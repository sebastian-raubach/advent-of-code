{"version":3,"file":"js/9130.d5f30d70.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCOtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAP,eAAAA,SAAAA,GACA,gBACA,QAEAQ,EAAAA,SAAAA,IACA,OACAC,KACA,yBACAC,EAAAA,GAAAA,MAAAA,EACA,IAGA,iDACA,gDACA,EACAC,aAAAA,SAAAA,GACA,MAEA,oCAEA,qBACA,eAGAC,EAAAA,EAAAA,EAAAA,EAAAA,EAGAF,EAAAA,GAAAA,KAAAA,IAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,EACA,CAGA,oBACA,sEACA,EACAG,aAAAA,SAAAA,GAEA,wBAEA,cACA,sEACA,EACAC,QAAAA,SAAAA,GAEA,gBAEA,MAEA,oCAEA,8CACA,YAEA,SAGAC,EAAAA,IAAAA,GAGA,qBACA,eAKAH,EAFA,+BAEAA,KAAAA,QAAAA,CAAAA,EAAAA,GAAAA,MAAAA,EAAAA,GAAAA,EAAAA,GAAAA,MAAAA,EAAAA,IAAAA,IAAAA,KAGAA,EAAAA,EAAAA,EAAAA,EAIAF,EAAAA,GAAAA,KAAAA,IAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,EACA,CACA,QACA,IC/F6P,I,UCOzPM,GAAY,OACd,EACA1B,EACAW,GACA,EACA,KACA,KACA,MAIF,EAAee,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2020/Day22.vue?395a","webpack://advent-of-code/src/components/2020/Day22.vue","webpack://advent-of-code/./src/components/2020/Day22.vue?b569","webpack://advent-of-code/./src/components/2020/Day22.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":22,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"22\" :year=\"2020\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const decks = [[], []]\n      let player = 0\n\n      input.forEach(i => {\n        if (i === '') {\n          player++\n        } else if (i.indexOf('Player') === -1) {\n          decks[player].push(+i)\n        }\n      })\n\n      this.solvePartOne(JSON.parse(JSON.stringify(decks)))\n      this.solvePartTwo(JSON.parse(JSON.stringify(decks)))\n    },\n    solvePartOne: function (decks) {\n      let winner\n      // As long as there are cards on both decks\n      while (decks[0].length > 0 && decks[1].length > 0) {\n        // Draw cards\n        const pOne = decks[0].shift()\n        const pTwo = decks[1].shift()\n\n        // Determine the winner\n        winner = pOne > pTwo ? 0 : 1\n\n        // Add the cards to the winner's deck\n        decks[winner].push(winner === 0 ? pOne : pTwo, winner === 0 ? pTwo : pOne)\n      }\n\n      // Calculate the result as the sum of the card values timed by their reverse index\n      const length = decks[winner].length\n      this.solutions.partOne = decks[winner].map((card, index) => card * (length - index)).reduce((a, b) => a + b)\n    },\n    solvePartTwo: function (decks) {\n      // Get the result recursively\n      const winner = this.recurse(decks)\n      // Calculate the result as the sum of the card values timed by their reverse index\n      const length = decks[winner].length\n      this.solutions.partTwo = decks[winner].map((card, index) => card * (length - index)).reduce((a, b) => a + b)\n    },\n    recurse: function (decks) {\n      // Remember previous configs\n      const prevConfigs = new Set()\n      // Remember the winner\n      let winner\n      // As long as there are cards on both decks\n      while (decks[0].length > 0 && decks[1].length > 0) {\n        // Calculate the current config\n        const config = `${decks[0].join(',')}|${decks[1].join(',')}`\n        if (prevConfigs.has(config)) {\n          // If we've seen it before, player 1 wins\n          return 0\n        }\n        // Add the config\n        prevConfigs.add(config)\n\n        // Draw cards\n        const pOne = decks[0].shift()\n        const pTwo = decks[1].shift()\n\n        // If there are enough cards for a sub-game\n        if (decks[0].length >= pOne && decks[1].length >= pTwo) {\n          // Determine the winner recursively\n          winner = this.recurse([decks[0].slice(0, pOne), decks[1].slice(0, pTwo)], new Set())\n        } else {\n          // Otherwise, handle same as part 1\n          winner = pOne > pTwo ? 0 : 1\n        }\n\n        // Add the cards to the winner's deck\n        decks[winner].push(winner === 0 ? pOne : pTwo, winner === 0 ? pTwo : pOne)\n      }\n      return winner\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day22.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day22.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day22.vue?vue&type=template&id=07705e81\"\nimport script from \"./Day22.vue?vue&type=script&lang=js\"\nexport * from \"./Day22.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","methods","input","player","decks","solvePartOne","winner","solvePartTwo","recurse","prevConfigs","component"],"sourceRoot":""}