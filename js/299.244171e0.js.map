{"version":3,"file":"js/299.244171e0.js","mappings":"yKAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,sBCQtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAP,eAAAA,SAAAA,GACA,WAEA,SAEAQ,EAAAA,SAAAA,IACA,QAEAC,EAAAA,KAAAA,CACAC,KAAAA,EACAC,MAAAA,EAAAA,EAAAA,GAAAA,EAAAA,KAAAA,GAAAA,EAAAA,MAAAA,OAAAA,KAAAA,GAAAA,EAAAA,KAAAA,QAEAC,EAAAA,IAEAA,EAAAA,KAAAA,EACA,IAEAH,EAAAA,KAAAA,CACAC,KAAAA,EACAC,MAAAA,EAAAA,EAAAA,GAAAA,EAAAA,KAAAA,GAAAA,EAAAA,MAAAA,OAAAA,KAAAA,GAAAA,EAAAA,KAAAA,QAIA,WAEA,kCAEA,gCAEA,0BASA,OANAE,EAAAA,KAAAA,CACAC,IAAAA,EACAC,IAAAA,IAIA,WACA,uBAEA,sCAEA,qCACA,aAGA,QACA,IAGAC,EAAAA,IAAAA,IAAAA,EAAAA,EAAAA,EAAAA,EAAAA,OAAAA,IACA,+BAEA,gBACAC,EAAAA,GAAAA,GAAAA,MAAAA,EAAAA,IAAAA,IACAC,EAAAA,GAAAA,GAAAA,EAAAA,GAAAA,GAGA,yDACA,mDAGA,iBAEAC,EAAAA,EACAC,EAAAA,EACA,OACA,CAEAH,EAAAA,GAAAA,GAAAA,EACAC,EAAAA,GAAAA,GAAAA,CACA,CAIA,kBACA,sBACA,EACAG,WAAAA,SAAAA,EAAAA,EAAAA,MAEA,2BAEA,yBAEA,2BAEA,KAEA,QAEA,CAIA,QACA,EACAC,SAAAA,SAAAA,EAAAA,GAEA,SACA,IAEA,SACA,sBAEA,MAGA,sBAEAC,GAAAA,EACA,KACA,CAGAC,GACA,CAEA,QACA,IC7I6P,I,UCOzPC,GAAY,OACd,EACAnC,EACAW,GACA,EACA,KACA,KACA,MAIF,EAAewB,EAAiB,O,+EClBhC,MAAMC,EAAMA,CAACC,EAAGC,KACLD,EAAIC,EAAKA,GAAKA,EAGnBC,EAAaZ,IACjB,MAAMP,EAAOO,EAAOa,OACdnB,EAAOM,EAAO,GAAGa,OACjBC,EAAO,GACb,IAAK,IAAIC,EAAI,EAAGA,EAAIrB,EAAMqB,IACxBD,EAAKC,GAAKC,MAAMvB,GAElB,IAAK,IAAIc,EAAI,EAAGA,EAAId,EAAMc,IACxB,IAAK,IAAIQ,EAAI,EAAGA,EAAIrB,EAAMqB,IACxBD,EAAKC,GAAGR,GAAKP,EAAOO,GAAGQ,GAG3B,OAAOD,CAAI,C","sources":["webpack://advent-of-code/./src/components/2023/Day13.vue?893e","webpack://advent-of-code/src/components/2023/Day13.vue","webpack://advent-of-code/./src/components/2023/Day13.vue?5597","webpack://advent-of-code/./src/components/2023/Day13.vue","webpack://advent-of-code/./src/util/math.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":13,\"year\":2023,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"13\" :year=\"2023\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\nimport { transpose } from '@/util/math'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const grids = []\n      // Cache the rows of each grid\n      let cache = []\n\n      input.forEach(i => {\n        if (i === '') {\n          // Push the cached rows as well as their transposed equivalents on the array\n          grids.push({\n            rows: cache,\n            cols: transpose(cache.map(c => c.split(''))).map(r => r.join(''))\n          })\n          cache = []\n        } else {\n          cache.push(i)\n        }\n      })\n      grids.push({\n        rows: cache,\n        cols: transpose(cache.map(c => c.split(''))).map(r => r.join(''))\n      })\n\n      // Remember part 1 solutions\n      const memory = []\n\n      this.solutions.partOne = grids.map(g => {\n        // Check if there's a mirror in the rows\n        const row = this.findMirror(g.rows)\n        // Check if there's a mirror in the columns\n        const col = this.findMirror(g.cols)\n\n        // Remember for part 2\n        memory.push({\n          row: row,\n          col: col\n        })\n\n        // Return the result\n        return col + row * 100\n      }).reduce((a, b) => a + b, 0)\n\n      this.solutions.partTwo = grids.map((g, gIndex) => {\n        // Split into matrix\n        const matrix = g.rows.map(r => r.split(''))\n        const transposed = transpose(matrix)\n\n        // Find the row and column indices that - when swapped - result in a different mirror\n        let overallCol = 0\n        let overallRow = 0\n\n        // Go through the whole matrix\n        outer: for (let y = 0; y < matrix.length; y++) {\n          for (let x = 0; x < matrix[y].length; x++) {\n            // Toggle the cell\n            const original = matrix[y][x]\n            matrix[y][x] = original === '.' ? '#' : '.'\n            transposed[x][y] = matrix[y][x]\n\n            // Try and see if there's a mirror in the swapped matrix or the transposed version (ignoring the original mirror from the memory)\n            const row = this.findMirror(matrix.map(r => r.join('')), memory[gIndex].row)\n            const col = this.findMirror(transposed.map(r => r.join('')), memory[gIndex].col)\n\n            // Match found\n            if ((row !== 0 || col !== 0)) {\n              // Remember the indices, then break out of loop\n              overallRow = row\n              overallCol = col\n              break outer\n            }\n\n            matrix[y][x] = original\n            transposed[x][y] = original\n          }\n        }\n\n        // Return the result\n        return overallCol + overallRow * 100\n      }).reduce((a, b) => a + b, 0)\n    },\n    findMirror: function (grid, ignoreIndex = null) {\n      // Starting from index 1\n      for (let i = 1; i < grid.length; i++) {\n        // Compare to i-1 and see if they're identical (and it's not an index we should ignore)\n        if (grid[i - 1] === grid[i] && i !== ignoreIndex) {\n          // Check it's actually a mirror by checking the neighboring indices as well\n          const isMirror = this.isMirror(grid, i)\n\n          if (isMirror) {\n            // Return index of mirror\n            return i\n          }\n        }\n      }\n\n      // Return 0 to get the correct result when calculating\n      return 0\n    },\n    isMirror: function (grid, index) {\n      // Assume it's a mirror\n      let result = true\n      let i = 0\n\n      while (true) {\n        if (!grid[index - i - 1] || !grid[index + i]) {\n          // If we run out of the array bounds, just stop looking\n          break\n        }\n\n        if (grid[index - i - 1] !== grid[index + i]) {\n          // If we find a pair that doesn't match, remember and break\n          result = false\n          break\n        }\n\n        // Check further outside\n        i++\n      }\n\n      return result\n    }\n  }\n}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day13.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day13.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day13.vue?vue&type=template&id=cddd9c64\"\nimport script from \"./Day13.vue?vue&type=script&lang=js\"\nexport * from \"./Day13.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const mod = (a, b) => {\n  return ((a % b) + b) % b\n}\n\nconst transpose = (matrix) => {\n  const rows = matrix.length\n  const cols = matrix[0].length\n  const grid = []\n  for (let j = 0; j < cols; j++) {\n    grid[j] = Array(rows)\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      grid[j][i] = matrix[i][j]\n    }\n  }\n  return grid\n}\n\nexport {\n  mod,\n  transpose\n}\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","methods","input","grids","rows","cols","cache","memory","row","col","outer","matrix","transposed","overallRow","overallCol","findMirror","isMirror","result","i","component","mod","a","b","transpose","length","grid","j","Array"],"sourceRoot":""}