{"version":3,"file":"js/8356.65e53556.js","mappings":"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","sources":["webpack://advent-of-code/./src/components/2020/Day20.vue?ae29","webpack://advent-of-code/./src/util/MonsterDrawer.js","webpack://advent-of-code/src/components/2020/Day20.vue","webpack://advent-of-code/./src/components/2020/Day20.vue?1f86","webpack://advent-of-code/./src/components/2020/Day20.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":20,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partTwo\",fn:function(){return [_c('pre',{staticClass:\"day-20-code border\"},[_c('code',{domProps:{\"innerHTML\":_vm._s(_vm.gridTwo)}}),_vm._v(\"\\n      \")])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export default class MonsterDrawer {\n  constructor (grid) {\n    this.$grid = grid\n  }\n\n  getFormattedGrid () {\n    let result = ''\n\n    for (let y = 0; y < this.$grid.length; y++) {\n      for (let x = 0; x < this.$grid[y].length; x++) {\n        if (this.$grid[y][x] === 'O') {\n          result += '<span class=\"day-20-monster\">O</span>'\n        } else {\n          result += this.$grid[y][x]\n        }\n      }\n      result += '<br/>'\n    }\n\n    return result\n  }\n}\n","<template>\n  <Day :day=\"20\" :year=\"2020\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partTwo>\n      <pre class=\"day-20-code border\">\n<code v-html=\"gridTwo\" />\n      </pre>\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nimport MonsterDrawer from '@/util/MonsterDrawer.js'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      gridTwo: null\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.gridTwo = null\n      this.parts = []\n\n      let id\n      let part = []\n      input.forEach(i => {\n        if (i === '') {\n          this.parts.push({\n            id,\n            part\n          })\n          id = null\n          part = []\n        } else if (i.includes('Tile ')) {\n          id = +(i.replace(/\\D/g, ''))\n        } else {\n          part.push(i.split('').map(c => c === '#'))\n        }\n      })\n\n      if (id !== null) {\n        this.parts.push({\n          id,\n          part\n        })\n      }\n\n      this.width = Math.sqrt(this.parts.length)\n\n      this.solvePartOne()\n      this.solvePartTwo()\n    },\n    rotateRight: function (part) {\n      return part[0].map((val, index) => part.map(row => row[index]).reverse())\n    },\n    flip: function (part) {\n      return part.map(p => p.map((c, index) => p[index]).reverse())\n    },\n    expand: function (parts) {\n      const expandedParts = []\n\n      parts.forEach(p => {\n        // Get all rotations\n        const zero = p.part\n        const ninety = this.rotateRight(zero)\n        const oneeighty = this.rotateRight(ninety)\n        const seventwenty = this.rotateRight(oneeighty)\n        // And their flipped options\n        const flipZero = this.flip(zero)\n        const flipNinety = this.flip(ninety)\n        const flipOneeighty = this.flip(oneeighty)\n        const flipSeventwenty = this.flip(seventwenty)\n\n        // Add them all\n        expandedParts.push({ id: p.id, part: zero })\n        expandedParts.push({ id: p.id, part: ninety })\n        expandedParts.push({ id: p.id, part: oneeighty })\n        expandedParts.push({ id: p.id, part: seventwenty })\n        expandedParts.push({ id: p.id, part: flipZero })\n        expandedParts.push({ id: p.id, part: flipNinety })\n        expandedParts.push({ id: p.id, part: flipOneeighty })\n        expandedParts.push({ id: p.id, part: flipSeventwenty })\n      })\n\n      // Keep track of the possible matches for each part\n      this.matches = {}\n      expandedParts.forEach(p => {\n        const m = expandedParts.filter(q => this.match(p.part, q.part, 'left') || this.match(p.part, q.part, 'top') || this.match(p.part, q.part, 'bottom') || this.match(p.part, q.part, 'right')).map(q => q.id)\n        if (!this.matches[p.id]) {\n          this.matches[p.id] = new Set()\n        }\n\n        m.filter(c => c !== p.id).forEach(c => this.matches[p.id].add(c))\n      })\n\n      return expandedParts\n    },\n    recurse: function (allParts, usedParts, index, usedIds) {\n      // Get the x and y position in the puzzle\n      const x = index % this.width\n      const y = Math.floor(index / this.width)\n\n      // If we've hit the last index (bottom right of the puzzle), return the used parts\n      if (index === this.parts.length) {\n        return usedParts\n      }\n\n      // Get the part to the left and the top if this one\n      const left = x > 0 ? usedParts[index - 1] : null\n      const top = y > 0 ? usedParts[index - this.width] : null\n\n      // Get all possible options for this position by exluding all the ones we've used already\n      const possibleParts = allParts.filter(p => usedIds.indexOf(p.id) === -1)\n\n      // Iterate through them all\n      for (let i = 0; i < possibleParts.length; i++) {\n        const p = possibleParts[i]\n        // If they match together\n        if ((!left || (this.matches[left.id].has(p.id) && this.match(left.part, p.part, 'right'))) && (!top || (this.matches[top.id].has(p.id) && this.match(top.part, p.part, 'bottom')))) {\n          // Take a copy of the arrays\n          const tempUsedParts = usedParts.concat()\n          const tempUsedIds = usedIds.concat()\n          // Add this one\n          tempUsedParts.push(p)\n          tempUsedIds.push(p.id)\n\n          // Continue recursively\n          const res = this.recurse(allParts, tempUsedParts, index + 1, tempUsedIds)\n\n          // If we found a result, return it\n          if (res !== null) {\n            return res\n          }\n        }\n      }\n\n      // We have not found a result\n      return null\n    },\n    match: function (one, two, side) {\n      switch (side) {\n        case 'bottom':\n          // Check the bottom of `one` matches the top of `two`\n          return JSON.stringify(one[one.length - 1]) === JSON.stringify(two[0])\n        case 'top':\n          // Check the top of `one` matches the bottom of `two`\n          return JSON.stringify(one[0]) === JSON.stringify(two[two.length - 1])\n        case 'right':\n          // Check the right of `one` matches the left of `two`\n          return JSON.stringify(one.map(r => r[r.length - 1])) === JSON.stringify(two.map(r => r[0]))\n        case 'left':\n          // Check the left of `one` matches the right of `two`\n          return JSON.stringify(one.map(r => r[0])) === JSON.stringify(two.map(r => r[r.length - 1]))\n      }\n    },\n    replaceAll: function (grid, monster) {\n      // Keep track of the number of monsters\n      let counter = 0\n      // Iterate through the grid\n      grid.forEach((row, y) => {\n        row.forEach((_, x) => {\n          // Keep track of whether all monster positions exist and are '#'s\n          const all = monster.filter(m => grid[y + m[0]] !== undefined && grid[y + m[0]][x + m[1]] === '#').length === monster.length\n\n          // If we have a complete monster, replace all parts with 'O's\n          if (all) {\n            monster.forEach(m => {\n              // Set it to 'O' to indicate it's been used\n              grid[y + m[0]][x + m[1]] = 'O'\n              counter++\n            })\n          }\n        })\n      })\n\n      return counter > 0\n    },\n    solvePartOne: function () {\n      // Expand the parts by getting all rotated and flipped options\n      const expanded = this.expand(this.parts)\n\n      // Solve this recursively. We start with all parts, no used parts, the top left index and no used ids.\n      this.usedParts = this.recurse(expanded, [], 0, [])\n\n      // The result is the corner ids multiplicated together\n      this.solutions.partOne = this.usedParts[0].id * this.usedParts[this.width - 1].id * this.usedParts[this.usedParts.length - 1].id * this.usedParts[this.usedParts.length - this.width].id\n    },\n    solvePartTwo: function () {\n      // Map each part by removing its border\n      const borderRemoved = this.usedParts.map(p => {\n        // Remove first and last row based on the index\n        return p.part.filter((row, index) => index !== 0 && index !== p.part.length - 1)\n         .map(row => {\n           // Within each row, remove first and last entry\n           row.shift()\n           row.pop()\n           return row.map(c => c ? '#' : '.').join('')\n         })\n      })\n\n      // Join them all together\n      const joined = []\n      // Iterate width in both dimensions across the parts\n      for (let y = 0; y < this.width; y++) {\n        for (let x = 0; x < this.width; x++) {\n          // Get the index of the part in our result\n          const part = borderRemoved[y * this.width + x]\n\n          // Within the part\n          for (let innerY = 0; innerY < part.length; innerY++) {\n            // Get the index in the joined grid\n            const joinedY = y * 8 + innerY\n            // If it doesn't exist, create it\n            if (joined.length <= joinedY) {\n              joined.push('')\n            }\n\n            // Then concatenate the parts\n            joined[joinedY] = joined[joinedY] + part[innerY]\n          }\n        }\n      }\n\n      // Finally, we split it back apart\n      const largeGrid = joined.map(j => j.split(''))\n\n      const rotatedAndFlipped = this.expand([{ id: null, part: largeGrid }])\n\n      // Define the monster as relative coordinates\n      const monster = [\n        [0, 18],\n        [1, 0], [1, 5], [1, 6], [1, 11], [1, 12], [1, 17], [1, 18], [1, 19],\n        [2, 1], [2, 4], [2, 7], [2, 10], [2, 13], [2, 16]\n      ]\n\n      rotatedAndFlipped.forEach(r => {\n        const part = r.part\n        // Check if the monster exists in there\n        if (this.replaceAll(part, monster)) {\n          // Count the non-monster '#'s\n          const counter = part.map(row => row.filter(c => c === '#').length).reduce((a, b) => a + b)\n\n          // Start the drawer\n          this.gridTwo = new MonsterDrawer(part).getFormattedGrid()\n\n          // The answer is the count\n          this.solutions.partTwo = counter\n        }\n      })\n    }\n  }\n}\n</script>\n\n<style>\n.day-20-code {\n  background-color: #2c3e50;\n  color: #7f8c8d;\n}\n.day-20-monster {\n  background-color: #2ecc71;\n  color: #2c3e50;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day20.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day20.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day20.vue?vue&type=template&id=01f27de8\"\nimport script from \"./Day20.vue?vue&type=script&lang=js\"\nexport * from \"./Day20.vue?vue&type=script&lang=js\"\nimport style0 from \"./Day20.vue?vue&type=style&index=0&id=01f27de8&prod&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","staticClass","domProps","_s","gridTwo","_v","proxy","staticRenderFns","MonsterDrawer","constructor","grid","$grid","getFormattedGrid","result","y","length","x","components","Day","data","partOne","partTwo","methods","input","id","part","rotateRight","flip","expand","parts","expandedParts","m","recurse","tempUsedParts","tempUsedIds","match","replaceAll","row","monster","counter","solvePartOne","solvePartTwo","map","joined","rotatedAndFlipped","component"],"sourceRoot":""}