{"version":3,"file":"js/1649.ff2a80d3.js","mappings":"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","sources":["webpack://advent-of-code/./src/components/2021/Day17.vue?525d","webpack://advent-of-code/src/components/2021/Day17.vue","webpack://advent-of-code/./src/components/2021/Day17.vue?023f","webpack://advent-of-code/./src/components/2021/Day17.vue","webpack://advent-of-code/./src/util/color.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":17,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{ref:\"canvasHolder\",staticClass:\"canvas-holder\"},[_c('canvas',{ref:\"partOne\",staticClass:\"canvas\",attrs:{\"width\":\"800\",\"height\":\"1080\"}})])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"17\" :year=\"2021\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partOne>\n      <div class=\"canvas-holder\" ref=\"canvasHolder\">\n        <canvas ref=\"partOne\" class=\"canvas\" width=\"800\" height=\"1080\" />\n      </div>\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\nimport { createColorGradient } from '@/util/color'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      canvasData: null\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Parse the input\n      const [x, y] = input[0].replace('target area: x=', '').split(', y=').map(c => c.split('..').map(d => +d))\n      const target = {\n        xMin: x[0],\n        xMax: x[1],\n        yMin: y[0],\n        yMax: y[1]\n      }\n\n      // Keep track of the max y and the count\n      let maxY = Number.NEGATIVE_INFINITY\n      let counter = 0\n      // Keep track of the individual points of each trajectory for plotting\n      const overallPoints = []\n\n      // Check all y's that are at least the bottom of the target area and at most the negative bottom\n      for (let velY = target.yMin; velY < -target.yMin; velY++) {\n        // Check all x's that are at most the right edge of the target and at least 1\n        for (let velX = target.xMax; velX > 0; velX--) {\n          // Check the trajectory\n          const [points, y] = this.getTrajectory({ x: velX, y: velY }, target)\n\n          if (y !== null) {\n            // Keep max y and increment counter\n            maxY = Math.max(maxY, y)\n            overallPoints.push(points)\n            counter++\n          }\n        }\n      }\n\n      this.solutions.partOne = maxY\n      this.solutions.partTwo = counter\n\n      // Plot\n      this.$nextTick(() => {\n        this.plotPoints(overallPoints, target)\n        this.$refs.canvasHolder.scrollTop = this.$refs.canvasHolder.scrollHeight\n      })\n    },\n    getTrajectory: function (velocity, target) {\n      // Start at the origin\n      const curr = {\n        x: 0,\n        y: 0\n      }\n\n      // Keep track of the maximum x we've seen\n      let maxY = Number.NEGATIVE_INFINITY\n      // Keep track of all points on the trajectory\n      const points = []\n\n      // While we've not shot past the max x or the min y\n      while (curr.x <= target.xMax && curr.y >= target.yMin) {\n        // Adjust coordinates\n        curr.x += velocity.x\n        curr.y += velocity.y\n\n        points.push([curr.x, curr.y])\n\n        // Get max y\n        maxY = Math.max(maxY, curr.y)\n\n        // Adjust velocity\n        velocity.x -= Math.sign(velocity.x)\n        velocity.y--\n\n        // Check if we're in the target area\n        if (curr.x >= target.xMin && curr.x <= target.xMax && curr.y >= target.yMin && curr.y <= target.yMax) {\n          return [points, maxY]\n        }\n      }\n\n      return [null, null]\n    },\n    plotPoints: function (overallPoints, target) {\n      // Get the bounding box\n      const edges = {\n        top: Math.max(0, target.yMax),\n        left: Math.min(0, target.xMin),\n        bottom: Math.min(0, target.yMin),\n        right: Math.max(0, target.xMax)\n      }\n      overallPoints.forEach(set => {\n        set.forEach(p => {\n          edges.top = Math.max(edges.top, p[1])\n          edges.left = Math.min(edges.left, p[0])\n          edges.bottom = Math.min(edges.bottom, p[1])\n          edges.right = Math.max(edges.right, p[0])\n        })\n      })\n\n      // Set the canvas size and translate the origin\n      const canvas = this.$refs.partOne\n      canvas.width = Math.abs(edges.right) + Math.abs(edges.left)\n      canvas.height = Math.abs(edges.top) + Math.abs(edges.bottom)\n      const ctx = canvas.getContext('2d')\n      ctx.translate(Math.abs(edges.left), Math.abs(edges.top))\n\n      // Draw the origin\n      ctx.fillStyle = 'red'\n      ctx.fillRect(0, 0, 1, 1)\n\n      // Draw all trajectories\n      overallPoints.forEach(set => {\n        // Generate a gradient each\n        const gradient = createColorGradient('#006266', '#C4E538', set.length)\n\n        for (let i = 0; i < set.length - 1; i++) {\n          ctx.strokeStyle = gradient[i]\n          ctx.beginPath()\n          ctx.moveTo(set[i][0], -set[i][1])\n          ctx.lineTo(set[i + 1][0], -set[i + 1][1])\n          ctx.stroke()\n        }\n      })\n\n      // Mark the target\n      ctx.strokeStyle = 'red'\n      ctx.beginPath()\n      ctx.moveTo(target.xMin, -target.yMin)\n      ctx.lineTo(target.xMin, -target.yMax)\n      ctx.lineTo(target.xMax, -target.yMax)\n      ctx.lineTo(target.xMax, -target.yMin)\n      ctx.lineTo(target.xMin, -target.yMin)\n      ctx.stroke()\n    }\n  }\n}\n</script>\n\n<style scoped>\n.canvas-holder {\n  overflow: auto;\n  height: 1080px;\n  width: 100%;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day17.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day17.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day17.vue?vue&type=template&id=39326bc6&scoped=true\"\nimport script from \"./Day17.vue?vue&type=script&lang=js\"\nexport * from \"./Day17.vue?vue&type=script&lang=js\"\nimport style0 from \"./Day17.vue?vue&type=style&index=0&id=39326bc6&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"39326bc6\",\n  null\n  \n)\n\nexport default component.exports","const VIRIDIS = ['#440154', '#48186a', '#472d7b', '#424086', '#3b528b', '#33638d', '#2c728e', '#26828e', '#21918c', '#1fa088', '#28ae80', '#3fbc73', '#5ec962', '#84d44b', '#addc30', '#d8e219', '#fde725']\n\n/**\n * Converts a HEX value into an RGB object\n * @param {String} hex The hex color\n */\nconst hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    }\n    : null\n}\n\n/**\n * Converts the given R, G, B values into a HEX color\n * @param {Number} r The red color component\n * @param {Number} g The green color component\n * @param {Number} b The blue color component\n */\nconst rgbToHex = (r, g, b) => {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n}\n\n/**\n * Creates a linear gradient between the two given colors with the given number of steps\n * @param {String} one The first color in HEX\n * @param {String} two The second color in HEX\n * @param {Number} steps The number of steps between the two colors\n */\nconst createColorGradient = (one, two, steps) => {\n  const oneRgb = hexToRgb(one)\n  const twoRgb = hexToRgb(two)\n\n  if (steps < 2) {\n    return [one]\n  }\n\n  const result = []\n  for (let i = 0; i < steps; i++) {\n    const iNorm = (i / (steps - 1))\n    result.push(rgbToHex(\n      Math.floor(oneRgb.r + iNorm * (twoRgb.r - oneRgb.r)),\n      Math.floor(oneRgb.g + iNorm * (twoRgb.g - oneRgb.g)),\n      Math.floor(oneRgb.b + iNorm * (twoRgb.b - oneRgb.b))\n    ))\n  }\n  return result\n}\n\nconst createMultiColorGradient = (colors, steps) => {\n  if (colors.length > steps) {\n    return colors.slice(0, steps)\n  }\n\n  const sections = colors.length - 1\n\n  let result = []\n\n  for (let i = 0; i < sections - 1; i++) {\n    result = result.concat(createColorGradient(colors[i], colors[i + 1], Math.max(1, Math.floor(steps / sections))))\n  }\n\n  while (result.length < steps) {\n    result.push(colors[colors.length - 1])\n  }\n\n  return result\n}\n\nexport {\n  hexToRgb,\n  rgbToHex,\n  createColorGradient,\n  createMultiColorGradient,\n  VIRIDIS\n}\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","ref","staticClass","proxy","staticRenderFns","components","Day","data","partOne","partTwo","canvasData","methods","xMin","xMax","yMin","yMax","x","y","maxY","overallPoints","counter","getTrajectory","curr","points","velocity","plotPoints","top","left","bottom","right","set","edges","canvas","ctx","component","VIRIDIS","hexToRgb","hex","result","exec","r","parseInt","g","b","rgbToHex","toString","slice","createColorGradient","one","two","steps","oneRgb","twoRgb","i","iNorm","push","Math","floor","createMultiColorGradient","colors","length","sections","concat","max"],"sourceRoot":""}