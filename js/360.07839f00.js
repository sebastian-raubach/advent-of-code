"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[360],{27540:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day22)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day22.vue?vue&type=template&id=dd7e63ec\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":22,\"year\":2018,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('pre',{staticClass:\"day-22-code border\"},[_c('code',{domProps:{\"innerHTML\":_vm._s(_vm.gridOne)}}),_vm._v(\"\\n      \")])]},proxy:true},{key:\"partTwo\",fn:function(){return [_c('pre',{staticClass:\"day-22-code border\"},[_c('code',{domProps:{\"innerHTML\":_vm._s(_vm.gridTwo)}}),_vm._v(\"\\n      \")])]},proxy:true}])})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day22.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\nconst ROCKY = '.';\nconst WET = '=';\nconst NARROW = '|';\nconst TORCH = 0;\nconst GEAR = 1;\nconst NONE = 2;\nconst BOTH = 3;\n/* harmony default export */ const Day22vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      gridOne: null,\n      risk: {\n        '.': 0,\n        '=': 1,\n        '|': 2\n      },\n      types: [ROCKY, WET, NARROW],\n      directions: [[1, 0], [0, 1], [-1, 0], [0, -1]],\n      validGear: {\n        '.': [GEAR, TORCH, BOTH],\n        '=': [GEAR, NONE],\n        '|': [TORCH, NONE]\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.depth = +input[0].split(' ')[1];\n      this.target = input[1].split(' ')[1].split(',').map(c => +c);\n      this.solvePartOne();\n      this.solvePartTwo();\n    },\n    getGeoIndex: function (grid, x, y) {\n      if (x === 0 && y === 0 || x === this.target[0] && y === this.target[1]) {\n        // Top left and target have an index of 0\n        return 0;\n      } else if (y === 0) {\n        // Top row uses x index\n        return x * 16807;\n      } else if (x === 0) {\n        // First column uses y index\n        return y * 48271;\n      } else {\n        // Everything else uses the index based on the cell to the top and the one to the left\n        return grid[y][x - 1].erosionLevel * grid[y - 1][x].erosionLevel;\n      }\n    },\n    solvePartOne: function () {\n      this.grid = [];\n      // Factor 2 was working for me, but just in case I increased this to 3\n      const sizeFactor = 3;\n\n      // Create the grid\n      for (let y = 0; y <= this.target[1] + 50; y++) {\n        // Add a  row\n        this.grid.push(Array.from(Array(this.target[0] * sizeFactor + 1).keys()).map(i => {\n          return {\n            geoIndex: null,\n            erosionLevel: null,\n            type: null\n          };\n        }));\n        for (let x = 0; x <= this.target[0] * sizeFactor; x++) {\n          // Calculate the index, erosion level and type\n          this.grid[y][x].geoIndex = this.getGeoIndex(this.grid, x, y);\n          this.grid[y][x].erosionLevel = (this.grid[y][x].geoIndex + this.depth) % 20183;\n          this.grid[y][x].type = this.types[this.grid[y][x].erosionLevel % 3];\n        }\n      }\n\n      // Print the grid\n      this.gridOne = this.print(this.grid.map(r => r.map(c => c.type)));\n      // Sum up all risks within the rectangle\n      this.solutions.partOne = this.grid.slice(0, this.target[1] + 1).map(r => r.slice(0, this.target[0] + 1).map(c => this.risk[c.type]).reduce((a, b) => a + b)).reduce((a, b) => a + b);\n    },\n    solvePartTwo: function () {\n      // Start location\n      const start = {\n        tool: TORCH,\n        x: 0,\n        y: 0,\n        type: ROCKY,\n        time: 0,\n        path: []\n      };\n\n      // Priority queue\n      const configs = [start];\n      // Keep track of best times for x,y,tool combinations\n      const bestTime = new Map();\n      bestTime.set(`${start.x},${start.y},${start.tool}`, 0);\n\n      // Do a breadth-first-search\n      while (true) {\n        // Sort them to get the one with the fewest steps\n        configs.sort((a, b) => a.time - b.time);\n\n        // Get the one with the lowest time\n        const current = configs.shift();\n\n        // If we get to the target, output the time\n        if (current.x === this.target[0] && current.y === this.target[1]) {\n          this.gridTwo = this.print(this.grid.map(r => r.map(c => c.type)), current.path);\n          this.solutions.partTwo = current.time;\n          return;\n        }\n        this.directions.forEach(d => {\n          // Take a copy and adjust the coordinates\n          const next = JSON.parse(JSON.stringify(current));\n          next.x += d[0];\n          next.y += d[1];\n\n          // If we're outside the grid, return\n          if (next.y < 0 || next.x < 0 || next.y >= this.grid.length || next.x >= this.grid[next.y].length) {\n            return;\n          }\n\n          // Get the type from the grid\n          next.type = this.grid[next.y][next.x].type;\n          // Adjust the configuration (time + tool)\n          this.adjustConfig(current, next);\n          const bt = bestTime.get(`${next.x},${next.y},${next.tool}`);\n          // If there's already a faster way to get here, return\n          if (bt !== undefined && bt <= next.time) {\n            return;\n          }\n\n          // If the next one is the target, but we're using the wrong tool, add 7 to the time\n          if (next.x === this.target[0] && next.y === this.target[1]) {\n            if (next.tool !== TORCH) {\n              next.time += 7;\n            }\n          }\n\n          // Remember the path\n          next.path.push({\n            x: next.x,\n            y: next.y\n          });\n          // Add the new config\n          configs.push(next);\n          // Remember the time\n          bestTime.set(`${next.x},${next.y},${next.tool}`, next.time);\n        });\n      }\n    },\n    adjustConfig: function (current, next) {\n      if (current.type === next.type) {\n        // Just increase the time by 1\n        next.time++;\n      } else {\n        // Get the intersection of gear, because we have to both switch in the current one and enter the next one\n        const toolsAllowedInBoth = this.validGear[current.type].filter(v => this.validGear[next.type].includes(v));\n\n        // Add the time for either switching tool and moving or simply moving\n        next.time += toolsAllowedInBoth[0] !== current.tool ? 7 + 1 : 1;\n        // Then adjust the tool\n        next.tool = toolsAllowedInBoth[0];\n      }\n    },\n    print: function (grid, path) {\n      const onPath = new Set();\n      if (path) {\n        path.forEach(p => onPath.add(`${p.x},${p.y}`));\n      }\n      let result = '';\n      for (let y = 0; y < grid.length; y++) {\n        for (let x = 0; x < grid[y].length; x++) {\n          let clazz = null;\n          if (onPath.has(`${x},${y}`)) {\n            clazz = 'day-22-path';\n          } else if (grid[y][x] === WET) {\n            clazz = 'day-22-wet';\n          } else if (grid[y][x] === NARROW) {\n            clazz = 'day-22-narrow';\n          }\n          if (clazz) {\n            result += `<span class=\"${clazz}\">${grid[y][x]}</span>`;\n          } else {\n            result += grid[y][x];\n          }\n        }\n        result += '<br/>';\n      }\n      return result;\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2018/Day22.vue?vue&type=script&lang=js\n /* harmony default export */ const _2018_Day22vue_type_script_lang_js = (Day22vue_type_script_lang_js); \n;// CONCATENATED MODULE: ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-12.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day22.vue?vue&type=style&index=0&id=dd7e63ec&prod&lang=css\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./src/components/2018/Day22.vue?vue&type=style&index=0&id=dd7e63ec&prod&lang=css\n\n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2018/Day22.vue\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2018_Day22vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day22 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc1NDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxtQ0FBbUMsc0JBQXNCLDRCQUE0QixrQkFBa0IsaUNBQWlDLGFBQWEsVUFBVSxpQ0FBaUMsd0JBQXdCLFlBQVksRUFBRSw0QkFBNEIsa0JBQWtCLGlDQUFpQyxhQUFhLFVBQVUsaUNBQWlDLHdCQUF3QixZQUFZLEdBQUc7QUFDempCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLG1FQUFlO0VBQ2ZBO0lBQ0FDLEdBQUFBLEVBQUFBLGtCQUFBQTtFQUNBO0VBQ0FDO0lBQ0E7TUFDQUM7UUFDQUM7UUFDQUM7TUFDQTtNQUNBQztNQUNBQztRQUNBO1FBQ0E7UUFDQTtNQUNBO01BQ0FDO01BQ0FDO01BQ0FDO1FBQ0E7UUFDQTtRQUNBO01BQ0E7SUFDQTtFQUNBO0VBQ0FDO0lBQ0FDO01BQ0E7TUFDQTtNQUNBO01BQ0E7SUFDQTtJQUNBQztNQUNBO1FBQ0E7UUFDQTtNQUNBO1FBQ0E7UUFDQTtNQUNBO1FBQ0E7UUFDQTtNQUNBO1FBQ0E7UUFDQTtNQUNBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBO01BQ0E7O01BRUE7TUFDQTtRQUNBO1FBQ0E7VUFBQTtZQUFBQztZQUFBQztZQUFBQztVQUFBO1FBQUE7UUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTtRQUNBQztRQUNBQztRQUNBQztRQUNBSjtRQUNBSztRQUNBQztNQUNBOztNQUVBO01BQ0E7TUFDQTtNQUNBO01BQ0FDOztNQUVBO01BQ0E7UUFDQTtRQUNBQzs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7VUFDQTtVQUNBO1VBQ0E7UUFDQTtRQUVBO1VBQ0E7VUFDQTtVQUNBQztVQUNBQTs7VUFFQTtVQUNBO1lBQ0E7VUFDQTs7VUFFQTtVQUNBQTtVQUNBO1VBQ0E7VUFFQTtVQUNBO1VBQ0E7WUFDQTtVQUNBOztVQUVBO1VBQ0E7WUFDQTtjQUNBQTtZQUNBO1VBQ0E7O1VBRUE7VUFDQUE7WUFDQU47WUFDQUM7VUFDQTtVQUNBO1VBQ0FJO1VBQ0E7VUFDQUQ7UUFDQTtNQUNBO0lBQ0E7SUFDQUc7TUFDQTtRQUNBO1FBQ0FEO01BQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0FBO1FBQ0E7UUFDQUE7TUFDQTtJQUNBO0lBQ0FFO01BQ0E7TUFFQTtRQUNBTDtNQUNBO01BRUE7TUFDQTtRQUNBO1VBQ0E7VUFDQTtZQUNBTTtVQUNBO1lBQ0FBO1VBQ0E7WUFDQUE7VUFDQTtVQUVBO1lBQ0FDO1VBQ0E7WUFDQUE7VUFDQTtRQUNBO1FBQ0FBO01BQ0E7TUFDQTtJQUNBO0VBQ0E7QUFDQSxDQUFDLEU7O0FDck4yUCxDQUFDLHlFQUFlLDRCQUFHLEVBQUMsQzs7QUNBaFI7Ozs7Ozs7QUVBbUY7QUFDM0I7QUFDTDtBQUNuRCxDQUFpRjs7O0FBR2pGO0FBQ3NHO0FBQ3RHLGdCQUFnQixzQ0FBVTtBQUMxQixFQUFFLGtDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkyMi52dWU/YjA0NiIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS9zcmMvY29tcG9uZW50cy8yMDE4L0RheTIyLnZ1ZT84OWUwIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkyMi52dWU/YWU1MiIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTgvRGF5MjIudnVlP2VhYzkiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDE4L0RheTIyLnZ1ZT83NGIxIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkyMi52dWU/ZWI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnRGF5Jyx7YXR0cnM6e1wiZGF5XCI6MjIsXCJ5ZWFyXCI6MjAxOCxcInNvbHV0aW9uc1wiOl92bS5zb2x1dGlvbnN9LG9uOntcImlucHV0LWNoYW5nZWRcIjpfdm0ub25JbnB1dENoYW5nZWR9LHNjb3BlZFNsb3RzOl92bS5fdShbe2tleTpcInBhcnRPbmVcIixmbjpmdW5jdGlvbigpe3JldHVybiBbX2MoJ3ByZScse3N0YXRpY0NsYXNzOlwiZGF5LTIyLWNvZGUgYm9yZGVyXCJ9LFtfYygnY29kZScse2RvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhfdm0uZ3JpZE9uZSl9fSksX3ZtLl92KFwiXFxuICAgICAgXCIpXSldfSxwcm94eTp0cnVlfSx7a2V5OlwicGFydFR3b1wiLGZuOmZ1bmN0aW9uKCl7cmV0dXJuIFtfYygncHJlJyx7c3RhdGljQ2xhc3M6XCJkYXktMjItY29kZSBib3JkZXJcIn0sW19jKCdjb2RlJyx7ZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKF92bS5ncmlkVHdvKX19KSxfdm0uX3YoXCJcXG4gICAgICBcIildKV19LHByb3h5OnRydWV9XSl9KX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIyMlwiIDp5ZWFyPVwiMjAxOFwiIDpzb2x1dGlvbnM9XCJzb2x1dGlvbnNcIiBAaW5wdXQtY2hhbmdlZD1cIm9uSW5wdXRDaGFuZ2VkXCI+XG4gICAgPHRlbXBsYXRlIHYtc2xvdDpwYXJ0T25lPlxuICAgICAgPHByZSBjbGFzcz1cImRheS0yMi1jb2RlIGJvcmRlclwiPlxuPGNvZGUgdi1odG1sPVwiZ3JpZE9uZVwiIC8+XG4gICAgICA8L3ByZT5cbiAgICA8L3RlbXBsYXRlPlxuICAgIDx0ZW1wbGF0ZSB2LXNsb3Q6cGFydFR3bz5cbiAgICAgIDxwcmUgY2xhc3M9XCJkYXktMjItY29kZSBib3JkZXJcIj5cbjxjb2RlIHYtaHRtbD1cImdyaWRUd29cIiAvPlxuICAgICAgPC9wcmU+XG4gICAgPC90ZW1wbGF0ZT5cbiAgPC9EYXk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IERheSBmcm9tICdAL2NvbXBvbmVudHMvRGF5J1xuXG5jb25zdCBST0NLWSA9ICcuJ1xuY29uc3QgV0VUID0gJz0nXG5jb25zdCBOQVJST1cgPSAnfCdcblxuY29uc3QgVE9SQ0ggPSAwXG5jb25zdCBHRUFSID0gMVxuY29uc3QgTk9ORSA9IDJcbmNvbnN0IEJPVEggPSAzXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIERheVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvbHV0aW9uczoge1xuICAgICAgICBwYXJ0T25lOiBudWxsLFxuICAgICAgICBwYXJ0VHdvOiBudWxsXG4gICAgICB9LFxuICAgICAgZ3JpZE9uZTogbnVsbCxcbiAgICAgIHJpc2s6IHtcbiAgICAgICAgJy4nOiAwLFxuICAgICAgICAnPSc6IDEsXG4gICAgICAgICd8JzogMlxuICAgICAgfSxcbiAgICAgIHR5cGVzOiBbUk9DS1ksIFdFVCwgTkFSUk9XXSxcbiAgICAgIGRpcmVjdGlvbnM6IFtbMSwgMF0sIFswLCAxXSwgWy0xLCAwXSwgWzAsIC0xXV0sXG4gICAgICB2YWxpZEdlYXI6IHtcbiAgICAgICAgJy4nOiBbR0VBUiwgVE9SQ0gsIEJPVEhdLFxuICAgICAgICAnPSc6IFtHRUFSLCBOT05FXSxcbiAgICAgICAgJ3wnOiBbVE9SQ0gsIE5PTkVdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25JbnB1dENoYW5nZWQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdGhpcy5kZXB0aCA9ICtpbnB1dFswXS5zcGxpdCgnICcpWzFdXG4gICAgICB0aGlzLnRhcmdldCA9IGlucHV0WzFdLnNwbGl0KCcgJylbMV0uc3BsaXQoJywnKS5tYXAoYyA9PiArYylcbiAgICAgIHRoaXMuc29sdmVQYXJ0T25lKClcbiAgICAgIHRoaXMuc29sdmVQYXJ0VHdvKClcbiAgICB9LFxuICAgIGdldEdlb0luZGV4OiBmdW5jdGlvbiAoZ3JpZCwgeCwgeSkge1xuICAgICAgaWYgKCh4ID09PSAwICYmIHkgPT09IDApIHx8ICh4ID09PSB0aGlzLnRhcmdldFswXSAmJiB5ID09PSB0aGlzLnRhcmdldFsxXSkpIHtcbiAgICAgICAgLy8gVG9wIGxlZnQgYW5kIHRhcmdldCBoYXZlIGFuIGluZGV4IG9mIDBcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoeSA9PT0gMCkge1xuICAgICAgICAvLyBUb3Agcm93IHVzZXMgeCBpbmRleFxuICAgICAgICByZXR1cm4geCAqIDE2ODA3XG4gICAgICB9IGVsc2UgaWYgKHggPT09IDApIHtcbiAgICAgICAgLy8gRmlyc3QgY29sdW1uIHVzZXMgeSBpbmRleFxuICAgICAgICByZXR1cm4geSAqIDQ4MjcxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgdXNlcyB0aGUgaW5kZXggYmFzZWQgb24gdGhlIGNlbGwgdG8gdGhlIHRvcCBhbmQgdGhlIG9uZSB0byB0aGUgbGVmdFxuICAgICAgICByZXR1cm4gZ3JpZFt5XVt4IC0gMV0uZXJvc2lvbkxldmVsICogZ3JpZFt5IC0gMV1beF0uZXJvc2lvbkxldmVsXG4gICAgICB9XG4gICAgfSxcbiAgICBzb2x2ZVBhcnRPbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZ3JpZCA9IFtdXG4gICAgICAvLyBGYWN0b3IgMiB3YXMgd29ya2luZyBmb3IgbWUsIGJ1dCBqdXN0IGluIGNhc2UgSSBpbmNyZWFzZWQgdGhpcyB0byAzXG4gICAgICBjb25zdCBzaXplRmFjdG9yID0gM1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIGdyaWRcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IHRoaXMudGFyZ2V0WzFdICsgNTA7IHkrKykge1xuICAgICAgICAvLyBBZGQgYSAgcm93XG4gICAgICAgIHRoaXMuZ3JpZC5wdXNoKEFycmF5LmZyb20oQXJyYXkodGhpcy50YXJnZXRbMF0gKiBzaXplRmFjdG9yICsgMSkua2V5cygpKS5tYXAoaSA9PiB7IHJldHVybiB7IGdlb0luZGV4OiBudWxsLCBlcm9zaW9uTGV2ZWw6IG51bGwsIHR5cGU6IG51bGwgfSB9KSlcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gdGhpcy50YXJnZXRbMF0gKiBzaXplRmFjdG9yOyB4KyspIHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluZGV4LCBlcm9zaW9uIGxldmVsIGFuZCB0eXBlXG4gICAgICAgICAgdGhpcy5ncmlkW3ldW3hdLmdlb0luZGV4ID0gdGhpcy5nZXRHZW9JbmRleCh0aGlzLmdyaWQsIHgsIHkpXG4gICAgICAgICAgdGhpcy5ncmlkW3ldW3hdLmVyb3Npb25MZXZlbCA9ICh0aGlzLmdyaWRbeV1beF0uZ2VvSW5kZXggKyB0aGlzLmRlcHRoKSAlIDIwMTgzXG4gICAgICAgICAgdGhpcy5ncmlkW3ldW3hdLnR5cGUgPSB0aGlzLnR5cGVzW3RoaXMuZ3JpZFt5XVt4XS5lcm9zaW9uTGV2ZWwgJSAzXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFByaW50IHRoZSBncmlkXG4gICAgICB0aGlzLmdyaWRPbmUgPSB0aGlzLnByaW50KHRoaXMuZ3JpZC5tYXAociA9PiByLm1hcChjID0+IGMudHlwZSkpKVxuICAgICAgLy8gU3VtIHVwIGFsbCByaXNrcyB3aXRoaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgdGhpcy5zb2x1dGlvbnMucGFydE9uZSA9IHRoaXMuZ3JpZC5zbGljZSgwLCB0aGlzLnRhcmdldFsxXSArIDEpLm1hcChyID0+IHIuc2xpY2UoMCwgdGhpcy50YXJnZXRbMF0gKyAxKS5tYXAoYyA9PiB0aGlzLnJpc2tbYy50eXBlXSkucmVkdWNlKChhLCBiKSA9PiBhICsgYikpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpXG4gICAgfSxcbiAgICBzb2x2ZVBhcnRUd286IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFN0YXJ0IGxvY2F0aW9uXG4gICAgICBjb25zdCBzdGFydCA9IHtcbiAgICAgICAgdG9vbDogVE9SQ0gsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHR5cGU6IFJPQ0tZLFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBwYXRoOiBbXVxuICAgICAgfVxuXG4gICAgICAvLyBQcmlvcml0eSBxdWV1ZVxuICAgICAgY29uc3QgY29uZmlncyA9IFtzdGFydF1cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgYmVzdCB0aW1lcyBmb3IgeCx5LHRvb2wgY29tYmluYXRpb25zXG4gICAgICBjb25zdCBiZXN0VGltZSA9IG5ldyBNYXAoKVxuICAgICAgYmVzdFRpbWUuc2V0KGAke3N0YXJ0Lnh9LCR7c3RhcnQueX0sJHtzdGFydC50b29sfWAsIDApXG5cbiAgICAgIC8vIERvIGEgYnJlYWR0aC1maXJzdC1zZWFyY2hcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIFNvcnQgdGhlbSB0byBnZXQgdGhlIG9uZSB3aXRoIHRoZSBmZXdlc3Qgc3RlcHNcbiAgICAgICAgY29uZmlncy5zb3J0KChhLCBiKSA9PiBhLnRpbWUgLSBiLnRpbWUpXG5cbiAgICAgICAgLy8gR2V0IHRoZSBvbmUgd2l0aCB0aGUgbG93ZXN0IHRpbWVcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNvbmZpZ3Muc2hpZnQoKVxuXG4gICAgICAgIC8vIElmIHdlIGdldCB0byB0aGUgdGFyZ2V0LCBvdXRwdXQgdGhlIHRpbWVcbiAgICAgICAgaWYgKGN1cnJlbnQueCA9PT0gdGhpcy50YXJnZXRbMF0gJiYgY3VycmVudC55ID09PSB0aGlzLnRhcmdldFsxXSkge1xuICAgICAgICAgIHRoaXMuZ3JpZFR3byA9IHRoaXMucHJpbnQodGhpcy5ncmlkLm1hcChyID0+IHIubWFwKGMgPT4gYy50eXBlKSksIGN1cnJlbnQucGF0aClcbiAgICAgICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gY3VycmVudC50aW1lXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcmVjdGlvbnMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAvLyBUYWtlIGEgY29weSBhbmQgYWRqdXN0IHRoZSBjb29yZGluYXRlc1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGN1cnJlbnQpKVxuICAgICAgICAgIG5leHQueCArPSBkWzBdXG4gICAgICAgICAgbmV4dC55ICs9IGRbMV1cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIG91dHNpZGUgdGhlIGdyaWQsIHJldHVyblxuICAgICAgICAgIGlmIChuZXh0LnkgPCAwIHx8IG5leHQueCA8IDAgfHwgbmV4dC55ID49IHRoaXMuZ3JpZC5sZW5ndGggfHwgbmV4dC54ID49IHRoaXMuZ3JpZFtuZXh0LnldLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2V0IHRoZSB0eXBlIGZyb20gdGhlIGdyaWRcbiAgICAgICAgICBuZXh0LnR5cGUgPSB0aGlzLmdyaWRbbmV4dC55XVtuZXh0LnhdLnR5cGVcbiAgICAgICAgICAvLyBBZGp1c3QgdGhlIGNvbmZpZ3VyYXRpb24gKHRpbWUgKyB0b29sKVxuICAgICAgICAgIHRoaXMuYWRqdXN0Q29uZmlnKGN1cnJlbnQsIG5leHQpXG5cbiAgICAgICAgICBjb25zdCBidCA9IGJlc3RUaW1lLmdldChgJHtuZXh0Lnh9LCR7bmV4dC55fSwke25leHQudG9vbH1gKVxuICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBhIGZhc3RlciB3YXkgdG8gZ2V0IGhlcmUsIHJldHVyblxuICAgICAgICAgIGlmIChidCAhPT0gdW5kZWZpbmVkICYmIGJ0IDw9IG5leHQudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIG5leHQgb25lIGlzIHRoZSB0YXJnZXQsIGJ1dCB3ZSdyZSB1c2luZyB0aGUgd3JvbmcgdG9vbCwgYWRkIDcgdG8gdGhlIHRpbWVcbiAgICAgICAgICBpZiAobmV4dC54ID09PSB0aGlzLnRhcmdldFswXSAmJiBuZXh0LnkgPT09IHRoaXMudGFyZ2V0WzFdKSB7XG4gICAgICAgICAgICBpZiAobmV4dC50b29sICE9PSBUT1JDSCkge1xuICAgICAgICAgICAgICBuZXh0LnRpbWUgKz0gN1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBwYXRoXG4gICAgICAgICAgbmV4dC5wYXRoLnB1c2goe1xuICAgICAgICAgICAgeDogbmV4dC54LFxuICAgICAgICAgICAgeTogbmV4dC55XG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBjb25maWdcbiAgICAgICAgICBjb25maWdzLnB1c2gobmV4dClcbiAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgdGltZVxuICAgICAgICAgIGJlc3RUaW1lLnNldChgJHtuZXh0Lnh9LCR7bmV4dC55fSwke25leHQudG9vbH1gLCBuZXh0LnRpbWUpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICBhZGp1c3RDb25maWc6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXh0KSB7XG4gICAgICBpZiAoY3VycmVudC50eXBlID09PSBuZXh0LnR5cGUpIHtcbiAgICAgICAgLy8gSnVzdCBpbmNyZWFzZSB0aGUgdGltZSBieSAxXG4gICAgICAgIG5leHQudGltZSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiBnZWFyLCBiZWNhdXNlIHdlIGhhdmUgdG8gYm90aCBzd2l0Y2ggaW4gdGhlIGN1cnJlbnQgb25lIGFuZCBlbnRlciB0aGUgbmV4dCBvbmVcbiAgICAgICAgY29uc3QgdG9vbHNBbGxvd2VkSW5Cb3RoID0gdGhpcy52YWxpZEdlYXJbY3VycmVudC50eXBlXS5maWx0ZXIodiA9PiB0aGlzLnZhbGlkR2VhcltuZXh0LnR5cGVdLmluY2x1ZGVzKHYpKVxuXG4gICAgICAgIC8vIEFkZCB0aGUgdGltZSBmb3IgZWl0aGVyIHN3aXRjaGluZyB0b29sIGFuZCBtb3Zpbmcgb3Igc2ltcGx5IG1vdmluZ1xuICAgICAgICBuZXh0LnRpbWUgKz0gdG9vbHNBbGxvd2VkSW5Cb3RoWzBdICE9PSBjdXJyZW50LnRvb2wgPyA3ICsgMSA6IDFcbiAgICAgICAgLy8gVGhlbiBhZGp1c3QgdGhlIHRvb2xcbiAgICAgICAgbmV4dC50b29sID0gdG9vbHNBbGxvd2VkSW5Cb3RoWzBdXG4gICAgICB9XG4gICAgfSxcbiAgICBwcmludDogZnVuY3Rpb24gKGdyaWQsIHBhdGgpIHtcbiAgICAgIGNvbnN0IG9uUGF0aCA9IG5ldyBTZXQoKVxuXG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBwYXRoLmZvckVhY2gocCA9PiBvblBhdGguYWRkKGAke3AueH0sJHtwLnl9YCkpXG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSAnJ1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBncmlkLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgZ3JpZFt5XS5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIGxldCBjbGF6eiA9IG51bGxcbiAgICAgICAgICBpZiAob25QYXRoLmhhcyhgJHt4fSwke3l9YCkpIHtcbiAgICAgICAgICAgIGNsYXp6ID0gJ2RheS0yMi1wYXRoJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3JpZFt5XVt4XSA9PT0gV0VUKSB7XG4gICAgICAgICAgICBjbGF6eiA9ICdkYXktMjItd2V0J1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3JpZFt5XVt4XSA9PT0gTkFSUk9XKSB7XG4gICAgICAgICAgICBjbGF6eiA9ICdkYXktMjItbmFycm93J1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjbGF6eikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhenp9XCI+JHtncmlkW3ldW3hdfTwvc3Bhbj5gXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBncmlkW3ldW3hdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnPGJyLz4nXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuLmRheS0yMi1jb2RlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJjM2U1MDtcbiAgY29sb3I6ICM3ZjhjOGQ7XG4gIG1heC1oZWlnaHQ6IDUwdmg7XG59XG4uZGF5LTIyLXdldCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICMyOTgwYjk7XG4gIGNvbG9yOiAjMmMzZTUwO1xufVxuLmRheS0yMi1uYXJyb3cge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiMyN2FlNjA7XG4gIGNvbG9yOiAjMmMzZTUwO1xufVxuLmRheS0yMi1wYXRoIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VjZjBmMTtcbiAgY29sb3I6ICMyYzNlNTA7XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkyMi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkyMi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/Y2xvbmVkUnVsZVNldC0xMi51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MjIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZGQ3ZTYzZWMmcHJvZCZsYW5nPWNzc1wiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9EYXkyMi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZGQ3ZTYzZWNcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkyMi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5MjIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vRGF5MjIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZGQ3ZTYzZWMmcHJvZCZsYW5nPWNzc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOlsiY29tcG9uZW50cyIsIkRheSIsImRhdGEiLCJzb2x1dGlvbnMiLCJwYXJ0T25lIiwicGFydFR3byIsImdyaWRPbmUiLCJyaXNrIiwidHlwZXMiLCJkaXJlY3Rpb25zIiwidmFsaWRHZWFyIiwibWV0aG9kcyIsIm9uSW5wdXRDaGFuZ2VkIiwiZ2V0R2VvSW5kZXgiLCJzb2x2ZVBhcnRPbmUiLCJnZW9JbmRleCIsImVyb3Npb25MZXZlbCIsInR5cGUiLCJzb2x2ZVBhcnRUd28iLCJ0b29sIiwieCIsInkiLCJ0aW1lIiwicGF0aCIsImJlc3RUaW1lIiwiY29uZmlncyIsIm5leHQiLCJhZGp1c3RDb25maWciLCJwcmludCIsImNsYXp6IiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27540\n")}}]);