"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[5002],{72016:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day1)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2016/Day1.vue?vue&type=template&id=692f2484\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":1,\"year\":2016,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{attrs:{\"id\":\"partOne\"}})]},proxy:true}])})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js\nvar vuex_esm = __webpack_require__(20629);\n// EXTERNAL MODULE: ./src/util/math.js\nvar math = __webpack_require__(24002);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2016/Day1.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ const Day1vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  computed: {\n    ...(0,vuex_esm/* mapGetters */.Se)(['storeDarkMode'])\n  },\n  watch: {\n    storeDarkMode: function () {\n      if (this.trace.x.length > 0) {\n        this.plot();\n      }\n    }\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      directions: ['N', 'E', 'S', 'W'],\n      move: {\n        N: (curr, amount) => {\n          curr[1] += amount;\n        },\n        E: (curr, amount) => {\n          curr[0] += amount;\n        },\n        S: (curr, amount) => {\n          curr[1] -= amount;\n        },\n        W: (curr, amount) => {\n          curr[0] -= amount;\n        }\n      },\n      trace: {\n        x: [],\n        y: []\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const directions = input[0].split(', ').map(i => {\n        return {\n          turn: i.substring(0, 1),\n          move: +i.substring(1, i.length)\n        };\n      });\n      this.trace = {\n        x: [],\n        y: []\n      };\n      this.solutions = {\n        partOne: null,\n        partTwo: null\n      };\n\n      // Keep track of the current position\n      const curr = {\n        pos: [0, 0],\n        dir: 'N'\n      };\n\n      // Remember visited positions\n      const memory = new Set();\n\n      // For each instruction\n      directions.forEach(d => {\n        // Keep a copy of the current position before moving\n        const prev = {\n          pos: curr.pos.concat()\n        };\n\n        // Based on the turn, calculate the direction delta\n        const delta = d.turn === 'R' ? 1 : -1;\n        // Adjust the direction accordingly\n        curr.dir = this.directions[(0,math/* mod */.w)(this.directions.indexOf(curr.dir) + delta, this.directions.length)];\n        // Move in the new direction\n        this.move[curr.dir](curr.pos, d.move);\n        const match = this.walk(prev.pos, curr.pos, memory);\n        // If we haven't found solution part two yet\n        if (!this.solutions.partTwo) {\n          // Check if there's a previously visited coordinate on the just walked path\n          this.solutions.partTwo = match;\n        }\n      });\n\n      // Solution part one is the manhattan distance between the origin and the target\n      this.solutions.partOne = Math.abs(curr.pos[0]) + Math.abs(curr.pos[1]);\n      this.$nextTick(() => this.plot());\n    },\n    walk: function (a, b, mem) {\n      this.trace.x.push(b[0]);\n      this.trace.y.push(b[1]);\n\n      // Check whether it's x or y coordinate that's different\n      const index = a[0] !== b[0] ? 0 : 1;\n\n      // Calculate min and max\n      const minX = Math.min(a[index], b[index]);\n      const maxX = Math.max(a[index], b[index]);\n\n      // Iterate between min and max\n      for (let i = minX + 1; i < maxX; i++) {\n        const coords = index === 0 ? `${i},${a[1]}` : `${a[0]},${i}`;\n        if (mem.has(coords)) {\n          // If visited before, return manhattan distance\n          return Math.abs(i) + Math.abs(a[1 - index]);\n        } else {\n          // Else add to memory\n          mem.add(coords);\n        }\n      }\n    },\n    plot: function () {\n      this.$plotly.purge('partOne');\n      const traces = [this.trace];\n      this.$plotly.newPlot('partOne', traces, {\n        height: 250,\n        margin: {\n          t: 10,\n          b: 20,\n          l: 50,\n          r: 0\n        },\n        paper_bgcolor: 'transparent',\n        plot_bgcolor: 'transparent',\n        xaxis: {\n          tickfont: {\n            color: this.storeDarkMode ? 'white' : 'black'\n          },\n          gridcolor: this.storeDarkMode ? '#111111' : '#eeeeee'\n        },\n        yaxis: {\n          title: {\n            text: 'Ranking',\n            font: {\n              color: this.storeDarkMode ? 'white' : 'black'\n            }\n          },\n          tickfont: {\n            color: this.storeDarkMode ? 'white' : 'black'\n          },\n          gridcolor: this.storeDarkMode ? '#111111' : '#eeeeee'\n        }\n      }, {\n        responsive: true,\n        displaylogo: false\n      });\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2016/Day1.vue?vue&type=script&lang=js\n /* harmony default export */ const _2016_Day1vue_type_script_lang_js = (Day1vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2016/Day1.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2016_Day1vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day1 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwMTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTyw4Q0FBOEMsS0FBSyxtQ0FBbUMsc0JBQXNCLDRCQUE0QixrQkFBa0IsT0FBTyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUc7QUFDcFQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNRQTtBQUNBO0FBQ0E7QUFFQSxrRUFBZTtFQUNmQTtJQUNBQyxHQUFBQSxFQUFBQSxrQkFBQUE7RUFDQTtFQUNBQztJQUNBLG9DQUNBLGdCQUNBO0VBQ0E7RUFDQUM7SUFDQUM7TUFDQTtRQUNBO01BQ0E7SUFDQTtFQUNBO0VBQ0FDO0lBQ0E7TUFDQUM7UUFDQUM7UUFDQUM7TUFDQTtNQUNBQztNQUNBQztRQUNBQztVQUFBQztRQUFBO1FBQ0FDO1VBQUFEO1FBQUE7UUFDQUU7VUFBQUY7UUFBQTtRQUNBRztVQUFBSDtRQUFBO01BQ0E7TUFDQUk7UUFDQUM7UUFDQUM7TUFDQTtJQUNBO0VBQ0E7RUFDQUM7SUFDQUM7TUFDQTtRQUNBO1VBQ0FDO1VBQ0FYO1FBQ0E7TUFDQTtNQUVBO1FBQ0FPO1FBQ0FDO01BQ0E7TUFFQTtRQUNBWDtRQUNBQztNQUNBOztNQUVBO01BQ0E7UUFDQWM7UUFDQUM7TUFDQTs7TUFFQTtNQUNBOztNQUVBO01BQ0FkO1FBQ0E7UUFDQTtVQUNBYTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBViwyQkFBQUEsbUJBQUFBO1FBQ0E7UUFDQTtRQUVBO1FBQ0E7UUFDQTtVQUNBO1VBQ0E7UUFDQTtNQUNBOztNQUVBO01BQ0E7TUFFQTtJQUNBO0lBQ0FZO01BQ0E7TUFDQTs7TUFFQTtNQUNBOztNQUVBO01BQ0E7TUFDQTs7TUFFQTtNQUNBO1FBQ0E7UUFFQTtVQUNBO1VBQ0E7UUFDQTtVQUNBO1VBQ0FDO1FBQ0E7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFFQTtNQUVBO1FBQ0FDO1FBQ0FDO1VBQUFDO1VBQUFDO1VBQUFDO1VBQUFDO1FBQUE7UUFDQUM7UUFDQUM7UUFDQUM7VUFDQUM7WUFBQUM7VUFBQTtVQUNBQztRQUNBO1FBQ0FDO1VBQ0FDO1lBQUFDO1lBQUFDO2NBQUFMO1lBQUE7VUFBQTtVQUNBRDtZQUFBQztVQUFBO1VBQ0FDO1FBQ0E7TUFDQTtRQUNBSztRQUNBQztNQUNBO0lBQ0E7RUFDQTtBQUNBLENBQUMsRTs7QUN4SjBQLENBQUMsd0VBQWUsMkJBQUcsRUFBQyxDOzs7O0FDQTdMO0FBQzNCO0FBQ0w7OztBQUdsRDtBQUNBLENBQXNHO0FBQ3RHLGdCQUFnQixzQ0FBVTtBQUMxQixFQUFFLGlDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxNi9EYXkxLnZ1ZT8zZDI2Iiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlL3NyYy9jb21wb25lbnRzLzIwMTYvRGF5MS52dWU/ZmE4ZSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTYvRGF5MS52dWU/MTcwOCIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTYvRGF5MS52dWU/NDEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnRGF5Jyx7YXR0cnM6e1wiZGF5XCI6MSxcInllYXJcIjoyMDE2LFwic29sdXRpb25zXCI6X3ZtLnNvbHV0aW9uc30sb246e1wiaW5wdXQtY2hhbmdlZFwiOl92bS5vbklucHV0Q2hhbmdlZH0sc2NvcGVkU2xvdHM6X3ZtLl91KFt7a2V5OlwicGFydE9uZVwiLGZuOmZ1bmN0aW9uKCl7cmV0dXJuIFtfYygnZGl2Jyx7YXR0cnM6e1wiaWRcIjpcInBhcnRPbmVcIn19KV19LHByb3h5OnRydWV9XSl9KX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIxXCIgOnllYXI9XCIyMDE2XCIgOnNvbHV0aW9ucz1cInNvbHV0aW9uc1wiIEBpbnB1dC1jaGFuZ2VkPVwib25JbnB1dENoYW5nZWRcIj5cbiAgICA8dGVtcGxhdGUgdi1zbG90OnBhcnRPbmU+XG4gICAgICA8ZGl2IGlkPVwicGFydE9uZVwiIC8+XG4gICAgPC90ZW1wbGF0ZT5cbiAgPC9EYXk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IERheSBmcm9tICdAL2NvbXBvbmVudHMvRGF5J1xuaW1wb3J0IHsgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnXG5pbXBvcnQgeyBtb2QgfSBmcm9tICdAL3V0aWwvbWF0aCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgLi4ubWFwR2V0dGVycyhbXG4gICAgICAnc3RvcmVEYXJrTW9kZSdcbiAgICBdKVxuICB9LFxuICB3YXRjaDoge1xuICAgIHN0b3JlRGFya01vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnRyYWNlLngubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnBsb3QoKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb2x1dGlvbnM6IHtcbiAgICAgICAgcGFydE9uZTogbnVsbCxcbiAgICAgICAgcGFydFR3bzogbnVsbFxuICAgICAgfSxcbiAgICAgIGRpcmVjdGlvbnM6IFsnTicsICdFJywgJ1MnLCAnVyddLFxuICAgICAgbW92ZToge1xuICAgICAgICBOOiAoY3VyciwgYW1vdW50KSA9PiB7IGN1cnJbMV0gKz0gYW1vdW50IH0sXG4gICAgICAgIEU6IChjdXJyLCBhbW91bnQpID0+IHsgY3VyclswXSArPSBhbW91bnQgfSxcbiAgICAgICAgUzogKGN1cnIsIGFtb3VudCkgPT4geyBjdXJyWzFdIC09IGFtb3VudCB9LFxuICAgICAgICBXOiAoY3VyciwgYW1vdW50KSA9PiB7IGN1cnJbMF0gLT0gYW1vdW50IH1cbiAgICAgIH0sXG4gICAgICB0cmFjZToge1xuICAgICAgICB4OiBbXSxcbiAgICAgICAgeTogW11cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0Q2hhbmdlZDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb25zID0gaW5wdXRbMF0uc3BsaXQoJywgJykubWFwKGkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR1cm46IGkuc3Vic3RyaW5nKDAsIDEpLFxuICAgICAgICAgIG1vdmU6ICtpLnN1YnN0cmluZygxLCBpLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy50cmFjZSA9IHtcbiAgICAgICAgeDogW10sXG4gICAgICAgIHk6IFtdXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc29sdXRpb25zID0ge1xuICAgICAgICBwYXJ0T25lOiBudWxsLFxuICAgICAgICBwYXJ0VHdvOiBudWxsXG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgIGNvbnN0IGN1cnIgPSB7XG4gICAgICAgIHBvczogWzAsIDBdLFxuICAgICAgICBkaXI6ICdOJ1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1lbWJlciB2aXNpdGVkIHBvc2l0aW9uc1xuICAgICAgY29uc3QgbWVtb3J5ID0gbmV3IFNldCgpXG5cbiAgICAgIC8vIEZvciBlYWNoIGluc3RydWN0aW9uXG4gICAgICBkaXJlY3Rpb25zLmZvckVhY2goZCA9PiB7XG4gICAgICAgIC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uIGJlZm9yZSBtb3ZpbmdcbiAgICAgICAgY29uc3QgcHJldiA9IHtcbiAgICAgICAgICBwb3M6IGN1cnIucG9zLmNvbmNhdCgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlZCBvbiB0aGUgdHVybiwgY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb24gZGVsdGFcbiAgICAgICAgY29uc3QgZGVsdGEgPSBkLnR1cm4gPT09ICdSJyA/IDEgOiAtMVxuICAgICAgICAvLyBBZGp1c3QgdGhlIGRpcmVjdGlvbiBhY2NvcmRpbmdseVxuICAgICAgICBjdXJyLmRpciA9IHRoaXMuZGlyZWN0aW9uc1ttb2QoKHRoaXMuZGlyZWN0aW9ucy5pbmRleE9mKGN1cnIuZGlyKSArIGRlbHRhKSwgdGhpcy5kaXJlY3Rpb25zLmxlbmd0aCldXG4gICAgICAgIC8vIE1vdmUgaW4gdGhlIG5ldyBkaXJlY3Rpb25cbiAgICAgICAgdGhpcy5tb3ZlW2N1cnIuZGlyXShjdXJyLnBvcywgZC5tb3ZlKVxuXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy53YWxrKHByZXYucG9zLCBjdXJyLnBvcywgbWVtb3J5KVxuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGZvdW5kIHNvbHV0aW9uIHBhcnQgdHdvIHlldFxuICAgICAgICBpZiAoIXRoaXMuc29sdXRpb25zLnBhcnRUd28pIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgcHJldmlvdXNseSB2aXNpdGVkIGNvb3JkaW5hdGUgb24gdGhlIGp1c3Qgd2Fsa2VkIHBhdGhcbiAgICAgICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gbWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gU29sdXRpb24gcGFydCBvbmUgaXMgdGhlIG1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvcmlnaW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgIHRoaXMuc29sdXRpb25zLnBhcnRPbmUgPSBNYXRoLmFicyhjdXJyLnBvc1swXSkgKyBNYXRoLmFicyhjdXJyLnBvc1sxXSlcblxuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gdGhpcy5wbG90KCkpXG4gICAgfSxcbiAgICB3YWxrOiBmdW5jdGlvbiAoYSwgYiwgbWVtKSB7XG4gICAgICB0aGlzLnRyYWNlLngucHVzaChiWzBdKVxuICAgICAgdGhpcy50cmFjZS55LnB1c2goYlsxXSlcblxuICAgICAgLy8gQ2hlY2sgd2hldGhlciBpdCdzIHggb3IgeSBjb29yZGluYXRlIHRoYXQncyBkaWZmZXJlbnRcbiAgICAgIGNvbnN0IGluZGV4ID0gYVswXSAhPT0gYlswXSA/IDAgOiAxXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBtaW4gYW5kIG1heFxuICAgICAgY29uc3QgbWluWCA9IE1hdGgubWluKGFbaW5kZXhdLCBiW2luZGV4XSlcbiAgICAgIGNvbnN0IG1heFggPSBNYXRoLm1heChhW2luZGV4XSwgYltpbmRleF0pXG5cbiAgICAgIC8vIEl0ZXJhdGUgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgICAgZm9yIChsZXQgaSA9IG1pblggKyAxOyBpIDwgbWF4WDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IGluZGV4ID09PSAwID8gYCR7aX0sJHthWzFdfWAgOiBgJHthWzBdfSwke2l9YFxuXG4gICAgICAgIGlmIChtZW0uaGFzKGNvb3JkcykpIHtcbiAgICAgICAgICAvLyBJZiB2aXNpdGVkIGJlZm9yZSwgcmV0dXJuIG1hbmhhdHRhbiBkaXN0YW5jZVxuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhpKSArIE1hdGguYWJzKGFbMSAtIGluZGV4XSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFbHNlIGFkZCB0byBtZW1vcnlcbiAgICAgICAgICBtZW0uYWRkKGNvb3JkcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGxvdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kcGxvdGx5LnB1cmdlKCdwYXJ0T25lJylcblxuICAgICAgY29uc3QgdHJhY2VzID0gW3RoaXMudHJhY2VdXG5cbiAgICAgIHRoaXMuJHBsb3RseS5uZXdQbG90KCdwYXJ0T25lJywgdHJhY2VzLCB7XG4gICAgICAgIGhlaWdodDogMjUwLFxuICAgICAgICBtYXJnaW46IHsgdDogMTAsIGI6IDIwLCBsOiA1MCwgcjogMCB9LFxuICAgICAgICBwYXBlcl9iZ2NvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBwbG90X2JnY29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgdGlja2ZvbnQ6IHsgY29sb3I6IHRoaXMuc3RvcmVEYXJrTW9kZSA/ICd3aGl0ZScgOiAnYmxhY2snIH0sXG4gICAgICAgICAgZ3JpZGNvbG9yOiB0aGlzLnN0b3JlRGFya01vZGUgPyAnIzExMTExMScgOiAnI2VlZWVlZSdcbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICB0aXRsZTogeyB0ZXh0OiAnUmFua2luZycsIGZvbnQ6IHsgY29sb3I6IHRoaXMuc3RvcmVEYXJrTW9kZSA/ICd3aGl0ZScgOiAnYmxhY2snIH0gfSxcbiAgICAgICAgICB0aWNrZm9udDogeyBjb2xvcjogdGhpcy5zdG9yZURhcmtNb2RlID8gJ3doaXRlJyA6ICdibGFjaycgfSxcbiAgICAgICAgICBncmlkY29sb3I6IHRoaXMuc3RvcmVEYXJrTW9kZSA/ICcjMTExMTExJyA6ICcjZWVlZWVlJ1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIGRpc3BsYXlsb2dvOiBmYWxzZVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNDAudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vRGF5MS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NjkyZjI0ODRcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkxLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9EYXkxLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOlsiY29tcG9uZW50cyIsIkRheSIsImNvbXB1dGVkIiwid2F0Y2giLCJzdG9yZURhcmtNb2RlIiwiZGF0YSIsInNvbHV0aW9ucyIsInBhcnRPbmUiLCJwYXJ0VHdvIiwiZGlyZWN0aW9ucyIsIm1vdmUiLCJOIiwiY3VyciIsIkUiLCJTIiwiVyIsInRyYWNlIiwieCIsInkiLCJtZXRob2RzIiwib25JbnB1dENoYW5nZWQiLCJ0dXJuIiwicG9zIiwiZGlyIiwid2FsayIsIm1lbSIsInBsb3QiLCJoZWlnaHQiLCJtYXJnaW4iLCJ0IiwiYiIsImwiLCJyIiwicGFwZXJfYmdjb2xvciIsInBsb3RfYmdjb2xvciIsInhheGlzIiwidGlja2ZvbnQiLCJjb2xvciIsImdyaWRjb2xvciIsInlheGlzIiwidGl0bGUiLCJ0ZXh0IiwiZm9udCIsInJlc3BvbnNpdmUiLCJkaXNwbGF5bG9nbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///72016\n")},24002:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ mod)\n/* harmony export */ });\nconst mod = (a, b) => {\n  return (a % b + b) % b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQwMDIuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsTUFBTUEsR0FBRyxHQUFHQSxDQUFDQyxDQUFDLEVBQUVDLENBQUMsS0FBSztFQUNwQixPQUFPLENBQUVELENBQUMsR0FBR0MsQ0FBQyxHQUFJQSxDQUFDLElBQUlBLENBQUM7QUFDMUIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL3V0aWwvbWF0aC5qcz9mMzFjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG1vZCA9IChhLCBiKSA9PiB7XG4gIHJldHVybiAoKGEgJSBiKSArIGIpICUgYlxufVxuXG5leHBvcnQge1xuICBtb2Rcbn1cbiJdLCJuYW1lcyI6WyJtb2QiLCJhIiwiYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24002\n")}}]);