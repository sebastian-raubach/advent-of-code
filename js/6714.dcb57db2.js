"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[6714],{26679:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day15)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day15.vue?vue&type=template&id=5ba2d910\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":15,\"year\":2018,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(36100);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day15.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day15vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      directions: [[0, -1], [-1, 0], [1, 0], [0, 1]]\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.grid = input.map(i => i.split(''));\n      this.players = [];\n      for (let y = 0; y < this.grid.length; y++) {\n        for (let x = 0; x < this.grid[y].length; x++) {\n          if (this.grid[y][x] === 'G' || this.grid[y][x] === 'E') {\n            this.players.push({\n              attack: 3,\n              health: 200,\n              type: this.grid[y][x],\n              x: x,\n              y: y\n            });\n          }\n        }\n      }\n      this.solvePartOne();\n      this.solvePartTwo();\n    },\n    findEnemy: function (player, players, grid) {\n      return players.filter(p => p.type !== player.type && p.health > 0).filter(p => Math.abs(player.x - p.x) + Math.abs(player.y - p.y) === 1).reduce((weakest, curr) => weakest === null || weakest.health > curr.health ? curr : weakest, null);\n    },\n    findNextMovement: function (player, players, grid) {\n      // Map all target position (adjacent cells) of all alive enemies\n      const targetKeys = {};\n      players.filter(p => p.type !== player.type && p.health > 0).map(p => this.getAdjacents({\n        x: p.x,\n        y: p.y\n      }).filter(a => grid[a.y][a.x] === '.')).reduce((acc, list) => acc.concat(...list), []).forEach(a => {\n        targetKeys[`${a.x},${a.y}`] = a;\n      });\n      const visited = new Set();\n      visited.add(`${player.x},${player.y}`);\n      let paths = [[{\n        x: player.x,\n        y: player.y\n      }]];\n      while (true) {\n        const newPaths = [];\n        let targetPaths = [];\n        paths.forEach(p => {\n          this.getAdjacents(p[p.length - 1]).forEach(a => {\n            const xy = `${a.x},${a.y}`;\n            if (targetKeys[xy]) {\n              // We found a path to a target\n              targetPaths.push([...p, a, targetKeys[xy]]);\n            } else if (!visited.has(xy) && grid[a.y][a.x] === '.') {\n              // Extend the path\n              newPaths.push([...p, a]);\n            }\n            visited.add(xy);\n          });\n        });\n        if (targetPaths.length > 0) {\n          // We found at least one path\n          // Sort them based on reading order of last step\n          targetPaths = targetPaths.sort((a, b) => {\n            const al = a[a.length - 1];\n            const bl = b[b.length - 1];\n            return al.y === bl.y ? al.x - bl.x : al.y - bl.y;\n          });\n\n          // Return the first step on the shortest path\n          return targetPaths[0][1];\n        }\n\n        // Keep going, no path found yet\n        paths = newPaths;\n        if (paths.length < 1) {\n          // There are no reachable targets\n          return null;\n        }\n      }\n    },\n    getAdjacents: function (position) {\n      return this.directions.map(d => {\n        return {\n          x: position.x + d[0],\n          y: position.y + d[1]\n        };\n      });\n    },\n    solve: function (grid, players, elfAttackPower) {\n      // Adjust the attack power of all elves\n      players.filter(p => p.type === 'E').forEach(p => {\n        p.attack = elfAttackPower;\n      });\n      let round = 0;\n      while (true) {\n        players = players.sort((a, b) => a.y === b.y ? a.x - b.x : a.y - b.y);\n        for (let i = 0; i < players.length; i++) {\n          const player = players[i];\n          if (player.health > 0) {\n            if (players.filter(p => p.health > 0 && p.type !== player.type).length < 1) {\n              return round * players.filter(p => p.health > 0).map(p => p.health).reduce((a, b) => a + b);\n            }\n            let enemy = this.findEnemy(player, players, grid);\n            const next = enemy ? null : this.findNextMovement(player, players, grid);\n            if (!enemy && next) {\n              grid[player.y][player.x] = '.';\n              player.x = next.x;\n              player.y = next.y;\n              grid[player.y][player.x] = player.type;\n              enemy = this.findEnemy(player, players, grid);\n            }\n            if (enemy) {\n              enemy.health -= player.attack;\n              if (enemy.health < 1) {\n                grid[enemy.y][enemy.x] = '.';\n\n                // If an elf died and this isn't part 1, return\n                if (enemy.type === 'E' && elfAttackPower !== 3) {\n                  return null;\n                }\n              }\n            }\n          }\n        }\n        round++;\n      }\n    },\n    solvePartOne: function () {\n      this.solutions.partOne = this.solve(JSON.parse(JSON.stringify(this.grid)), JSON.parse(JSON.stringify(this.players)), 3);\n    },\n    solvePartTwo: function () {\n      // Start with an attack power of 4\n      let attackPower = 4;\n      while (true) {\n        // Get the result\n        const result = this.solve(JSON.parse(JSON.stringify(this.grid)), JSON.parse(JSON.stringify(this.players)), attackPower);\n\n        // If it succeeded, not elf died, so accept the result\n        if (result !== null) {\n          this.solutions.partTwo = result;\n          return;\n        }\n\n        // Increase the elf attack power\n        attackPower++;\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2018/Day15.vue?vue&type=script&lang=js\n /* harmony default export */ const _2018_Day15vue_type_script_lang_js = (Day15vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2018/Day15.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2018_Day15vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day15 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY2NzkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxvQ0FBb0M7QUFDek07Ozs7Ozs7Ozs7OztBQ0tBO0FBRUEsbUVBQWU7RUFDZkE7SUFDQUMsR0FBQUEsRUFBQUEsa0JBQUFBO0VBQ0E7RUFDQUM7SUFDQTtNQUNBQztRQUNBQztRQUNBQztNQUNBO01BQ0FDO0lBQ0E7RUFDQTtFQUNBQztJQUNBQztNQUNBO01BQ0E7TUFFQTtRQUNBO1VBQ0E7WUFDQTtjQUNBQztjQUNBQztjQUNBQztjQUNBQztjQUNBQztZQUNBO1VBQ0E7UUFDQTtNQUNBO01BRUE7TUFDQTtJQUNBO0lBQ0FDO01BQ0EsbUVBQ0FDLHVFQUNBQztJQUNBO0lBQ0FDO01BQ0E7TUFDQTtNQUNBQyw0REFDQUM7UUFBQVA7UUFBQUM7TUFBQSx3Q0FDQUcsK0NBQ0FJO1FBQ0FDO01BQ0E7TUFFQTtNQUNBQztNQUVBO1FBQUFWO1FBQUFDO01BQUE7TUFFQTtRQUNBO1FBQ0E7UUFFQVU7VUFDQTtZQUNBO1lBQ0E7Y0FDQTtjQUNBQztZQUNBO2NBQ0E7Y0FDQUM7WUFDQTtZQUNBSDtVQUNBO1FBQ0E7UUFFQTtVQUNBO1VBQ0E7VUFDQUU7WUFDQTtZQUNBO1lBQ0E7VUFDQTs7VUFFQTtVQUNBO1FBQ0E7O1FBRUE7UUFDQUQ7UUFDQTtVQUNBO1VBQ0E7UUFDQTtNQUNBO0lBQ0E7SUFDQUc7TUFDQTtRQUNBO1VBQ0FkO1VBQ0FDO1FBQ0E7TUFDQTtJQUNBO0lBQ0FjO01BQ0E7TUFDQVQ7UUFBQVU7TUFBQTtNQUNBO01BQ0E7UUFDQVY7UUFFQTtVQUNBO1VBRUE7WUFDQTtjQUNBO1lBQ0E7WUFFQTtZQUNBO1lBQ0E7Y0FDQVc7Y0FDQUM7Y0FDQUE7Y0FDQUQ7Y0FFQUU7WUFDQTtZQUVBO2NBQ0FBO2NBQ0E7Z0JBQ0FGOztnQkFFQTtnQkFDQTtrQkFDQTtnQkFDQTtjQUNBO1lBQ0E7VUFDQTtRQUNBO1FBRUFHO01BQ0E7SUFDQTtJQUNBQztNQUNBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBO01BQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7VUFDQTtVQUNBO1FBQ0E7O1FBRUE7UUFDQUM7TUFDQTtJQUNBO0VBQ0E7QUFDQSxDQUFDLEU7O0FDOUsyUCxDQUFDLHlFQUFlLDRCQUFHLEVBQUMsQzs7OztBQ0E3TDtBQUMzQjtBQUNMOzs7QUFHbkQ7QUFDQSxDQUFzRztBQUN0RyxnQkFBZ0Isc0NBQVU7QUFDMUIsRUFBRSxrQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTgvRGF5MTUudnVlP2E4MTMiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkxNS52dWU/NmIyYSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTgvRGF5MTUudnVlP2I0MGIiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDE4L0RheTE1LnZ1ZT8xNTU0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdEYXknLHthdHRyczp7XCJkYXlcIjoxNSxcInllYXJcIjoyMDE4LFwic29sdXRpb25zXCI6X3ZtLnNvbHV0aW9uc30sb246e1wiaW5wdXQtY2hhbmdlZFwiOl92bS5vbklucHV0Q2hhbmdlZH19KX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIxNVwiIDp5ZWFyPVwiMjAxOFwiIDpzb2x1dGlvbnM9XCJzb2x1dGlvbnNcIiBAaW5wdXQtY2hhbmdlZD1cIm9uSW5wdXRDaGFuZ2VkXCI+XG4gIDwvRGF5PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBEYXkgZnJvbSAnQC9jb21wb25lbnRzL0RheSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sdXRpb25zOiB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb25zOiBbWzAsIC0xXSwgWy0xLCAwXSwgWzEsIDBdLCBbMCwgMV1dXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25JbnB1dENoYW5nZWQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdGhpcy5ncmlkID0gaW5wdXQubWFwKGkgPT4gaS5zcGxpdCgnJykpXG4gICAgICB0aGlzLnBsYXllcnMgPSBbXVxuXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuZ3JpZC5sZW5ndGg7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZ3JpZFt5XS5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIGlmICh0aGlzLmdyaWRbeV1beF0gPT09ICdHJyB8fCB0aGlzLmdyaWRbeV1beF0gPT09ICdFJykge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICBhdHRhY2s6IDMsXG4gICAgICAgICAgICAgIGhlYWx0aDogMjAwLFxuICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdyaWRbeV1beF0sXG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc29sdmVQYXJ0T25lKClcbiAgICAgIHRoaXMuc29sdmVQYXJ0VHdvKClcbiAgICB9LFxuICAgIGZpbmRFbmVteTogZnVuY3Rpb24gKHBsYXllciwgcGxheWVycywgZ3JpZCkge1xuICAgICAgcmV0dXJuIHBsYXllcnMuZmlsdGVyKHAgPT4gcC50eXBlICE9PSBwbGF5ZXIudHlwZSAmJiBwLmhlYWx0aCA+IDApXG4gICAgICAgIC5maWx0ZXIocCA9PiAoTWF0aC5hYnMocGxheWVyLnggLSBwLngpICsgTWF0aC5hYnMocGxheWVyLnkgLSBwLnkpKSA9PT0gMSlcbiAgICAgICAgLnJlZHVjZSgod2Vha2VzdCwgY3VycikgPT4gd2Vha2VzdCA9PT0gbnVsbCB8fCB3ZWFrZXN0LmhlYWx0aCA+IGN1cnIuaGVhbHRoID8gY3VyciA6IHdlYWtlc3QsIG51bGwpXG4gICAgfSxcbiAgICBmaW5kTmV4dE1vdmVtZW50OiBmdW5jdGlvbiAocGxheWVyLCBwbGF5ZXJzLCBncmlkKSB7XG4gICAgICAvLyBNYXAgYWxsIHRhcmdldCBwb3NpdGlvbiAoYWRqYWNlbnQgY2VsbHMpIG9mIGFsbCBhbGl2ZSBlbmVtaWVzXG4gICAgICBjb25zdCB0YXJnZXRLZXlzID0ge31cbiAgICAgIHBsYXllcnMuZmlsdGVyKHAgPT4gcC50eXBlICE9PSBwbGF5ZXIudHlwZSAmJiBwLmhlYWx0aCA+IDApXG4gICAgICAgIC5tYXAocCA9PiB0aGlzLmdldEFkamFjZW50cyh7IHg6IHAueCwgeTogcC55IH0pLmZpbHRlcihhID0+IGdyaWRbYS55XVthLnhdID09PSAnLicpKVxuICAgICAgICAucmVkdWNlKChhY2MsIGxpc3QpID0+IGFjYy5jb25jYXQoLi4ubGlzdCksIFtdKVxuICAgICAgICAuZm9yRWFjaChhID0+IHtcbiAgICAgICAgICB0YXJnZXRLZXlzW2Ake2EueH0sJHthLnl9YF0gPSBhXG4gICAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KClcbiAgICAgIHZpc2l0ZWQuYWRkKGAke3BsYXllci54fSwke3BsYXllci55fWApXG5cbiAgICAgIGxldCBwYXRocyA9IFtbeyB4OiBwbGF5ZXIueCwgeTogcGxheWVyLnkgfV1dXG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGhzID0gW11cbiAgICAgICAgbGV0IHRhcmdldFBhdGhzID0gW11cblxuICAgICAgICBwYXRocy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgIHRoaXMuZ2V0QWRqYWNlbnRzKHBbcC5sZW5ndGggLSAxXSkuZm9yRWFjaChhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHh5ID0gYCR7YS54fSwke2EueX1gXG4gICAgICAgICAgICBpZiAodGFyZ2V0S2V5c1t4eV0pIHtcbiAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBwYXRoIHRvIGEgdGFyZ2V0XG4gICAgICAgICAgICAgIHRhcmdldFBhdGhzLnB1c2goWy4uLnAsIGEsIHRhcmdldEtleXNbeHldXSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXZpc2l0ZWQuaGFzKHh5KSAmJiBncmlkW2EueV1bYS54XSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgcGF0aFxuICAgICAgICAgICAgICBuZXdQYXRocy5wdXNoKFsuLi5wLCBhXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKHh5KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHRhcmdldFBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBmb3VuZCBhdCBsZWFzdCBvbmUgcGF0aFxuICAgICAgICAgIC8vIFNvcnQgdGhlbSBiYXNlZCBvbiByZWFkaW5nIG9yZGVyIG9mIGxhc3Qgc3RlcFxuICAgICAgICAgIHRhcmdldFBhdGhzID0gdGFyZ2V0UGF0aHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWwgPSBhW2EubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIGNvbnN0IGJsID0gYltiLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICByZXR1cm4gYWwueSA9PT0gYmwueSA/IGFsLnggLSBibC54IDogYWwueSAtIGJsLnlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBzdGVwIG9uIHRoZSBzaG9ydGVzdCBwYXRoXG4gICAgICAgICAgcmV0dXJuIHRhcmdldFBhdGhzWzBdWzFdXG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIGdvaW5nLCBubyBwYXRoIGZvdW5kIHlldFxuICAgICAgICBwYXRocyA9IG5ld1BhdGhzXG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIHJlYWNoYWJsZSB0YXJnZXRzXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QWRqYWNlbnRzOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbnMubWFwKGQgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHBvc2l0aW9uLnggKyBkWzBdLFxuICAgICAgICAgIHk6IHBvc2l0aW9uLnkgKyBkWzFdXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBzb2x2ZTogZnVuY3Rpb24gKGdyaWQsIHBsYXllcnMsIGVsZkF0dGFja1Bvd2VyKSB7XG4gICAgICAvLyBBZGp1c3QgdGhlIGF0dGFjayBwb3dlciBvZiBhbGwgZWx2ZXNcbiAgICAgIHBsYXllcnMuZmlsdGVyKHAgPT4gcC50eXBlID09PSAnRScpLmZvckVhY2gocCA9PiB7IHAuYXR0YWNrID0gZWxmQXR0YWNrUG93ZXIgfSlcbiAgICAgIGxldCByb3VuZCA9IDBcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBsYXllcnMgPSBwbGF5ZXJzLnNvcnQoKGEsIGIpID0+IGEueSA9PT0gYi55ID8gYS54IC0gYi54IDogYS55IC0gYi55KVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBsYXllciA9IHBsYXllcnNbaV1cblxuICAgICAgICAgIGlmIChwbGF5ZXIuaGVhbHRoID4gMCkge1xuICAgICAgICAgICAgaWYgKHBsYXllcnMuZmlsdGVyKHAgPT4gcC5oZWFsdGggPiAwICYmIHAudHlwZSAhPT0gcGxheWVyLnR5cGUpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kICogcGxheWVycy5maWx0ZXIocCA9PiBwLmhlYWx0aCA+IDApLm1hcChwID0+IHAuaGVhbHRoKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZW5lbXkgPSB0aGlzLmZpbmRFbmVteShwbGF5ZXIsIHBsYXllcnMsIGdyaWQpXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gZW5lbXkgPyBudWxsIDogdGhpcy5maW5kTmV4dE1vdmVtZW50KHBsYXllciwgcGxheWVycywgZ3JpZClcbiAgICAgICAgICAgIGlmICghZW5lbXkgJiYgbmV4dCkge1xuICAgICAgICAgICAgICBncmlkW3BsYXllci55XVtwbGF5ZXIueF0gPSAnLidcbiAgICAgICAgICAgICAgcGxheWVyLnggPSBuZXh0LnhcbiAgICAgICAgICAgICAgcGxheWVyLnkgPSBuZXh0LnlcbiAgICAgICAgICAgICAgZ3JpZFtwbGF5ZXIueV1bcGxheWVyLnhdID0gcGxheWVyLnR5cGVcblxuICAgICAgICAgICAgICBlbmVteSA9IHRoaXMuZmluZEVuZW15KHBsYXllciwgcGxheWVycywgZ3JpZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuZW15KSB7XG4gICAgICAgICAgICAgIGVuZW15LmhlYWx0aCAtPSBwbGF5ZXIuYXR0YWNrXG4gICAgICAgICAgICAgIGlmIChlbmVteS5oZWFsdGggPCAxKSB7XG4gICAgICAgICAgICAgICAgZ3JpZFtlbmVteS55XVtlbmVteS54XSA9ICcuJ1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gZWxmIGRpZWQgYW5kIHRoaXMgaXNuJ3QgcGFydCAxLCByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAoZW5lbXkudHlwZSA9PT0gJ0UnICYmIGVsZkF0dGFja1Bvd2VyICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJvdW5kKytcbiAgICAgIH1cbiAgICB9LFxuICAgIHNvbHZlUGFydE9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zb2x1dGlvbnMucGFydE9uZSA9IHRoaXMuc29sdmUoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmdyaWQpKSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBsYXllcnMpKSwgMylcbiAgICB9LFxuICAgIHNvbHZlUGFydFR3bzogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU3RhcnQgd2l0aCBhbiBhdHRhY2sgcG93ZXIgb2YgNFxuICAgICAgbGV0IGF0dGFja1Bvd2VyID0gNFxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gR2V0IHRoZSByZXN1bHRcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zb2x2ZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZ3JpZCkpLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGxheWVycykpLCBhdHRhY2tQb3dlcilcblxuICAgICAgICAvLyBJZiBpdCBzdWNjZWVkZWQsIG5vdCBlbGYgZGllZCwgc28gYWNjZXB0IHRoZSByZXN1bHRcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuc29sdXRpb25zLnBhcnRUd28gPSByZXN1bHRcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlYXNlIHRoZSBlbGYgYXR0YWNrIHBvd2VyXG4gICAgICAgIGF0dGFja1Bvd2VyKytcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTE1LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTE1LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9EYXkxNS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWJhMmQ5MTBcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkxNS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5MTUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6WyJjb21wb25lbnRzIiwiRGF5IiwiZGF0YSIsInNvbHV0aW9ucyIsInBhcnRPbmUiLCJwYXJ0VHdvIiwiZGlyZWN0aW9ucyIsIm1ldGhvZHMiLCJvbklucHV0Q2hhbmdlZCIsImF0dGFjayIsImhlYWx0aCIsInR5cGUiLCJ4IiwieSIsImZpbmRFbmVteSIsImZpbHRlciIsInJlZHVjZSIsImZpbmROZXh0TW92ZW1lbnQiLCJwbGF5ZXJzIiwibWFwIiwiZm9yRWFjaCIsInRhcmdldEtleXMiLCJ2aXNpdGVkIiwicGF0aHMiLCJ0YXJnZXRQYXRocyIsIm5ld1BhdGhzIiwiZ2V0QWRqYWNlbnRzIiwic29sdmUiLCJwIiwiZ3JpZCIsInBsYXllciIsImVuZW15Iiwicm91bmQiLCJzb2x2ZVBhcnRPbmUiLCJzb2x2ZVBhcnRUd28iLCJhdHRhY2tQb3dlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26679\n")}}]);