"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[5528],{15072:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day7)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2017/Day7.vue?vue&type=template&id=4f2d0980\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":7,\"year\":2017,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2017/Day7.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day7vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Split each row on tab and then map the values to numbers\n      // this.values = input[0].split('\\t').map(i => +i)\n      this.allNodes = input.map(r => {\n        // Split into node details and children\n        const parts = r.split(' -> ');\n        // Replace all brackets, then split on space\n        const left = parts[0].replace(/\\(/g, '').replace(/\\)/g, '').split(' ');\n        // Split into individual children\n        const right = parts.length > 1 ? parts[1].split(', ') : [];\n        return {\n          parent: null,\n          name: left[0],\n          weight: +left[1],\n          children: right\n        };\n      });\n      this.solve();\n    },\n    solve: function () {\n      // Map from name to node\n      const mapping = new Map();\n\n      // Add all nodes\n      this.allNodes.forEach(n => mapping.set(n.name, n));\n      mapping.forEach(node => {\n        // If there are children\n        if (node.children.length > 0) {\n          node.children = node.children.map(c => {\n            // Get their mapping and add them instead of their name\n            const child = mapping.get(c);\n            // Remember the parent\n            child.parent = node;\n            return child;\n          });\n        }\n      });\n\n      // Find the root (the one without a parent)\n      let root;\n      mapping.forEach(node => {\n        if (node.parent === null) {\n          root = node;\n        }\n      });\n      this.solutions.partOne = root.name;\n\n      // Solve part two by DFS from the source\n      this.recurse(root);\n    },\n    recurse: function (node) {\n      if (node.children.length < 1) {\n        // If it's a leaf, return its weight\n        return node.weight;\n      } else {\n        // Else, compute the weight of each child by recursion\n        const childWeights = node.children.map(_ => 0);\n        for (let i = 0; i < node.children.length; i++) {\n          // Continue recursion for the child\n          childWeights[i] = this.recurse(node.children[i]);\n\n          // We found the solution further up\n          if (isNaN(childWeights[i])) {\n            return NaN;\n          }\n        }\n\n        // Check if there's a value that doesn't match the rest in the array\n        const wrongIndex = childWeights.findIndex(count => childWeights.filter(x => x === count).length === 1);\n        if (wrongIndex !== -1) {\n          // Get the diff between it and the next one over\n          const diff = childWeights[(wrongIndex + 1) % childWeights.length] - childWeights[wrongIndex];\n\n          // The solution is the original weight of the child plus the diff\n          this.solutions.partTwo = node.children[wrongIndex].weight + diff;\n          return NaN;\n        } else {\n          // Else, just sum up all children and add them to the original weight\n          return node.weight + childWeights.reduce((a, b) => a + b, 0);\n        }\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2017/Day7.vue?vue&type=script&lang=js\n /* harmony default export */ const _2017_Day7vue_type_script_lang_js = (Day7vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2017/Day7.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2017_Day7vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day7 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUwNzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTyw4Q0FBOEMsS0FBSyxvQ0FBb0M7QUFDeE07Ozs7Ozs7Ozs7OztBQ0tBO0FBRUEsa0VBQWU7RUFDZkE7SUFDQUMsR0FBQUEsRUFBQUEsa0JBQUFBO0VBQ0E7RUFDQUM7SUFDQTtNQUNBQztRQUNBQztRQUNBQztNQUNBO0lBQ0E7RUFDQTtFQUNBQztJQUNBQztNQUNBO01BQ0E7TUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUVBO1VBQ0FDO1VBQ0FDO1VBQ0FDO1VBQ0FDO1FBQ0E7TUFDQTtNQUVBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBOztNQUVBO01BQ0E7TUFFQUM7UUFDQTtRQUNBO1VBQ0FDO1lBQ0E7WUFDQTtZQUNBO1lBQ0FDO1lBQ0E7VUFDQTtRQUNBO01BQ0E7O01BRUE7TUFDQTtNQUNBRjtRQUNBO1VBQ0FHO1FBQ0E7TUFDQTtNQUVBOztNQUVBO01BQ0E7SUFDQTtJQUNBQztNQUNBO1FBQ0E7UUFDQTtNQUNBO1FBQ0E7UUFDQTtRQUNBO1VBQ0E7VUFDQUM7O1VBRUE7VUFDQTtZQUNBO1VBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBRUE7VUFDQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtRQUNBO1VBQ0E7VUFDQTtRQUNBO01BQ0E7SUFDQTtFQUNBO0FBQ0EsQ0FBQyxFOztBQzdHMFAsQ0FBQyx3RUFBZSwyQkFBRyxFQUFDLEM7Ozs7QUNBN0w7QUFDM0I7QUFDTDs7O0FBR2xEO0FBQ0EsQ0FBc0c7QUFDdEcsZ0JBQWdCLHNDQUFVO0FBQzFCLEVBQUUsaUNBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDE3L0RheTcudnVlPzE5NDAiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvc3JjL2NvbXBvbmVudHMvMjAxNy9EYXk3LnZ1ZT9jNjgyIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxNy9EYXk3LnZ1ZT82YWVmIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxNy9EYXk3LnZ1ZT85ODY2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdEYXknLHthdHRyczp7XCJkYXlcIjo3LFwieWVhclwiOjIwMTcsXCJzb2x1dGlvbnNcIjpfdm0uc29sdXRpb25zfSxvbjp7XCJpbnB1dC1jaGFuZ2VkXCI6X3ZtLm9uSW5wdXRDaGFuZ2VkfX0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxEYXkgOmRheT1cIjdcIiA6eWVhcj1cIjIwMTdcIiA6c29sdXRpb25zPVwic29sdXRpb25zXCIgQGlucHV0LWNoYW5nZWQ9XCJvbklucHV0Q2hhbmdlZFwiPlxuICA8L0RheT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgRGF5IGZyb20gJ0AvY29tcG9uZW50cy9EYXknXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIERheVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvbHV0aW9uczoge1xuICAgICAgICBwYXJ0T25lOiBudWxsLFxuICAgICAgICBwYXJ0VHdvOiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25JbnB1dENoYW5nZWQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgLy8gU3BsaXQgZWFjaCByb3cgb24gdGFiIGFuZCB0aGVuIG1hcCB0aGUgdmFsdWVzIHRvIG51bWJlcnNcbiAgICAgIC8vIHRoaXMudmFsdWVzID0gaW5wdXRbMF0uc3BsaXQoJ1xcdCcpLm1hcChpID0+ICtpKVxuICAgICAgdGhpcy5hbGxOb2RlcyA9IGlucHV0Lm1hcChyID0+IHtcbiAgICAgICAgLy8gU3BsaXQgaW50byBub2RlIGRldGFpbHMgYW5kIGNoaWxkcmVuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gci5zcGxpdCgnIC0+ICcpXG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIGJyYWNrZXRzLCB0aGVuIHNwbGl0IG9uIHNwYWNlXG4gICAgICAgIGNvbnN0IGxlZnQgPSBwYXJ0c1swXS5yZXBsYWNlKC9cXCgvZywgJycpLnJlcGxhY2UoL1xcKS9nLCAnJykuc3BsaXQoJyAnKVxuICAgICAgICAvLyBTcGxpdCBpbnRvIGluZGl2aWR1YWwgY2hpbGRyZW5cbiAgICAgICAgY29uc3QgcmlnaHQgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0uc3BsaXQoJywgJykgOiBbXVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgIG5hbWU6IGxlZnRbMF0sXG4gICAgICAgICAgd2VpZ2h0OiArbGVmdFsxXSxcbiAgICAgICAgICBjaGlsZHJlbjogcmlnaHRcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5zb2x2ZSgpXG4gICAgfSxcbiAgICBzb2x2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTWFwIGZyb20gbmFtZSB0byBub2RlXG4gICAgICBjb25zdCBtYXBwaW5nID0gbmV3IE1hcCgpXG5cbiAgICAgIC8vIEFkZCBhbGwgbm9kZXNcbiAgICAgIHRoaXMuYWxsTm9kZXMuZm9yRWFjaChuID0+IG1hcHBpbmcuc2V0KG4ubmFtZSwgbikpXG5cbiAgICAgIG1hcHBpbmcuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGNoaWxkcmVuXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoYyA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlaXIgbWFwcGluZyBhbmQgYWRkIHRoZW0gaW5zdGVhZCBvZiB0aGVpciBuYW1lXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG1hcHBpbmcuZ2V0KGMpXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgcGFyZW50XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBGaW5kIHRoZSByb290ICh0aGUgb25lIHdpdGhvdXQgYSBwYXJlbnQpXG4gICAgICBsZXQgcm9vdFxuICAgICAgbWFwcGluZy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICByb290ID0gbm9kZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gcm9vdC5uYW1lXG5cbiAgICAgIC8vIFNvbHZlIHBhcnQgdHdvIGJ5IERGUyBmcm9tIHRoZSBzb3VyY2VcbiAgICAgIHRoaXMucmVjdXJzZShyb290KVxuICAgIH0sXG4gICAgcmVjdXJzZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIGxlYWYsIHJldHVybiBpdHMgd2VpZ2h0XG4gICAgICAgIHJldHVybiBub2RlLndlaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRWxzZSwgY29tcHV0ZSB0aGUgd2VpZ2h0IG9mIGVhY2ggY2hpbGQgYnkgcmVjdXJzaW9uXG4gICAgICAgIGNvbnN0IGNoaWxkV2VpZ2h0cyA9IG5vZGUuY2hpbGRyZW4ubWFwKF8gPT4gMClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gQ29udGludWUgcmVjdXJzaW9uIGZvciB0aGUgY2hpbGRcbiAgICAgICAgICBjaGlsZFdlaWdodHNbaV0gPSB0aGlzLnJlY3Vyc2Uobm9kZS5jaGlsZHJlbltpXSlcblxuICAgICAgICAgIC8vIFdlIGZvdW5kIHRoZSBzb2x1dGlvbiBmdXJ0aGVyIHVwXG4gICAgICAgICAgaWYgKGlzTmFOKGNoaWxkV2VpZ2h0c1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgdmFsdWUgdGhhdCBkb2Vzbid0IG1hdGNoIHRoZSByZXN0IGluIHRoZSBhcnJheVxuICAgICAgICBjb25zdCB3cm9uZ0luZGV4ID0gY2hpbGRXZWlnaHRzLmZpbmRJbmRleChjb3VudCA9PiBjaGlsZFdlaWdodHMuZmlsdGVyKHggPT4geCA9PT0gY291bnQpLmxlbmd0aCA9PT0gMSlcblxuICAgICAgICBpZiAod3JvbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIGRpZmYgYmV0d2VlbiBpdCBhbmQgdGhlIG5leHQgb25lIG92ZXJcbiAgICAgICAgICBjb25zdCBkaWZmID0gY2hpbGRXZWlnaHRzWyh3cm9uZ0luZGV4ICsgMSkgJSBjaGlsZFdlaWdodHMubGVuZ3RoXSAtIGNoaWxkV2VpZ2h0c1t3cm9uZ0luZGV4XVxuXG4gICAgICAgICAgLy8gVGhlIHNvbHV0aW9uIGlzIHRoZSBvcmlnaW5hbCB3ZWlnaHQgb2YgdGhlIGNoaWxkIHBsdXMgdGhlIGRpZmZcbiAgICAgICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gbm9kZS5jaGlsZHJlblt3cm9uZ0luZGV4XS53ZWlnaHQgKyBkaWZmXG4gICAgICAgICAgcmV0dXJuIE5hTlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVsc2UsIGp1c3Qgc3VtIHVwIGFsbCBjaGlsZHJlbiBhbmQgYWRkIHRoZW0gdG8gdGhlIG9yaWdpbmFsIHdlaWdodFxuICAgICAgICAgIHJldHVybiBub2RlLndlaWdodCArIGNoaWxkV2VpZ2h0cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXk3LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0RheTcudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRmMmQwOTgwXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRGF5Ny52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5Ny52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm5hbWVzIjpbImNvbXBvbmVudHMiLCJEYXkiLCJkYXRhIiwic29sdXRpb25zIiwicGFydE9uZSIsInBhcnRUd28iLCJtZXRob2RzIiwib25JbnB1dENoYW5nZWQiLCJwYXJlbnQiLCJuYW1lIiwid2VpZ2h0IiwiY2hpbGRyZW4iLCJzb2x2ZSIsIm1hcHBpbmciLCJub2RlIiwiY2hpbGQiLCJyb290IiwicmVjdXJzZSIsImNoaWxkV2VpZ2h0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15072\n")}}]);