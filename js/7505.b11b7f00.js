"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[7505],{44196:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day13)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day13.vue?vue&type=template&id=1d1384a8\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":13,\"year\":2018,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(36100);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day13.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day13vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      // What to do on which grid cell symbol\n      gridCells: {\n        '|': cart => {},\n        '-': cart => {},\n        '+': cart => {\n          // Adjust the orientation based on the next turn direction\n          cart.or = this.directions[cart.or][cart.nextTurn];\n          // Adjust the next turn based on the next index in the turns array\n          cart.nextTurn = this.turns[(this.turns.indexOf(cart.nextTurn) + 1) % this.turns.length];\n        },\n        '/': cart => {\n          switch (cart.or) {\n            case '^':\n              cart.or = '>';\n              break;\n            case '>':\n              cart.or = '^';\n              break;\n            case 'v':\n              cart.or = '<';\n              break;\n            case '<':\n              cart.or = 'v';\n              break;\n          }\n        },\n        '\\\\': cart => {\n          switch (cart.or) {\n            case '^':\n              cart.or = '<';\n              break;\n            case '>':\n              cart.or = 'v';\n              break;\n            case 'v':\n              cart.or = '>';\n              break;\n            case '<':\n              cart.or = '^';\n              break;\n          }\n        }\n      },\n      // Directions to handle turns and movements\n      directions: {\n        '^': {\n          left: '<',\n          right: '>',\n          straight: '^',\n          move: cart => cart.y--\n        },\n        '>': {\n          left: '^',\n          right: 'v',\n          straight: '>',\n          move: cart => cart.x++\n        },\n        v: {\n          left: '>',\n          right: '<',\n          straight: 'v',\n          move: cart => cart.y++\n        },\n        '<': {\n          left: 'v',\n          right: '^',\n          straight: '<',\n          move: cart => cart.x--\n        }\n      },\n      turns: ['left', 'straight', 'right']\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.solutions.partOne = null;\n      this.solutions.partTwo = null;\n      // Valid cart markers\n      const cartsMarkers = ['^', '>', 'v', '<'];\n\n      // Parse the grid\n      this.grid = input.map(i => i.split(''));\n      // Parse the carts\n      this.carts = [];\n\n      // Go through the grid\n      for (let y = 0; y < this.grid.length; y++) {\n        for (let x = 0; x < this.grid[y].length; x++) {\n          // Check if it's a cart\n          const cartIndex = cartsMarkers.indexOf(this.grid[y][x]);\n          if (cartIndex !== -1) {\n            // Push it to the array with its position, orientation and next turn direction\n            this.carts.push({\n              x: x,\n              y: y,\n              or: this.grid[y][x],\n              nextTurn: 'left'\n            });\n\n            // Replace the symbol on the grid with a rail\n            if (this.grid[y][x] === '<' || this.grid[y][x] === '>') {\n              this.grid[y][x] = '-';\n            } else {\n              this.grid[y][x] = '|';\n            }\n          }\n        }\n      }\n      this.solve();\n    },\n    /**\n     * Sorts the given carts based on their action order, first on y then on x\n     */\n    getCartsInOrder: function (carts) {\n      return carts.concat().sort((a, b) => {\n        if (a.y !== b.y) {\n          return a.y - b.y;\n        } else {\n          return a.x - b.x;\n        }\n      });\n    },\n    solve: function () {\n      let lCarts = this.carts.concat();\n      const locs = new Set();\n      lCarts.forEach(c => locs.add(`${c.x},${c.y}`));\n      while (true) {\n        lCarts = this.getCartsInOrder(lCarts);\n        let pos = 0;\n        while (pos < lCarts.length) {\n          // for (let c = 0; c < lCarts.length; c++) {\n          const cart = lCarts[pos];\n          // Remove the current cart location from the list\n          const oldLoc = `${cart.x},${cart.y}`;\n          locs.delete(oldLoc);\n\n          // Move the cart\n          this.directions[cart.or].move(cart);\n          // Get the grid cell at that location\n          const cell = this.grid[cart.y][cart.x];\n          // Turn the cart if necessary\n          this.gridCells[cell](cart);\n\n          // Check if it collides with any of the others\n          const newLoc = `${cart.x},${cart.y}`;\n\n          // If this was the last cart, we stop here before going any further\n          if (lCarts.length === 1) {\n            this.solutions.partTwo = `${lCarts[0].x},${lCarts[0].y}`;\n            return;\n          }\n\n          // Otherwise, check if this location is occupied\n          if (locs.has(newLoc)) {\n            // If it is, store solution part one if it's the first collision\n            if (!this.solutions.partOne) {\n              this.solutions.partOne = newLoc;\n            }\n\n            // We need to adjust the position, because we are removing items\n            let decrement = 1;\n            lCarts.forEach((c, i) => {\n              // Only count those with the same coordinates but a smaller index\n              if (c.x === cart.x && c.y === cart.y && i < pos) {\n                decrement++;\n              }\n            });\n            // Now actually remove the items\n            lCarts = lCarts.filter(c => !(c.x === cart.x && c.y === cart.y));\n            // Delete the location, cause there's nothing there anymore\n            locs.delete(newLoc);\n            // Decrement the position\n            pos -= decrement;\n          } else {\n            locs.add(newLoc);\n          }\n          pos++;\n        }\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2018/Day13.vue?vue&type=script&lang=js\n /* harmony default export */ const _2018_Day13vue_type_script_lang_js = (Day13vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2018/Day13.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2018_Day13vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day13 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQxOTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxvQ0FBb0M7QUFDek07Ozs7Ozs7Ozs7OztBQ0tBO0FBRUEsbUVBQWU7RUFDZkE7SUFDQUMsR0FBQUEsRUFBQUEsa0JBQUFBO0VBQ0E7RUFDQUM7SUFDQTtNQUNBQztRQUNBQztRQUNBQztNQUNBO01BQ0E7TUFDQUM7UUFDQTtRQUNBO1FBQ0E7VUFDQTtVQUNBQztVQUNBO1VBQ0FBO1FBQ0E7UUFDQTtVQUNBO1lBQ0E7Y0FDQUE7Y0FDQTtZQUNBO2NBQ0FBO2NBQ0E7WUFDQTtjQUNBQTtjQUNBO1lBQ0E7Y0FDQUE7Y0FDQTtVQUNBO1FBQ0E7UUFDQTtVQUNBO1lBQ0E7Y0FDQUE7Y0FDQTtZQUNBO2NBQ0FBO2NBQ0E7WUFDQTtjQUNBQTtjQUNBO1lBQ0E7Y0FDQUE7Y0FDQTtVQUNBO1FBQ0E7TUFDQTtNQUNBO01BQ0FDO1FBQ0E7VUFDQUM7VUFDQUM7VUFDQUM7VUFDQUM7UUFDQTtRQUNBO1VBQ0FIO1VBQ0FDO1VBQ0FDO1VBQ0FDO1FBQ0E7UUFDQUM7VUFDQUo7VUFDQUM7VUFDQUM7VUFDQUM7UUFDQTtRQUNBO1VBQ0FIO1VBQ0FDO1VBQ0FDO1VBQ0FDO1FBQ0E7TUFDQTtNQUNBRTtJQUNBO0VBQ0E7RUFDQUM7SUFDQUM7TUFDQTtNQUNBO01BQ0E7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTs7TUFFQTtNQUNBO1FBQ0E7VUFDQTtVQUNBO1VBQ0E7WUFDQTtZQUNBO2NBQ0FDO2NBQ0FDO2NBQ0FDO2NBQ0FDO1lBQ0E7O1lBRUE7WUFDQTtjQUNBO1lBQ0E7Y0FDQTtZQUNBO1VBQ0E7UUFDQTtNQUNBO01BRUE7SUFDQTtJQUNBO0FBQ0E7QUFDQTtJQUNBQztNQUNBO1FBQ0E7VUFDQTtRQUNBO1VBQ0E7UUFDQTtNQUNBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBO01BQ0FDO01BRUE7UUFDQUE7UUFFQTtRQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQUM7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtZQUNBO1lBQ0E7VUFDQTs7VUFFQTtVQUNBO1lBQ0E7WUFDQTtjQUNBO1lBQ0E7O1lBRUE7WUFDQTtZQUNBRDtjQUNBO2NBQ0E7Z0JBQ0FFO2NBQ0E7WUFDQTtZQUNBO1lBQ0FGO1lBQ0E7WUFDQUM7WUFDQTtZQUNBRTtVQUNBO1lBQ0FGO1VBQ0E7VUFFQUU7UUFDQTtNQUNBO0lBQ0E7RUFDQTtBQUNBLENBQUMsRTs7QUMzTTJQLENBQUMseUVBQWUsNEJBQUcsRUFBQyxDOzs7O0FDQTdMO0FBQzNCO0FBQ0w7OztBQUduRDtBQUNBLENBQXNHO0FBQ3RHLGdCQUFnQixzQ0FBVTtBQUMxQixFQUFFLGtDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkxMy52dWU/NzdhNSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS9zcmMvY29tcG9uZW50cy8yMDE4L0RheTEzLnZ1ZT83NTQ5Iiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkxMy52dWU/MjhlNiIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTgvRGF5MTMudnVlP2E0NDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ0RheScse2F0dHJzOntcImRheVwiOjEzLFwieWVhclwiOjIwMTgsXCJzb2x1dGlvbnNcIjpfdm0uc29sdXRpb25zfSxvbjp7XCJpbnB1dC1jaGFuZ2VkXCI6X3ZtLm9uSW5wdXRDaGFuZ2VkfX0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxEYXkgOmRheT1cIjEzXCIgOnllYXI9XCIyMDE4XCIgOnNvbHV0aW9ucz1cInNvbHV0aW9uc1wiIEBpbnB1dC1jaGFuZ2VkPVwib25JbnB1dENoYW5nZWRcIj5cbiAgPC9EYXk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IERheSBmcm9tICdAL2NvbXBvbmVudHMvRGF5J1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBEYXlcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb2x1dGlvbnM6IHtcbiAgICAgICAgcGFydE9uZTogbnVsbCxcbiAgICAgICAgcGFydFR3bzogbnVsbFxuICAgICAgfSxcbiAgICAgIC8vIFdoYXQgdG8gZG8gb24gd2hpY2ggZ3JpZCBjZWxsIHN5bWJvbFxuICAgICAgZ3JpZENlbGxzOiB7XG4gICAgICAgICd8JzogKGNhcnQpID0+IHt9LFxuICAgICAgICAnLSc6IChjYXJ0KSA9PiB7fSxcbiAgICAgICAgJysnOiAoY2FydCkgPT4ge1xuICAgICAgICAgIC8vIEFkanVzdCB0aGUgb3JpZW50YXRpb24gYmFzZWQgb24gdGhlIG5leHQgdHVybiBkaXJlY3Rpb25cbiAgICAgICAgICBjYXJ0Lm9yID0gdGhpcy5kaXJlY3Rpb25zW2NhcnQub3JdW2NhcnQubmV4dFR1cm5dXG4gICAgICAgICAgLy8gQWRqdXN0IHRoZSBuZXh0IHR1cm4gYmFzZWQgb24gdGhlIG5leHQgaW5kZXggaW4gdGhlIHR1cm5zIGFycmF5XG4gICAgICAgICAgY2FydC5uZXh0VHVybiA9IHRoaXMudHVybnNbKHRoaXMudHVybnMuaW5kZXhPZihjYXJ0Lm5leHRUdXJuKSArIDEpICUgdGhpcy50dXJucy5sZW5ndGhdXG4gICAgICAgIH0sXG4gICAgICAgICcvJzogKGNhcnQpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGNhcnQub3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICBjYXJ0Lm9yID0gJz4nXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgY2FydC5vciA9ICdeJ1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgIGNhcnQub3IgPSAnPCdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICBjYXJ0Lm9yID0gJ3YnXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnXFxcXCc6IChjYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjYXJ0Lm9yKSB7XG4gICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgY2FydC5vciA9ICc8J1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgIGNhcnQub3IgPSAndidcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICBjYXJ0Lm9yID0gJz4nXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgY2FydC5vciA9ICdeJ1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIERpcmVjdGlvbnMgdG8gaGFuZGxlIHR1cm5zIGFuZCBtb3ZlbWVudHNcbiAgICAgIGRpcmVjdGlvbnM6IHtcbiAgICAgICAgJ14nOiB7XG4gICAgICAgICAgbGVmdDogJzwnLFxuICAgICAgICAgIHJpZ2h0OiAnPicsXG4gICAgICAgICAgc3RyYWlnaHQ6ICdeJyxcbiAgICAgICAgICBtb3ZlOiAoY2FydCkgPT4gY2FydC55LS1cbiAgICAgICAgfSxcbiAgICAgICAgJz4nOiB7XG4gICAgICAgICAgbGVmdDogJ14nLFxuICAgICAgICAgIHJpZ2h0OiAndicsXG4gICAgICAgICAgc3RyYWlnaHQ6ICc+JyxcbiAgICAgICAgICBtb3ZlOiAoY2FydCkgPT4gY2FydC54KytcbiAgICAgICAgfSxcbiAgICAgICAgdjoge1xuICAgICAgICAgIGxlZnQ6ICc+JyxcbiAgICAgICAgICByaWdodDogJzwnLFxuICAgICAgICAgIHN0cmFpZ2h0OiAndicsXG4gICAgICAgICAgbW92ZTogKGNhcnQpID0+IGNhcnQueSsrXG4gICAgICAgIH0sXG4gICAgICAgICc8Jzoge1xuICAgICAgICAgIGxlZnQ6ICd2JyxcbiAgICAgICAgICByaWdodDogJ14nLFxuICAgICAgICAgIHN0cmFpZ2h0OiAnPCcsXG4gICAgICAgICAgbW92ZTogKGNhcnQpID0+IGNhcnQueC0tXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0dXJuczogWydsZWZ0JywgJ3N0cmFpZ2h0JywgJ3JpZ2h0J11cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0Q2hhbmdlZDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gbnVsbFxuICAgICAgdGhpcy5zb2x1dGlvbnMucGFydFR3byA9IG51bGxcbiAgICAgIC8vIFZhbGlkIGNhcnQgbWFya2Vyc1xuICAgICAgY29uc3QgY2FydHNNYXJrZXJzID0gWydeJywgJz4nLCAndicsICc8J11cblxuICAgICAgLy8gUGFyc2UgdGhlIGdyaWRcbiAgICAgIHRoaXMuZ3JpZCA9IGlucHV0Lm1hcChpID0+IGkuc3BsaXQoJycpKVxuICAgICAgLy8gUGFyc2UgdGhlIGNhcnRzXG4gICAgICB0aGlzLmNhcnRzID0gW11cblxuICAgICAgLy8gR28gdGhyb3VnaCB0aGUgZ3JpZFxuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmdyaWQubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLmdyaWRbeV0ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgY2FydFxuICAgICAgICAgIGNvbnN0IGNhcnRJbmRleCA9IGNhcnRzTWFya2Vycy5pbmRleE9mKHRoaXMuZ3JpZFt5XVt4XSlcbiAgICAgICAgICBpZiAoY2FydEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gUHVzaCBpdCB0byB0aGUgYXJyYXkgd2l0aCBpdHMgcG9zaXRpb24sIG9yaWVudGF0aW9uIGFuZCBuZXh0IHR1cm4gZGlyZWN0aW9uXG4gICAgICAgICAgICB0aGlzLmNhcnRzLnB1c2goe1xuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICBvcjogdGhpcy5ncmlkW3ldW3hdLFxuICAgICAgICAgICAgICBuZXh0VHVybjogJ2xlZnQnXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBzeW1ib2wgb24gdGhlIGdyaWQgd2l0aCBhIHJhaWxcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWRbeV1beF0gPT09ICc8JyB8fCB0aGlzLmdyaWRbeV1beF0gPT09ICc+Jykge1xuICAgICAgICAgICAgICB0aGlzLmdyaWRbeV1beF0gPSAnLSdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZ3JpZFt5XVt4XSA9ICd8J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNvbHZlKClcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBnaXZlbiBjYXJ0cyBiYXNlZCBvbiB0aGVpciBhY3Rpb24gb3JkZXIsIGZpcnN0IG9uIHkgdGhlbiBvbiB4XG4gICAgICovXG4gICAgZ2V0Q2FydHNJbk9yZGVyOiBmdW5jdGlvbiAoY2FydHMpIHtcbiAgICAgIHJldHVybiBjYXJ0cy5jb25jYXQoKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnkgIT09IGIueSkge1xuICAgICAgICAgIHJldHVybiBhLnkgLSBiLnlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYS54IC0gYi54XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBzb2x2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGxDYXJ0cyA9IHRoaXMuY2FydHMuY29uY2F0KClcbiAgICAgIGNvbnN0IGxvY3MgPSBuZXcgU2V0KClcbiAgICAgIGxDYXJ0cy5mb3JFYWNoKGMgPT4gbG9jcy5hZGQoYCR7Yy54fSwke2MueX1gKSlcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbENhcnRzID0gdGhpcy5nZXRDYXJ0c0luT3JkZXIobENhcnRzKVxuXG4gICAgICAgIGxldCBwb3MgPSAwXG4gICAgICAgIHdoaWxlIChwb3MgPCBsQ2FydHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIGZvciAobGV0IGMgPSAwOyBjIDwgbENhcnRzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgY29uc3QgY2FydCA9IGxDYXJ0c1twb3NdXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50IGNhcnQgbG9jYXRpb24gZnJvbSB0aGUgbGlzdFxuICAgICAgICAgIGNvbnN0IG9sZExvYyA9IGAke2NhcnQueH0sJHtjYXJ0Lnl9YFxuICAgICAgICAgIGxvY3MuZGVsZXRlKG9sZExvYylcblxuICAgICAgICAgIC8vIE1vdmUgdGhlIGNhcnRcbiAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNbY2FydC5vcl0ubW92ZShjYXJ0KVxuICAgICAgICAgIC8vIEdldCB0aGUgZ3JpZCBjZWxsIGF0IHRoYXQgbG9jYXRpb25cbiAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5ncmlkW2NhcnQueV1bY2FydC54XVxuICAgICAgICAgIC8vIFR1cm4gdGhlIGNhcnQgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgdGhpcy5ncmlkQ2VsbHNbY2VsbF0oY2FydClcblxuICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGNvbGxpZGVzIHdpdGggYW55IG9mIHRoZSBvdGhlcnNcbiAgICAgICAgICBjb25zdCBuZXdMb2MgPSBgJHtjYXJ0Lnh9LCR7Y2FydC55fWBcblxuICAgICAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IGNhcnQsIHdlIHN0b3AgaGVyZSBiZWZvcmUgZ29pbmcgYW55IGZ1cnRoZXJcbiAgICAgICAgICBpZiAobENhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zb2x1dGlvbnMucGFydFR3byA9IGAke2xDYXJ0c1swXS54fSwke2xDYXJ0c1swXS55fWBcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgdGhpcyBsb2NhdGlvbiBpcyBvY2N1cGllZFxuICAgICAgICAgIGlmIChsb2NzLmhhcyhuZXdMb2MpKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcywgc3RvcmUgc29sdXRpb24gcGFydCBvbmUgaWYgaXQncyB0aGUgZmlyc3QgY29sbGlzaW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMuc29sdXRpb25zLnBhcnRPbmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zb2x1dGlvbnMucGFydE9uZSA9IG5ld0xvY1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGFkanVzdCB0aGUgcG9zaXRpb24sIGJlY2F1c2Ugd2UgYXJlIHJlbW92aW5nIGl0ZW1zXG4gICAgICAgICAgICBsZXQgZGVjcmVtZW50ID0gMVxuICAgICAgICAgICAgbENhcnRzLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSBjb3VudCB0aG9zZSB3aXRoIHRoZSBzYW1lIGNvb3JkaW5hdGVzIGJ1dCBhIHNtYWxsZXIgaW5kZXhcbiAgICAgICAgICAgICAgaWYgKGMueCA9PT0gY2FydC54ICYmIGMueSA9PT0gY2FydC55ICYmIGkgPCBwb3MpIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQrK1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gTm93IGFjdHVhbGx5IHJlbW92ZSB0aGUgaXRlbXNcbiAgICAgICAgICAgIGxDYXJ0cyA9IGxDYXJ0cy5maWx0ZXIoYyA9PiAhKGMueCA9PT0gY2FydC54ICYmIGMueSA9PT0gY2FydC55KSlcbiAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgbG9jYXRpb24sIGNhdXNlIHRoZXJlJ3Mgbm90aGluZyB0aGVyZSBhbnltb3JlXG4gICAgICAgICAgICBsb2NzLmRlbGV0ZShuZXdMb2MpXG4gICAgICAgICAgICAvLyBEZWNyZW1lbnQgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICBwb3MgLT0gZGVjcmVtZW50XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY3MuYWRkKG5ld0xvYylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3MrK1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxMy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxMy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vRGF5MTMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFkMTM4NGE4XCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRGF5MTMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0RheTEzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOlsiY29tcG9uZW50cyIsIkRheSIsImRhdGEiLCJzb2x1dGlvbnMiLCJwYXJ0T25lIiwicGFydFR3byIsImdyaWRDZWxscyIsImNhcnQiLCJkaXJlY3Rpb25zIiwibGVmdCIsInJpZ2h0Iiwic3RyYWlnaHQiLCJtb3ZlIiwidiIsInR1cm5zIiwibWV0aG9kcyIsIm9uSW5wdXRDaGFuZ2VkIiwieCIsInkiLCJvciIsIm5leHRUdXJuIiwiZ2V0Q2FydHNJbk9yZGVyIiwic29sdmUiLCJsQ2FydHMiLCJsb2NzIiwiZGVjcmVtZW50IiwicG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44196\n")}}]);