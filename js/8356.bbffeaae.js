"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[8356],{32183:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day20)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day20.vue?vue&type=template&id=01f27de8\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":20,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partTwo\",fn:function(){return [_c('pre',{staticClass:\"day-20-code border\"},[_c('code',{domProps:{\"innerHTML\":_vm._s(_vm.gridTwo)}}),_vm._v(\"\\n      \")])]},proxy:true}])})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./src/util/MonsterDrawer.js\nclass MonsterDrawer {\n  constructor(grid) {\n    this.$grid = grid;\n  }\n  getFormattedGrid() {\n    let result = '';\n    for (let y = 0; y < this.$grid.length; y++) {\n      for (let x = 0; x < this.$grid[y].length; x++) {\n        if (this.$grid[y][x] === 'O') {\n          result += '<span class=\"day-20-monster\">O</span>';\n        } else {\n          result += this.$grid[y][x];\n        }\n      }\n      result += '<br/>';\n    }\n    return result;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day20.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ const Day20vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      gridTwo: null\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.gridTwo = null;\n      this.parts = [];\n      let id;\n      let part = [];\n      input.forEach(i => {\n        if (i === '') {\n          this.parts.push({\n            id,\n            part\n          });\n          id = null;\n          part = [];\n        } else if (i.includes('Tile ')) {\n          id = +i.replace(/\\D/g, '');\n        } else {\n          part.push(i.split('').map(c => c === '#'));\n        }\n      });\n      if (id !== null) {\n        this.parts.push({\n          id,\n          part\n        });\n      }\n      this.width = Math.sqrt(this.parts.length);\n      this.solvePartOne();\n      this.solvePartTwo();\n    },\n    rotateRight: function (part) {\n      return part[0].map((val, index) => part.map(row => row[index]).reverse());\n    },\n    flip: function (part) {\n      return part.map(p => p.map((c, index) => p[index]).reverse());\n    },\n    expand: function (parts) {\n      const expandedParts = [];\n      parts.forEach(p => {\n        // Get all rotations\n        const zero = p.part;\n        const ninety = this.rotateRight(zero);\n        const oneeighty = this.rotateRight(ninety);\n        const seventwenty = this.rotateRight(oneeighty);\n        // And their flipped options\n        const flipZero = this.flip(zero);\n        const flipNinety = this.flip(ninety);\n        const flipOneeighty = this.flip(oneeighty);\n        const flipSeventwenty = this.flip(seventwenty);\n\n        // Add them all\n        expandedParts.push({\n          id: p.id,\n          part: zero\n        });\n        expandedParts.push({\n          id: p.id,\n          part: ninety\n        });\n        expandedParts.push({\n          id: p.id,\n          part: oneeighty\n        });\n        expandedParts.push({\n          id: p.id,\n          part: seventwenty\n        });\n        expandedParts.push({\n          id: p.id,\n          part: flipZero\n        });\n        expandedParts.push({\n          id: p.id,\n          part: flipNinety\n        });\n        expandedParts.push({\n          id: p.id,\n          part: flipOneeighty\n        });\n        expandedParts.push({\n          id: p.id,\n          part: flipSeventwenty\n        });\n      });\n\n      // Keep track of the possible matches for each part\n      this.matches = {};\n      expandedParts.forEach(p => {\n        const m = expandedParts.filter(q => this.match(p.part, q.part, 'left') || this.match(p.part, q.part, 'top') || this.match(p.part, q.part, 'bottom') || this.match(p.part, q.part, 'right')).map(q => q.id);\n        if (!this.matches[p.id]) {\n          this.matches[p.id] = new Set();\n        }\n        m.filter(c => c !== p.id).forEach(c => this.matches[p.id].add(c));\n      });\n      return expandedParts;\n    },\n    recurse: function (allParts, usedParts, index, usedIds) {\n      // Get the x and y position in the puzzle\n      const x = index % this.width;\n      const y = Math.floor(index / this.width);\n\n      // If we've hit the last index (bottom right of the puzzle), return the used parts\n      if (index === this.parts.length) {\n        return usedParts;\n      }\n\n      // Get the part to the left and the top if this one\n      const left = x > 0 ? usedParts[index - 1] : null;\n      const top = y > 0 ? usedParts[index - this.width] : null;\n\n      // Get all possible options for this position by exluding all the ones we've used already\n      const possibleParts = allParts.filter(p => usedIds.indexOf(p.id) === -1);\n\n      // Iterate through them all\n      for (let i = 0; i < possibleParts.length; i++) {\n        const p = possibleParts[i];\n        // If they match together\n        if ((!left || this.matches[left.id].has(p.id) && this.match(left.part, p.part, 'right')) && (!top || this.matches[top.id].has(p.id) && this.match(top.part, p.part, 'bottom'))) {\n          // Take a copy of the arrays\n          const tempUsedParts = usedParts.concat();\n          const tempUsedIds = usedIds.concat();\n          // Add this one\n          tempUsedParts.push(p);\n          tempUsedIds.push(p.id);\n\n          // Continue recursively\n          const res = this.recurse(allParts, tempUsedParts, index + 1, tempUsedIds);\n\n          // If we found a result, return it\n          if (res !== null) {\n            return res;\n          }\n        }\n      }\n\n      // We have not found a result\n      return null;\n    },\n    match: function (one, two, side) {\n      switch (side) {\n        case 'bottom':\n          // Check the bottom of `one` matches the top of `two`\n          return JSON.stringify(one[one.length - 1]) === JSON.stringify(two[0]);\n        case 'top':\n          // Check the top of `one` matches the bottom of `two`\n          return JSON.stringify(one[0]) === JSON.stringify(two[two.length - 1]);\n        case 'right':\n          // Check the right of `one` matches the left of `two`\n          return JSON.stringify(one.map(r => r[r.length - 1])) === JSON.stringify(two.map(r => r[0]));\n        case 'left':\n          // Check the left of `one` matches the right of `two`\n          return JSON.stringify(one.map(r => r[0])) === JSON.stringify(two.map(r => r[r.length - 1]));\n      }\n    },\n    replaceAll: function (grid, monster) {\n      // Keep track of the number of monsters\n      let counter = 0;\n      // Iterate through the grid\n      grid.forEach((row, y) => {\n        row.forEach((_, x) => {\n          // Keep track of whether all monster positions exist and are '#'s\n          const all = monster.filter(m => grid[y + m[0]] !== undefined && grid[y + m[0]][x + m[1]] === '#').length === monster.length;\n\n          // If we have a complete monster, replace all parts with 'O's\n          if (all) {\n            monster.forEach(m => {\n              // Set it to 'O' to indicate it's been used\n              grid[y + m[0]][x + m[1]] = 'O';\n              counter++;\n            });\n          }\n        });\n      });\n      return counter > 0;\n    },\n    solvePartOne: function () {\n      // Expand the parts by getting all rotated and flipped options\n      const expanded = this.expand(this.parts);\n\n      // Solve this recursively. We start with all parts, no used parts, the top left index and no used ids.\n      this.usedParts = this.recurse(expanded, [], 0, []);\n\n      // The result is the corner ids multiplicated together\n      this.solutions.partOne = this.usedParts[0].id * this.usedParts[this.width - 1].id * this.usedParts[this.usedParts.length - 1].id * this.usedParts[this.usedParts.length - this.width].id;\n    },\n    solvePartTwo: function () {\n      // Map each part by removing its border\n      const borderRemoved = this.usedParts.map(p => {\n        // Remove first and last row based on the index\n        return p.part.filter((row, index) => index !== 0 && index !== p.part.length - 1).map(row => {\n          // Within each row, remove first and last entry\n          row.shift();\n          row.pop();\n          return row.map(c => c ? '#' : '.').join('');\n        });\n      });\n\n      // Join them all together\n      const joined = [];\n      // Iterate width in both dimensions across the parts\n      for (let y = 0; y < this.width; y++) {\n        for (let x = 0; x < this.width; x++) {\n          // Get the index of the part in our result\n          const part = borderRemoved[y * this.width + x];\n\n          // Within the part\n          for (let innerY = 0; innerY < part.length; innerY++) {\n            // Get the index in the joined grid\n            const joinedY = y * 8 + innerY;\n            // If it doesn't exist, create it\n            if (joined.length <= joinedY) {\n              joined.push('');\n            }\n\n            // Then concatenate the parts\n            joined[joinedY] = joined[joinedY] + part[innerY];\n          }\n        }\n      }\n\n      // Finally, we split it back apart\n      const largeGrid = joined.map(j => j.split(''));\n      const rotatedAndFlipped = this.expand([{\n        id: null,\n        part: largeGrid\n      }]);\n\n      // Define the monster as relative coordinates\n      const monster = [[0, 18], [1, 0], [1, 5], [1, 6], [1, 11], [1, 12], [1, 17], [1, 18], [1, 19], [2, 1], [2, 4], [2, 7], [2, 10], [2, 13], [2, 16]];\n      rotatedAndFlipped.forEach(r => {\n        const part = r.part;\n        // Check if the monster exists in there\n        if (this.replaceAll(part, monster)) {\n          // Count the non-monster '#'s\n          const counter = part.map(row => row.filter(c => c === '#').length).reduce((a, b) => a + b);\n\n          // Start the drawer\n          this.gridTwo = new MonsterDrawer(part).getFormattedGrid();\n\n          // The answer is the count\n          this.solutions.partTwo = counter;\n        }\n      });\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2020/Day20.vue?vue&type=script&lang=js\n /* harmony default export */ const _2020_Day20vue_type_script_lang_js = (Day20vue_type_script_lang_js); \n;// CONCATENATED MODULE: ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-12.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day20.vue?vue&type=style&index=0&id=01f27de8&prod&lang=css\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./src/components/2020/Day20.vue?vue&type=style&index=0&id=01f27de8&prod&lang=css\n\n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2020/Day20.vue\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2020_Day20vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day20 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIxODMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxtQ0FBbUMsc0JBQXNCLDRCQUE0QixrQkFBa0IsaUNBQWlDLGFBQWEsVUFBVSxpQ0FBaUMsd0JBQXdCLFlBQVksR0FBRztBQUM1WTs7Ozs7O0FDRGUsTUFBTUEsYUFBYSxDQUFDO0VBQ2pDQyxXQUFXQSxDQUFFQyxJQUFJLEVBQUU7SUFDakIsSUFBSSxDQUFDQyxLQUFLLEdBQUdELElBQUk7RUFDbkI7RUFFQUUsZ0JBQWdCQSxDQUFBLEVBQUk7SUFDbEIsSUFBSUMsTUFBTSxHQUFHLEVBQUU7SUFFZixLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUMxQyxLQUFLLElBQUlFLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ0csQ0FBQyxDQUFDLENBQUNDLE1BQU0sRUFBRUMsQ0FBQyxFQUFFLEVBQUU7UUFDN0MsSUFBSSxJQUFJLENBQUNMLEtBQUssQ0FBQ0csQ0FBQyxDQUFDLENBQUNFLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRTtVQUM1QkgsTUFBTSxJQUFJLHVDQUF1QztRQUNuRCxDQUFDLE1BQU07VUFDTEEsTUFBTSxJQUFJLElBQUksQ0FBQ0YsS0FBSyxDQUFDRyxDQUFDLENBQUMsQ0FBQ0UsQ0FBQyxDQUFDO1FBQzVCO01BQ0Y7TUFDQUgsTUFBTSxJQUFJLE9BQU87SUFDbkI7SUFFQSxPQUFPQSxNQUFNO0VBQ2Y7QUFDRixDOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFFQTtBQUVBLG1FQUFlO0VBQ2ZJO0lBQ0FDLEdBQUFBLEVBQUFBLGtCQUFBQTtFQUNBO0VBQ0FDO0lBQ0E7TUFDQUM7UUFDQUM7UUFDQUM7TUFDQTtNQUNBQztJQUNBO0VBQ0E7RUFDQUM7SUFDQUM7TUFDQTtNQUNBO01BRUE7TUFDQTtNQUNBQztRQUNBO1VBQ0E7WUFDQUM7WUFDQUM7VUFDQTtVQUNBRDtVQUNBQztRQUNBO1VBQ0FEO1FBQ0E7VUFDQUM7UUFDQTtNQUNBO01BRUE7UUFDQTtVQUNBRDtVQUNBQztRQUNBO01BQ0E7TUFFQTtNQUVBO01BQ0E7SUFDQTtJQUNBQztNQUNBO0lBQ0E7SUFDQUM7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFFQUM7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBQztVQUFBTjtVQUFBQztRQUFBO1FBQ0FLO1VBQUFOO1VBQUFDO1FBQUE7UUFDQUs7VUFBQU47VUFBQUM7UUFBQTtRQUNBSztVQUFBTjtVQUFBQztRQUFBO1FBQ0FLO1VBQUFOO1VBQUFDO1FBQUE7UUFDQUs7VUFBQU47VUFBQUM7UUFBQTtRQUNBSztVQUFBTjtVQUFBQztRQUFBO1FBQ0FLO1VBQUFOO1VBQUFDO1FBQUE7TUFDQTs7TUFFQTtNQUNBO01BQ0FLO1FBQ0E7UUFDQTtVQUNBO1FBQ0E7UUFFQUM7TUFDQTtNQUVBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBO01BQ0E7O01BRUE7TUFDQTtRQUNBO01BQ0E7O01BRUE7TUFDQTtNQUNBOztNQUVBO01BQ0E7O01BRUE7TUFDQTtRQUNBO1FBQ0E7UUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0FDO1VBQ0FDOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtZQUNBO1VBQ0E7UUFDQTtNQUNBOztNQUVBO01BQ0E7SUFDQTtJQUNBQztNQUNBO1FBQ0E7VUFDQTtVQUNBO1FBQ0E7VUFDQTtVQUNBO1FBQ0E7VUFDQTtVQUNBO1FBQ0E7VUFDQTtVQUNBO01BQ0E7SUFDQTtJQUNBQztNQUNBO01BQ0E7TUFDQTtNQUNBN0I7UUFDQThCO1VBQ0E7VUFDQTs7VUFFQTtVQUNBO1lBQ0FDO2NBQ0E7Y0FDQS9CO2NBQ0FnQztZQUNBO1VBQ0E7UUFDQTtNQUNBO01BRUE7SUFDQTtJQUNBQztNQUNBO01BQ0E7O01BRUE7TUFDQTs7TUFFQTtNQUNBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBO1FBQ0E7UUFDQSxpRkFDQUM7VUFDQTtVQUNBTDtVQUNBQTtVQUNBO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtRQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7Y0FDQU07WUFDQTs7WUFFQTtZQUNBQTtVQUNBO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO01BRUE7UUFBQW5CO1FBQUFDO01BQUE7O01BRUE7TUFDQSxpQkFDQSxTQUNBLHFFQUNBLGtEQUNBO01BRUFtQjtRQUNBO1FBQ0E7UUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1FBQ0E7TUFDQTtJQUNBO0VBQ0E7QUFDQSxDQUFDLEU7O0FDclEyUCxDQUFDLHlFQUFlLDRCQUFHLEVBQUMsQzs7QUNBaFI7Ozs7Ozs7QUVBbUY7QUFDM0I7QUFDTDtBQUNuRCxDQUFpRjs7O0FBR2pGO0FBQ3NHO0FBQ3RHLGdCQUFnQixzQ0FBVTtBQUMxQixFQUFFLGtDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMC9EYXkyMC52dWU/YWUyOSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy91dGlsL01vbnN0ZXJEcmF3ZXIuanM/Yjc4NSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS9zcmMvY29tcG9uZW50cy8yMDIwL0RheTIwLnZ1ZT85NmJkIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMC9EYXkyMC52dWU/MWY4NiIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjAvRGF5MjAudnVlPzA5MzUiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIwL0RheTIwLnZ1ZT85MzIzIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMC9EYXkyMC52dWU/NDdlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnRGF5Jyx7YXR0cnM6e1wiZGF5XCI6MjAsXCJ5ZWFyXCI6MjAyMCxcInNvbHV0aW9uc1wiOl92bS5zb2x1dGlvbnN9LG9uOntcImlucHV0LWNoYW5nZWRcIjpfdm0ub25JbnB1dENoYW5nZWR9LHNjb3BlZFNsb3RzOl92bS5fdShbe2tleTpcInBhcnRUd29cIixmbjpmdW5jdGlvbigpe3JldHVybiBbX2MoJ3ByZScse3N0YXRpY0NsYXNzOlwiZGF5LTIwLWNvZGUgYm9yZGVyXCJ9LFtfYygnY29kZScse2RvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhfdm0uZ3JpZFR3byl9fSksX3ZtLl92KFwiXFxuICAgICAgXCIpXSldfSxwcm94eTp0cnVlfV0pfSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vbnN0ZXJEcmF3ZXIge1xuICBjb25zdHJ1Y3RvciAoZ3JpZCkge1xuICAgIHRoaXMuJGdyaWQgPSBncmlkXG4gIH1cblxuICBnZXRGb3JtYXR0ZWRHcmlkICgpIHtcbiAgICBsZXQgcmVzdWx0ID0gJydcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy4kZ3JpZC5sZW5ndGg7IHkrKykge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLiRncmlkW3ldLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIGlmICh0aGlzLiRncmlkW3ldW3hdID09PSAnTycpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJzxzcGFuIGNsYXNzPVwiZGF5LTIwLW1vbnN0ZXJcIj5PPC9zcGFuPidcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gdGhpcy4kZ3JpZFt5XVt4XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJzxici8+J1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIyMFwiIDp5ZWFyPVwiMjAyMFwiIDpzb2x1dGlvbnM9XCJzb2x1dGlvbnNcIiBAaW5wdXQtY2hhbmdlZD1cIm9uSW5wdXRDaGFuZ2VkXCI+XG4gICAgPHRlbXBsYXRlIHYtc2xvdDpwYXJ0VHdvPlxuICAgICAgPHByZSBjbGFzcz1cImRheS0yMC1jb2RlIGJvcmRlclwiPlxuPGNvZGUgdi1odG1sPVwiZ3JpZFR3b1wiIC8+XG4gICAgICA8L3ByZT5cbiAgICA8L3RlbXBsYXRlPlxuICA8L0RheT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgRGF5IGZyb20gJ0AvY29tcG9uZW50cy9EYXknXG5cbmltcG9ydCBNb25zdGVyRHJhd2VyIGZyb20gJ0AvdXRpbC9Nb25zdGVyRHJhd2VyLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBEYXlcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb2x1dGlvbnM6IHtcbiAgICAgICAgcGFydE9uZTogbnVsbCxcbiAgICAgICAgcGFydFR3bzogbnVsbFxuICAgICAgfSxcbiAgICAgIGdyaWRUd286IG51bGxcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0Q2hhbmdlZDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB0aGlzLmdyaWRUd28gPSBudWxsXG4gICAgICB0aGlzLnBhcnRzID0gW11cblxuICAgICAgbGV0IGlkXG4gICAgICBsZXQgcGFydCA9IFtdXG4gICAgICBpbnB1dC5mb3JFYWNoKGkgPT4ge1xuICAgICAgICBpZiAoaSA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXJ0XG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZCA9IG51bGxcbiAgICAgICAgICBwYXJ0ID0gW11cbiAgICAgICAgfSBlbHNlIGlmIChpLmluY2x1ZGVzKCdUaWxlICcpKSB7XG4gICAgICAgICAgaWQgPSArKGkucmVwbGFjZSgvXFxEL2csICcnKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0LnB1c2goaS5zcGxpdCgnJykubWFwKGMgPT4gYyA9PT0gJyMnKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGFydHMucHVzaCh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFydFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB0aGlzLndpZHRoID0gTWF0aC5zcXJ0KHRoaXMucGFydHMubGVuZ3RoKVxuXG4gICAgICB0aGlzLnNvbHZlUGFydE9uZSgpXG4gICAgICB0aGlzLnNvbHZlUGFydFR3bygpXG4gICAgfSxcbiAgICByb3RhdGVSaWdodDogZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIHJldHVybiBwYXJ0WzBdLm1hcCgodmFsLCBpbmRleCkgPT4gcGFydC5tYXAocm93ID0+IHJvd1tpbmRleF0pLnJldmVyc2UoKSlcbiAgICB9LFxuICAgIGZsaXA6IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICByZXR1cm4gcGFydC5tYXAocCA9PiBwLm1hcCgoYywgaW5kZXgpID0+IHBbaW5kZXhdKS5yZXZlcnNlKCkpXG4gICAgfSxcbiAgICBleHBhbmQ6IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgY29uc3QgZXhwYW5kZWRQYXJ0cyA9IFtdXG5cbiAgICAgIHBhcnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIC8vIEdldCBhbGwgcm90YXRpb25zXG4gICAgICAgIGNvbnN0IHplcm8gPSBwLnBhcnRcbiAgICAgICAgY29uc3QgbmluZXR5ID0gdGhpcy5yb3RhdGVSaWdodCh6ZXJvKVxuICAgICAgICBjb25zdCBvbmVlaWdodHkgPSB0aGlzLnJvdGF0ZVJpZ2h0KG5pbmV0eSlcbiAgICAgICAgY29uc3Qgc2V2ZW50d2VudHkgPSB0aGlzLnJvdGF0ZVJpZ2h0KG9uZWVpZ2h0eSlcbiAgICAgICAgLy8gQW5kIHRoZWlyIGZsaXBwZWQgb3B0aW9uc1xuICAgICAgICBjb25zdCBmbGlwWmVybyA9IHRoaXMuZmxpcCh6ZXJvKVxuICAgICAgICBjb25zdCBmbGlwTmluZXR5ID0gdGhpcy5mbGlwKG5pbmV0eSlcbiAgICAgICAgY29uc3QgZmxpcE9uZWVpZ2h0eSA9IHRoaXMuZmxpcChvbmVlaWdodHkpXG4gICAgICAgIGNvbnN0IGZsaXBTZXZlbnR3ZW50eSA9IHRoaXMuZmxpcChzZXZlbnR3ZW50eSlcblxuICAgICAgICAvLyBBZGQgdGhlbSBhbGxcbiAgICAgICAgZXhwYW5kZWRQYXJ0cy5wdXNoKHsgaWQ6IHAuaWQsIHBhcnQ6IHplcm8gfSlcbiAgICAgICAgZXhwYW5kZWRQYXJ0cy5wdXNoKHsgaWQ6IHAuaWQsIHBhcnQ6IG5pbmV0eSB9KVxuICAgICAgICBleHBhbmRlZFBhcnRzLnB1c2goeyBpZDogcC5pZCwgcGFydDogb25lZWlnaHR5IH0pXG4gICAgICAgIGV4cGFuZGVkUGFydHMucHVzaCh7IGlkOiBwLmlkLCBwYXJ0OiBzZXZlbnR3ZW50eSB9KVxuICAgICAgICBleHBhbmRlZFBhcnRzLnB1c2goeyBpZDogcC5pZCwgcGFydDogZmxpcFplcm8gfSlcbiAgICAgICAgZXhwYW5kZWRQYXJ0cy5wdXNoKHsgaWQ6IHAuaWQsIHBhcnQ6IGZsaXBOaW5ldHkgfSlcbiAgICAgICAgZXhwYW5kZWRQYXJ0cy5wdXNoKHsgaWQ6IHAuaWQsIHBhcnQ6IGZsaXBPbmVlaWdodHkgfSlcbiAgICAgICAgZXhwYW5kZWRQYXJ0cy5wdXNoKHsgaWQ6IHAuaWQsIHBhcnQ6IGZsaXBTZXZlbnR3ZW50eSB9KVxuICAgICAgfSlcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgcG9zc2libGUgbWF0Y2hlcyBmb3IgZWFjaCBwYXJ0XG4gICAgICB0aGlzLm1hdGNoZXMgPSB7fVxuICAgICAgZXhwYW5kZWRQYXJ0cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBjb25zdCBtID0gZXhwYW5kZWRQYXJ0cy5maWx0ZXIocSA9PiB0aGlzLm1hdGNoKHAucGFydCwgcS5wYXJ0LCAnbGVmdCcpIHx8IHRoaXMubWF0Y2gocC5wYXJ0LCBxLnBhcnQsICd0b3AnKSB8fCB0aGlzLm1hdGNoKHAucGFydCwgcS5wYXJ0LCAnYm90dG9tJykgfHwgdGhpcy5tYXRjaChwLnBhcnQsIHEucGFydCwgJ3JpZ2h0JykpLm1hcChxID0+IHEuaWQpXG4gICAgICAgIGlmICghdGhpcy5tYXRjaGVzW3AuaWRdKSB7XG4gICAgICAgICAgdGhpcy5tYXRjaGVzW3AuaWRdID0gbmV3IFNldCgpXG4gICAgICAgIH1cblxuICAgICAgICBtLmZpbHRlcihjID0+IGMgIT09IHAuaWQpLmZvckVhY2goYyA9PiB0aGlzLm1hdGNoZXNbcC5pZF0uYWRkKGMpKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGV4cGFuZGVkUGFydHNcbiAgICB9LFxuICAgIHJlY3Vyc2U6IGZ1bmN0aW9uIChhbGxQYXJ0cywgdXNlZFBhcnRzLCBpbmRleCwgdXNlZElkcykge1xuICAgICAgLy8gR2V0IHRoZSB4IGFuZCB5IHBvc2l0aW9uIGluIHRoZSBwdXp6bGVcbiAgICAgIGNvbnN0IHggPSBpbmRleCAlIHRoaXMud2lkdGhcbiAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy53aWR0aClcblxuICAgICAgLy8gSWYgd2UndmUgaGl0IHRoZSBsYXN0IGluZGV4IChib3R0b20gcmlnaHQgb2YgdGhlIHB1enpsZSksIHJldHVybiB0aGUgdXNlZCBwYXJ0c1xuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdXNlZFBhcnRzXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgcGFydCB0byB0aGUgbGVmdCBhbmQgdGhlIHRvcCBpZiB0aGlzIG9uZVxuICAgICAgY29uc3QgbGVmdCA9IHggPiAwID8gdXNlZFBhcnRzW2luZGV4IC0gMV0gOiBudWxsXG4gICAgICBjb25zdCB0b3AgPSB5ID4gMCA/IHVzZWRQYXJ0c1tpbmRleCAtIHRoaXMud2lkdGhdIDogbnVsbFxuXG4gICAgICAvLyBHZXQgYWxsIHBvc3NpYmxlIG9wdGlvbnMgZm9yIHRoaXMgcG9zaXRpb24gYnkgZXhsdWRpbmcgYWxsIHRoZSBvbmVzIHdlJ3ZlIHVzZWQgYWxyZWFkeVxuICAgICAgY29uc3QgcG9zc2libGVQYXJ0cyA9IGFsbFBhcnRzLmZpbHRlcihwID0+IHVzZWRJZHMuaW5kZXhPZihwLmlkKSA9PT0gLTEpXG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGVtIGFsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NzaWJsZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHAgPSBwb3NzaWJsZVBhcnRzW2ldXG4gICAgICAgIC8vIElmIHRoZXkgbWF0Y2ggdG9nZXRoZXJcbiAgICAgICAgaWYgKCghbGVmdCB8fCAodGhpcy5tYXRjaGVzW2xlZnQuaWRdLmhhcyhwLmlkKSAmJiB0aGlzLm1hdGNoKGxlZnQucGFydCwgcC5wYXJ0LCAncmlnaHQnKSkpICYmICghdG9wIHx8ICh0aGlzLm1hdGNoZXNbdG9wLmlkXS5oYXMocC5pZCkgJiYgdGhpcy5tYXRjaCh0b3AucGFydCwgcC5wYXJ0LCAnYm90dG9tJykpKSkge1xuICAgICAgICAgIC8vIFRha2UgYSBjb3B5IG9mIHRoZSBhcnJheXNcbiAgICAgICAgICBjb25zdCB0ZW1wVXNlZFBhcnRzID0gdXNlZFBhcnRzLmNvbmNhdCgpXG4gICAgICAgICAgY29uc3QgdGVtcFVzZWRJZHMgPSB1c2VkSWRzLmNvbmNhdCgpXG4gICAgICAgICAgLy8gQWRkIHRoaXMgb25lXG4gICAgICAgICAgdGVtcFVzZWRQYXJ0cy5wdXNoKHApXG4gICAgICAgICAgdGVtcFVzZWRJZHMucHVzaChwLmlkKVxuXG4gICAgICAgICAgLy8gQ29udGludWUgcmVjdXJzaXZlbHlcbiAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnJlY3Vyc2UoYWxsUGFydHMsIHRlbXBVc2VkUGFydHMsIGluZGV4ICsgMSwgdGVtcFVzZWRJZHMpXG5cbiAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIHJlc3VsdCwgcmV0dXJuIGl0XG4gICAgICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSBoYXZlIG5vdCBmb3VuZCBhIHJlc3VsdFxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9LFxuICAgIG1hdGNoOiBmdW5jdGlvbiAob25lLCB0d28sIHNpZGUpIHtcbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIC8vIENoZWNrIHRoZSBib3R0b20gb2YgYG9uZWAgbWF0Y2hlcyB0aGUgdG9wIG9mIGB0d29gXG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9uZVtvbmUubGVuZ3RoIC0gMV0pID09PSBKU09OLnN0cmluZ2lmeSh0d29bMF0pXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgLy8gQ2hlY2sgdGhlIHRvcCBvZiBgb25lYCBtYXRjaGVzIHRoZSBib3R0b20gb2YgYHR3b2BcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob25lWzBdKSA9PT0gSlNPTi5zdHJpbmdpZnkodHdvW3R3by5sZW5ndGggLSAxXSlcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIC8vIENoZWNrIHRoZSByaWdodCBvZiBgb25lYCBtYXRjaGVzIHRoZSBsZWZ0IG9mIGB0d29gXG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9uZS5tYXAociA9PiByW3IubGVuZ3RoIC0gMV0pKSA9PT0gSlNPTi5zdHJpbmdpZnkodHdvLm1hcChyID0+IHJbMF0pKVxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAvLyBDaGVjayB0aGUgbGVmdCBvZiBgb25lYCBtYXRjaGVzIHRoZSByaWdodCBvZiBgdHdvYFxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvbmUubWFwKHIgPT4gclswXSkpID09PSBKU09OLnN0cmluZ2lmeSh0d28ubWFwKHIgPT4gcltyLmxlbmd0aCAtIDFdKSlcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2VBbGw6IGZ1bmN0aW9uIChncmlkLCBtb25zdGVyKSB7XG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgbW9uc3RlcnNcbiAgICAgIGxldCBjb3VudGVyID0gMFxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBncmlkXG4gICAgICBncmlkLmZvckVhY2goKHJvdywgeSkgPT4ge1xuICAgICAgICByb3cuZm9yRWFjaCgoXywgeCkgPT4ge1xuICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbGwgbW9uc3RlciBwb3NpdGlvbnMgZXhpc3QgYW5kIGFyZSAnIydzXG4gICAgICAgICAgY29uc3QgYWxsID0gbW9uc3Rlci5maWx0ZXIobSA9PiBncmlkW3kgKyBtWzBdXSAhPT0gdW5kZWZpbmVkICYmIGdyaWRbeSArIG1bMF1dW3ggKyBtWzFdXSA9PT0gJyMnKS5sZW5ndGggPT09IG1vbnN0ZXIubGVuZ3RoXG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY29tcGxldGUgbW9uc3RlciwgcmVwbGFjZSBhbGwgcGFydHMgd2l0aCAnTydzXG4gICAgICAgICAgaWYgKGFsbCkge1xuICAgICAgICAgICAgbW9uc3Rlci5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgICAvLyBTZXQgaXQgdG8gJ08nIHRvIGluZGljYXRlIGl0J3MgYmVlbiB1c2VkXG4gICAgICAgICAgICAgIGdyaWRbeSArIG1bMF1dW3ggKyBtWzFdXSA9ICdPJ1xuICAgICAgICAgICAgICBjb3VudGVyKytcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGNvdW50ZXIgPiAwXG4gICAgfSxcbiAgICBzb2x2ZVBhcnRPbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEV4cGFuZCB0aGUgcGFydHMgYnkgZ2V0dGluZyBhbGwgcm90YXRlZCBhbmQgZmxpcHBlZCBvcHRpb25zXG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRoaXMuZXhwYW5kKHRoaXMucGFydHMpXG5cbiAgICAgIC8vIFNvbHZlIHRoaXMgcmVjdXJzaXZlbHkuIFdlIHN0YXJ0IHdpdGggYWxsIHBhcnRzLCBubyB1c2VkIHBhcnRzLCB0aGUgdG9wIGxlZnQgaW5kZXggYW5kIG5vIHVzZWQgaWRzLlxuICAgICAgdGhpcy51c2VkUGFydHMgPSB0aGlzLnJlY3Vyc2UoZXhwYW5kZWQsIFtdLCAwLCBbXSlcblxuICAgICAgLy8gVGhlIHJlc3VsdCBpcyB0aGUgY29ybmVyIGlkcyBtdWx0aXBsaWNhdGVkIHRvZ2V0aGVyXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gdGhpcy51c2VkUGFydHNbMF0uaWQgKiB0aGlzLnVzZWRQYXJ0c1t0aGlzLndpZHRoIC0gMV0uaWQgKiB0aGlzLnVzZWRQYXJ0c1t0aGlzLnVzZWRQYXJ0cy5sZW5ndGggLSAxXS5pZCAqIHRoaXMudXNlZFBhcnRzW3RoaXMudXNlZFBhcnRzLmxlbmd0aCAtIHRoaXMud2lkdGhdLmlkXG4gICAgfSxcbiAgICBzb2x2ZVBhcnRUd286IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIE1hcCBlYWNoIHBhcnQgYnkgcmVtb3ZpbmcgaXRzIGJvcmRlclxuICAgICAgY29uc3QgYm9yZGVyUmVtb3ZlZCA9IHRoaXMudXNlZFBhcnRzLm1hcChwID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlIGZpcnN0IGFuZCBsYXN0IHJvdyBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgICAgcmV0dXJuIHAucGFydC5maWx0ZXIoKHJvdywgaW5kZXgpID0+IGluZGV4ICE9PSAwICYmIGluZGV4ICE9PSBwLnBhcnQubGVuZ3RoIC0gMSlcbiAgICAgICAgIC5tYXAocm93ID0+IHtcbiAgICAgICAgICAgLy8gV2l0aGluIGVhY2ggcm93LCByZW1vdmUgZmlyc3QgYW5kIGxhc3QgZW50cnlcbiAgICAgICAgICAgcm93LnNoaWZ0KClcbiAgICAgICAgICAgcm93LnBvcCgpXG4gICAgICAgICAgIHJldHVybiByb3cubWFwKGMgPT4gYyA/ICcjJyA6ICcuJykuam9pbignJylcbiAgICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBKb2luIHRoZW0gYWxsIHRvZ2V0aGVyXG4gICAgICBjb25zdCBqb2luZWQgPSBbXVxuICAgICAgLy8gSXRlcmF0ZSB3aWR0aCBpbiBib3RoIGRpbWVuc2lvbnMgYWNyb3NzIHRoZSBwYXJ0c1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLndpZHRoOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwYXJ0IGluIG91ciByZXN1bHRcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gYm9yZGVyUmVtb3ZlZFt5ICogdGhpcy53aWR0aCArIHhdXG5cbiAgICAgICAgICAvLyBXaXRoaW4gdGhlIHBhcnRcbiAgICAgICAgICBmb3IgKGxldCBpbm5lclkgPSAwOyBpbm5lclkgPCBwYXJ0Lmxlbmd0aDsgaW5uZXJZKyspIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggaW4gdGhlIGpvaW5lZCBncmlkXG4gICAgICAgICAgICBjb25zdCBqb2luZWRZID0geSAqIDggKyBpbm5lcllcbiAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgICAgICAgICAgaWYgKGpvaW5lZC5sZW5ndGggPD0gam9pbmVkWSkge1xuICAgICAgICAgICAgICBqb2luZWQucHVzaCgnJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlbiBjb25jYXRlbmF0ZSB0aGUgcGFydHNcbiAgICAgICAgICAgIGpvaW5lZFtqb2luZWRZXSA9IGpvaW5lZFtqb2luZWRZXSArIHBhcnRbaW5uZXJZXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5hbGx5LCB3ZSBzcGxpdCBpdCBiYWNrIGFwYXJ0XG4gICAgICBjb25zdCBsYXJnZUdyaWQgPSBqb2luZWQubWFwKGogPT4gai5zcGxpdCgnJykpXG5cbiAgICAgIGNvbnN0IHJvdGF0ZWRBbmRGbGlwcGVkID0gdGhpcy5leHBhbmQoW3sgaWQ6IG51bGwsIHBhcnQ6IGxhcmdlR3JpZCB9XSlcblxuICAgICAgLy8gRGVmaW5lIHRoZSBtb25zdGVyIGFzIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gICAgICBjb25zdCBtb25zdGVyID0gW1xuICAgICAgICBbMCwgMThdLFxuICAgICAgICBbMSwgMF0sIFsxLCA1XSwgWzEsIDZdLCBbMSwgMTFdLCBbMSwgMTJdLCBbMSwgMTddLCBbMSwgMThdLCBbMSwgMTldLFxuICAgICAgICBbMiwgMV0sIFsyLCA0XSwgWzIsIDddLCBbMiwgMTBdLCBbMiwgMTNdLCBbMiwgMTZdXG4gICAgICBdXG5cbiAgICAgIHJvdGF0ZWRBbmRGbGlwcGVkLmZvckVhY2gociA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSByLnBhcnRcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1vbnN0ZXIgZXhpc3RzIGluIHRoZXJlXG4gICAgICAgIGlmICh0aGlzLnJlcGxhY2VBbGwocGFydCwgbW9uc3RlcikpIHtcbiAgICAgICAgICAvLyBDb3VudCB0aGUgbm9uLW1vbnN0ZXIgJyMnc1xuICAgICAgICAgIGNvbnN0IGNvdW50ZXIgPSBwYXJ0Lm1hcChyb3cgPT4gcm93LmZpbHRlcihjID0+IGMgPT09ICcjJykubGVuZ3RoKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKVxuXG4gICAgICAgICAgLy8gU3RhcnQgdGhlIGRyYXdlclxuICAgICAgICAgIHRoaXMuZ3JpZFR3byA9IG5ldyBNb25zdGVyRHJhd2VyKHBhcnQpLmdldEZvcm1hdHRlZEdyaWQoKVxuXG4gICAgICAgICAgLy8gVGhlIGFuc3dlciBpcyB0aGUgY291bnRcbiAgICAgICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gY291bnRlclxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbi5kYXktMjAtY29kZSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICMyYzNlNTA7XG4gIGNvbG9yOiAjN2Y4YzhkO1xufVxuLmRheS0yMC1tb25zdGVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJlY2M3MTtcbiAgY29sb3I6ICMyYzNlNTA7XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkyMC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkyMC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/Y2xvbmVkUnVsZVNldC0xMi51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MjAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MDFmMjdkZTgmcHJvZCZsYW5nPWNzc1wiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9EYXkyMC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MDFmMjdkZThcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkyMC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5MjAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vRGF5MjAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MDFmMjdkZTgmcHJvZCZsYW5nPWNzc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOlsiTW9uc3RlckRyYXdlciIsImNvbnN0cnVjdG9yIiwiZ3JpZCIsIiRncmlkIiwiZ2V0Rm9ybWF0dGVkR3JpZCIsInJlc3VsdCIsInkiLCJsZW5ndGgiLCJ4IiwiY29tcG9uZW50cyIsIkRheSIsImRhdGEiLCJzb2x1dGlvbnMiLCJwYXJ0T25lIiwicGFydFR3byIsImdyaWRUd28iLCJtZXRob2RzIiwib25JbnB1dENoYW5nZWQiLCJpbnB1dCIsImlkIiwicGFydCIsInJvdGF0ZVJpZ2h0IiwiZmxpcCIsImV4cGFuZCIsInBhcnRzIiwiZXhwYW5kZWRQYXJ0cyIsIm0iLCJyZWN1cnNlIiwidGVtcFVzZWRQYXJ0cyIsInRlbXBVc2VkSWRzIiwibWF0Y2giLCJyZXBsYWNlQWxsIiwicm93IiwibW9uc3RlciIsImNvdW50ZXIiLCJzb2x2ZVBhcnRPbmUiLCJzb2x2ZVBhcnRUd28iLCJtYXAiLCJqb2luZWQiLCJyb3RhdGVkQW5kRmxpcHBlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32183\n")}}]);