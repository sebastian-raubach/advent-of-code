{"version":3,"file":"js/2576.8237b0fc.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,gBAAgBC,YAAYV,EAAIW,GAAG,CAAC,CAACC,IAAI,UAAUC,GAAG,WAAW,MAAO,CAACT,EAAG,MAAM,CAACU,YAAY,iBAAiB,CAACV,EAAG,SAAS,CAACU,YAAY,SAASR,MAAM,CAAC,GAAK,UAAU,MAAQ,MAAM,OAAS,WAAW,EAAES,OAAM,MAAS,EACjZC,EAAkB,G,WCYtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAZ,UAAAA,CACAa,QAAAA,KACAC,QAAAA,MAEAC,OAAAA,KACAC,MAAAA,EACAC,OAAAA,KAEA,EACAC,QAAAA,CACAhB,eAAAA,SAAAA,GACA,6CAEA,cAGAiB,EAAAA,MAAAA,GAAAA,SAAAA,CAAAA,EAAAA,IAAAA,EAAAA,MAAAA,IAAAA,SAAAA,CAAAA,EAAAA,IAAAA,EAAAA,IAAAA,GAAAA,KAAAA,IAAAA,MAAAA,EAAAA,EAAAA,OAGA,YAEA,QACA,qBAEAC,EAAAA,KAAAA,QAAAA,EAAAA,EAAAA,GAGA,WACAC,EAAAA,EAAAA,GAGA,QAEA,sCAIAN,EAAAA,KAAAA,GAIA,qCAEA,cACA,aAEA,qCACA,EACAO,MAAAA,SAAAA,GACA,QAOA,OALAF,EAAAA,SAAAA,CAAAA,EAAAA,KACA,GACAG,GACA,IAEA,CACA,EACAC,QAAAA,SAAAA,EAAAA,EAAAA,GACA,gBAGA,8BACA,0BACA,2BACA,2BACAJ,EAAAA,SAAAA,CAAAA,EAAAA,KACA,kCACAK,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IACAC,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IACAC,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IACAC,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,GAAAA,IAGA,wBACA,yBAEA,wCACA,oBACA,gBACA,SAEA,CACA,IACA,SAGA,gBACA,KACAC,EAAAA,IAAAA,GAAAA,KAAAA,IAAAA,GAEAA,EAAAA,IAAAA,GAAAA,KAAAA,IAAAA,EAEA,CAGA,QACA,EACAC,aAAAA,SAAAA,EAAAA,GACA,mCACA,sBACA,4BACA,EACAC,SAAAA,WACA,aACAC,KAAAA,EACAC,MAAAA,EACAC,IAAAA,EACAC,OAAAA,GAGA,yBACAC,EAAAA,SAAAA,CAAAA,EAAAA,KACA,kCAEA,iDACA,mDACA,+CACA,uDACA,IAGA,+CACA,UACA,6EACA,8EACA,sCACA,oBACA,yEAEA,WACA,EACAC,KAAAA,WACA,6BACA,yFACA,6BAEA,gCAEAjB,EAAAA,SAAAA,CAAAA,EAAAA,KACA,MACA,kCAEA,gCACA,KAGA,6CAEAkB,YAAAA,IAAAA,OAAAA,sBAAAA,KAAAA,OAAAA,IACA,ICzK6P,I,UCQzPC,GAAY,OACd,EACA/C,EACAiB,GACA,EACA,KACA,WACA,MAIF,EAAe8B,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2021/Day20.vue?a2d9","webpack://advent-of-code/src/components/2021/Day20.vue","webpack://advent-of-code/./src/components/2021/Day20.vue?3f40","webpack://advent-of-code/./src/components/2021/Day20.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":20,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partTwo\",fn:function(){return [_c('div',{staticClass:\"canvas-holder\"},[_c('canvas',{staticClass:\"canvas\",attrs:{\"id\":\"partTwo\",\"width\":\"800\",\"height\":\"500\"}})])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"20\" :year=\"2021\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partTwo>\n      <div class=\"canvas-holder\">\n        <canvas id=\"partTwo\" class=\"canvas\" width=\"800\" height=\"500\" />\n      </div>\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      images: null,\n      round: 0,\n      bounds: null\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const algo = input[0].split('').map(c => c === '#' ? 1 : 0)\n\n      let image = new Map()\n\n      // Parse the grid\n      input.slice(2).forEach((r, y) => r.split('').forEach((c, x) => image.set(`${x},${y}`, c === '#' ? 1 : 0)))\n\n      // Keep track of all intermediate images for drawing\n      const images = [image]\n      // Keep track of background polarity\n      let polarity = 0\n      for (let i = 0; i < 50; i++) {\n        // Enhance the image\n        image = this.enhance(image, algo, polarity)\n\n        // Switch polarity\n        if (algo[0] === 1) {\n          polarity = 1 - polarity\n        }\n\n        if (i === 1) {\n          // Part one\n          this.solutions.partOne = this.count(image)\n        }\n\n        // Remember image\n        images.push(image)\n      }\n\n      // Part two\n      this.solutions.partTwo = this.count(image)\n\n      this.images = images\n      this.round = 0\n\n      this.$nextTick(() => this.drawInit())\n    },\n    count: function (image) {\n      let counter = 0\n      // Count all hashes\n      image.forEach((value, key) => {\n        if (value) {\n          counter++\n        }\n      })\n      return counter\n    },\n    enhance: function (image, algo, polarity) {\n      const enhanced = new Map()\n\n      // Determine span in x and y of grid\n      let minX = Number.MAX_SAFE_INTEGER\n      let minY = Number.MAX_SAFE_INTEGER\n      let maxX = -Number.MAX_SAFE_INTEGER\n      let maxY = -Number.MAX_SAFE_INTEGER\n      image.forEach((value, key) => {\n        const coords = key.split(',').map(c => +c)\n        minX = Math.min(minX, coords[0])\n        minY = Math.min(minY, coords[1])\n        maxX = Math.max(maxX, coords[0])\n        maxY = Math.max(maxY, coords[1])\n      })\n\n      for (let y = minY - 1; y < maxY + 2; y++) {\n        for (let x = minX - 1; x < maxX + 2; x++) {\n          // Get the binary string based on the neighbors\n          const binaryString = this.getNeighbors(x, y).map(c => {\n            const coord = c.join(',')\n            if (image.has(coord)) {\n              return image.get(coord)\n            } else {\n              return polarity\n            }\n          }).join('')\n\n          // Get the value from the algorighm\n          const index = parseInt(binaryString, 2)\n          if (algo[index]) {\n            enhanced.set(`${x},${y}`, 1)\n          } else {\n            enhanced.set(`${x},${y}`, 0)\n          }\n        }\n      }\n\n      return enhanced\n    },\n    getNeighbors: function (x, y) {\n      return [[x - 1, y - 1], [x, y - 1], [x + 1, y - 1],\n              [x - 1, y], [x, y], [x + 1, y],\n              [x - 1, y + 1], [x, y + 1], [x + 1, y + 1]]\n    },\n    drawInit: function () {\n      this.bounds = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n\n      this.images.forEach(i => {\n        i.forEach((value, key) => {\n          const coords = key.split(',').map(c => +c)\n\n          this.bounds.left = Math.min(this.bounds.left, coords[0])\n          this.bounds.right = Math.max(this.bounds.right, coords[0])\n          this.bounds.top = Math.min(this.bounds.top, coords[1])\n          this.bounds.bottom = Math.max(this.bounds.bottom, coords[1])\n        })\n      })\n\n      this.canvas = document.getElementById('partTwo')\n      const factor = 2\n      this.canvas.width = factor * (Math.abs(this.bounds.left) + Math.abs(this.bounds.right))\n      this.canvas.height = factor * (Math.abs(this.bounds.top) + Math.abs(this.bounds.bottom))\n      this.ctx = this.canvas.getContext('2d')\n      this.ctx.scale(factor, factor)\n      this.ctx.translate(Math.abs(this.bounds.left), Math.abs(this.bounds.top))\n\n      this.draw()\n    },\n    draw: function () {\n      this.ctx.fillStyle = '#006266'\n      this.ctx.fillRect(this.bounds.left, this.bounds.top, this.canvas.width, this.canvas.height)\n      this.ctx.fillStyle = '#C4E538'\n\n      const image = this.images[this.round]\n\n      image.forEach((value, key) => {\n        if (value) {\n          const coords = key.split(',').map(c => +c)\n\n          this.ctx.fillRect(coords[0], coords[1], 1, 1)\n        }\n      })\n\n      this.round = (this.round + 1) % this.images.length\n\n      setTimeout(() => window.requestAnimationFrame(this.draw), 100)\n    }\n  }\n}\n</script>\n\n<style scoped>\n.canvas-holder {\n  overflow: auto;\n  height: 500px;\n  width: 100%;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day20.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day20.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day20.vue?vue&type=template&id=1d60609f&scoped=true\"\nimport script from \"./Day20.vue?vue&type=script&lang=js\"\nexport * from \"./Day20.vue?vue&type=script&lang=js\"\nimport style0 from \"./Day20.vue?vue&type=style&index=0&id=1d60609f&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1d60609f\",\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","staticClass","proxy","staticRenderFns","components","Day","data","partOne","partTwo","images","round","bounds","methods","input","image","polarity","count","counter","enhance","minX","minY","maxX","maxY","enhanced","getNeighbors","drawInit","left","right","top","bottom","i","draw","setTimeout","component"],"sourceRoot":""}