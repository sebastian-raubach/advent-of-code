"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[6427],{19072:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day13)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2022/Day13.vue?vue&type=template&id=444796f2\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":13,\"year\":2022,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(36100);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2022/Day13.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\nconst CONTINUE = 0;\nconst RIGHT = 1;\nconst WRONG = 2;\n/* harmony default export */ const Day13vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Keep track of the left and right inputs\n      const left = [];\n      const right = [];\n      for (let i = 1; i < input.length; i += 3) {\n        // Parse them using JSON.parse() into JSON\n        left.push(JSON.parse(input[i - 1]));\n        right.push(JSON.parse(input[i]));\n      }\n\n      // Sum up the indices\n      let sum = 0;\n      for (let i = 0; i < left.length; i++) {\n        // Check whether they are in order\n        const result = this.check(left[i], right[i]);\n        if (result === RIGHT) {\n          // If so, add the index\n          sum += i + 1;\n        }\n      }\n\n      // Solution for part one is the sum\n      this.solutions.partOne = sum;\n\n      // Now concatenate all packets together and add the two dividers\n      const allPackets = left.concat(right).concat([[[2]], [[6]]]);\n\n      // Then sort the packets using our implementation and map them to their string representation\n      const mapped = allPackets.sort((a, b) => this.check(a, b) === RIGHT ? -1 : 1).map(p => JSON.stringify(p));\n\n      // Now search for the divider packets and multiply their indices together\n      this.solutions.partTwo = (mapped.indexOf('[[2]]') + 1) * (mapped.indexOf('[[6]]') + 1);\n    },\n    check: function (left, right) {\n      // Check for both whether they are arrays\n      const lIsArray = Array.isArray(left);\n      const rIsArray = Array.isArray(right);\n      if (left === undefined) {\n        // If the left is undefined, this means that the containing array ran out of items, it's in the right order\n        return RIGHT;\n      } else if (right === undefined) {\n        // If the right is undefined, the containing array ran out of items, it's in the wrong order\n        return WRONG;\n      }\n      if (!lIsArray && !rIsArray) {\n        // If both aren't arrays => they're numbers\n        if (left === right) {\n          // Same number, keep looking\n          return CONTINUE;\n        } else {\n          // Left number is smaller than right\n          return left < right ? RIGHT : WRONG;\n        }\n      } else if (lIsArray && rIsArray) {\n        // If both are arrays, iterate through them\n        const max = Math.max(left.length, right.length);\n        for (let i = 0; i < max; i++) {\n          // For each pair, check them recursively\n          const result = this.check(left[i], right[i]);\n          if (result !== CONTINUE) {\n            // We found a result (either RIGHT or WRONG), therefore, return it\n            return result;\n          }\n        }\n\n        // If we didn't find a result, tell the recursion source to keep looking\n        return CONTINUE;\n      } else if (!lIsArray && rIsArray) {\n        // If the left isn't an array, make it one\n        return this.check([left], right);\n      } else if (lIsArray && !rIsArray) {\n        // If the right isn't an array, make it one\n        return this.check(left, [right]);\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2022/Day13.vue?vue&type=script&lang=js\n /* harmony default export */ const _2022_Day13vue_type_script_lang_js = (Day13vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2022/Day13.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2022_Day13vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day13 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwNzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxvQ0FBb0M7QUFDek07Ozs7Ozs7Ozs7OztBQ0tBO0FBRUE7QUFDQTtBQUNBO0FBRUEsbUVBQWU7RUFDZkE7SUFDQUMsR0FBQUEsRUFBQUEsa0JBQUFBO0VBQ0E7RUFDQUM7SUFDQTtNQUNBQztRQUNBQztRQUNBQztNQUNBO0lBQ0E7RUFDQTtFQUNBQztJQUNBQztNQUNBO01BQ0E7TUFDQTtNQUVBO1FBQ0E7UUFDQUM7UUFDQUM7TUFDQTs7TUFFQTtNQUNBO01BQ0E7UUFDQTtRQUNBO1FBRUE7VUFDQTtVQUNBQztRQUNBO01BQ0E7O01BRUE7TUFDQTs7TUFFQTtNQUNBOztNQUVBO01BQ0E7O01BRUE7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTtNQUNBO01BRUE7UUFDQTtRQUNBO01BQ0E7UUFDQTtRQUNBO01BQ0E7TUFFQTtRQUNBO1FBQ0E7VUFDQTtVQUNBO1FBQ0E7VUFDQTtVQUNBO1FBQ0E7TUFDQTtRQUNBO1FBQ0E7UUFDQTtVQUNBO1VBQ0E7VUFFQTtZQUNBO1lBQ0E7VUFDQTtRQUNBOztRQUVBO1FBQ0E7TUFDQTtRQUNBO1FBQ0E7TUFDQTtRQUNBO1FBQ0E7TUFDQTtJQUNBO0VBQ0E7QUFDQSxDQUFDLEU7O0FDMUcyUCxDQUFDLHlFQUFlLDRCQUFHLEVBQUMsQzs7OztBQ0E3TDtBQUMzQjtBQUNMOzs7QUFHbkQ7QUFDQSxDQUFzRztBQUN0RyxnQkFBZ0Isc0NBQVU7QUFDMUIsRUFBRSxrQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjIvRGF5MTMudnVlPzA3M2QiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvc3JjL2NvbXBvbmVudHMvMjAyMi9EYXkxMy52dWU/ZmYxZCIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjIvRGF5MTMudnVlPzEwMGUiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIyL0RheTEzLnZ1ZT84NTM3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdEYXknLHthdHRyczp7XCJkYXlcIjoxMyxcInllYXJcIjoyMDIyLFwic29sdXRpb25zXCI6X3ZtLnNvbHV0aW9uc30sb246e1wiaW5wdXQtY2hhbmdlZFwiOl92bS5vbklucHV0Q2hhbmdlZH19KX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIxM1wiIDp5ZWFyPVwiMjAyMlwiIDpzb2x1dGlvbnM9XCJzb2x1dGlvbnNcIiBAaW5wdXQtY2hhbmdlZD1cIm9uSW5wdXRDaGFuZ2VkXCI+XG4gIDwvRGF5PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBEYXkgZnJvbSAnQC9jb21wb25lbnRzL0RheSdcblxuY29uc3QgQ09OVElOVUUgPSAwXG5jb25zdCBSSUdIVCA9IDFcbmNvbnN0IFdST05HID0gMlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBEYXlcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb2x1dGlvbnM6IHtcbiAgICAgICAgcGFydE9uZTogbnVsbCxcbiAgICAgICAgcGFydFR3bzogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uSW5wdXRDaGFuZ2VkOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IGlucHV0c1xuICAgICAgY29uc3QgbGVmdCA9IFtdXG4gICAgICBjb25zdCByaWdodCA9IFtdXG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlbSB1c2luZyBKU09OLnBhcnNlKCkgaW50byBKU09OXG4gICAgICAgIGxlZnQucHVzaChKU09OLnBhcnNlKGlucHV0W2kgLSAxXSkpXG4gICAgICAgIHJpZ2h0LnB1c2goSlNPTi5wYXJzZShpbnB1dFtpXSkpXG4gICAgICB9XG5cbiAgICAgIC8vIFN1bSB1cCB0aGUgaW5kaWNlc1xuICAgICAgbGV0IHN1bSA9IDBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZXkgYXJlIGluIG9yZGVyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2hlY2sobGVmdFtpXSwgcmlnaHRbaV0pXG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gUklHSFQpIHtcbiAgICAgICAgICAvLyBJZiBzbywgYWRkIHRoZSBpbmRleFxuICAgICAgICAgIHN1bSArPSBpICsgMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbHV0aW9uIGZvciBwYXJ0IG9uZSBpcyB0aGUgc3VtXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gc3VtXG5cbiAgICAgIC8vIE5vdyBjb25jYXRlbmF0ZSBhbGwgcGFja2V0cyB0b2dldGhlciBhbmQgYWRkIHRoZSB0d28gZGl2aWRlcnNcbiAgICAgIGNvbnN0IGFsbFBhY2tldHMgPSBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KFtbWzJdXSwgW1s2XV1dKVxuXG4gICAgICAvLyBUaGVuIHNvcnQgdGhlIHBhY2tldHMgdXNpbmcgb3VyIGltcGxlbWVudGF0aW9uIGFuZCBtYXAgdGhlbSB0byB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgIGNvbnN0IG1hcHBlZCA9IGFsbFBhY2tldHMuc29ydCgoYSwgYikgPT4gdGhpcy5jaGVjayhhLCBiKSA9PT0gUklHSFQgPyAtMSA6IDEpLm1hcChwID0+IEpTT04uc3RyaW5naWZ5KHApKVxuXG4gICAgICAvLyBOb3cgc2VhcmNoIGZvciB0aGUgZGl2aWRlciBwYWNrZXRzIGFuZCBtdWx0aXBseSB0aGVpciBpbmRpY2VzIHRvZ2V0aGVyXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gKG1hcHBlZC5pbmRleE9mKCdbWzJdXScpICsgMSkgKiAobWFwcGVkLmluZGV4T2YoJ1tbNl1dJykgKyAxKVxuICAgIH0sXG4gICAgY2hlY2s6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIGJvdGggd2hldGhlciB0aGV5IGFyZSBhcnJheXNcbiAgICAgIGNvbnN0IGxJc0FycmF5ID0gQXJyYXkuaXNBcnJheShsZWZ0KVxuICAgICAgY29uc3QgcklzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJpZ2h0KVxuXG4gICAgICBpZiAobGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHRoZSBsZWZ0IGlzIHVuZGVmaW5lZCwgdGhpcyBtZWFucyB0aGF0IHRoZSBjb250YWluaW5nIGFycmF5IHJhbiBvdXQgb2YgaXRlbXMsIGl0J3MgaW4gdGhlIHJpZ2h0IG9yZGVyXG4gICAgICAgIHJldHVybiBSSUdIVFxuICAgICAgfSBlbHNlIGlmIChyaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHRoZSByaWdodCBpcyB1bmRlZmluZWQsIHRoZSBjb250YWluaW5nIGFycmF5IHJhbiBvdXQgb2YgaXRlbXMsIGl0J3MgaW4gdGhlIHdyb25nIG9yZGVyXG4gICAgICAgIHJldHVybiBXUk9OR1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxJc0FycmF5ICYmICFySXNBcnJheSkge1xuICAgICAgICAvLyBJZiBib3RoIGFyZW4ndCBhcnJheXMgPT4gdGhleSdyZSBudW1iZXJzXG4gICAgICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICAgIC8vIFNhbWUgbnVtYmVyLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgICByZXR1cm4gQ09OVElOVUVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMZWZ0IG51bWJlciBpcyBzbWFsbGVyIHRoYW4gcmlnaHRcbiAgICAgICAgICByZXR1cm4gbGVmdCA8IHJpZ2h0ID8gUklHSFQgOiBXUk9OR1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxJc0FycmF5ICYmIHJJc0FycmF5KSB7XG4gICAgICAgIC8vIElmIGJvdGggYXJlIGFycmF5cywgaXRlcmF0ZSB0aHJvdWdoIHRoZW1cbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgobGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgIC8vIEZvciBlYWNoIHBhaXIsIGNoZWNrIHRoZW0gcmVjdXJzaXZlbHlcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNoZWNrKGxlZnRbaV0sIHJpZ2h0W2ldKVxuXG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gQ09OVElOVUUpIHtcbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgcmVzdWx0IChlaXRoZXIgUklHSFQgb3IgV1JPTkcpLCB0aGVyZWZvcmUsIHJldHVybiBpdFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgcmVzdWx0LCB0ZWxsIHRoZSByZWN1cnNpb24gc291cmNlIHRvIGtlZXAgbG9va2luZ1xuICAgICAgICByZXR1cm4gQ09OVElOVUVcbiAgICAgIH0gZWxzZSBpZiAoIWxJc0FycmF5ICYmIHJJc0FycmF5KSB7XG4gICAgICAgIC8vIElmIHRoZSBsZWZ0IGlzbid0IGFuIGFycmF5LCBtYWtlIGl0IG9uZVxuICAgICAgICByZXR1cm4gdGhpcy5jaGVjayhbbGVmdF0sIHJpZ2h0KVxuICAgICAgfSBlbHNlIGlmIChsSXNBcnJheSAmJiAhcklzQXJyYXkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJpZ2h0IGlzbid0IGFuIGFycmF5LCBtYWtlIGl0IG9uZVxuICAgICAgICByZXR1cm4gdGhpcy5jaGVjayhsZWZ0LCBbcmlnaHRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTEzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTEzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9EYXkxMy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NDQ0Nzk2ZjJcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkxMy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5MTMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6WyJjb21wb25lbnRzIiwiRGF5IiwiZGF0YSIsInNvbHV0aW9ucyIsInBhcnRPbmUiLCJwYXJ0VHdvIiwibWV0aG9kcyIsIm9uSW5wdXRDaGFuZ2VkIiwibGVmdCIsInJpZ2h0Iiwic3VtIiwiY2hlY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19072\n")}}]);