{"version":3,"file":"js/6074.7912d76e.js","mappings":"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","sources":["webpack://advent-of-code/./src/components/2018/Day15.vue?a813","webpack://advent-of-code/src/components/2018/Day15.vue","webpack://advent-of-code/./src/components/2018/Day15.vue?b40b","webpack://advent-of-code/./src/components/2018/Day15.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":15,\"year\":2018,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"15\" :year=\"2018\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      directions: [[0, -1], [-1, 0], [1, 0], [0, 1]]\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.grid = input.map(i => i.split(''))\n      this.players = []\n\n      for (let y = 0; y < this.grid.length; y++) {\n        for (let x = 0; x < this.grid[y].length; x++) {\n          if (this.grid[y][x] === 'G' || this.grid[y][x] === 'E') {\n            this.players.push({\n              attack: 3,\n              health: 200,\n              type: this.grid[y][x],\n              x: x,\n              y: y\n            })\n          }\n        }\n      }\n\n      this.solvePartOne()\n      this.solvePartTwo()\n    },\n    findEnemy: function (player, players, grid) {\n      return players.filter(p => p.type !== player.type && p.health > 0)\n        .filter(p => (Math.abs(player.x - p.x) + Math.abs(player.y - p.y)) === 1)\n        .reduce((weakest, curr) => weakest === null || weakest.health > curr.health ? curr : weakest, null)\n    },\n    findNextMovement: function (player, players, grid) {\n      // Map all target position (adjacent cells) of all alive enemies\n      const targetKeys = {}\n      players.filter(p => p.type !== player.type && p.health > 0)\n        .map(p => this.getAdjacents({ x: p.x, y: p.y }).filter(a => grid[a.y][a.x] === '.'))\n        .reduce((acc, list) => acc.concat(...list), [])\n        .forEach(a => {\n          targetKeys[`${a.x},${a.y}`] = a\n        })\n\n      const visited = new Set()\n      visited.add(`${player.x},${player.y}`)\n\n      let paths = [[{ x: player.x, y: player.y }]]\n\n      while (true) {\n        const newPaths = []\n        let targetPaths = []\n\n        paths.forEach(p => {\n          this.getAdjacents(p[p.length - 1]).forEach(a => {\n            const xy = `${a.x},${a.y}`\n            if (targetKeys[xy]) {\n              // We found a path to a target\n              targetPaths.push([...p, a, targetKeys[xy]])\n            } else if (!visited.has(xy) && grid[a.y][a.x] === '.') {\n              // Extend the path\n              newPaths.push([...p, a])\n            }\n            visited.add(xy)\n          })\n        })\n\n        if (targetPaths.length > 0) {\n          // We found at least one path\n          // Sort them based on reading order of last step\n          targetPaths = targetPaths.sort((a, b) => {\n            const al = a[a.length - 1]\n            const bl = b[b.length - 1]\n            return al.y === bl.y ? al.x - bl.x : al.y - bl.y\n          })\n\n          // Return the first step on the shortest path\n          return targetPaths[0][1]\n        }\n\n        // Keep going, no path found yet\n        paths = newPaths\n        if (paths.length < 1) {\n          // There are no reachable targets\n          return null\n        }\n      }\n    },\n    getAdjacents: function (position) {\n      return this.directions.map(d => {\n        return {\n          x: position.x + d[0],\n          y: position.y + d[1]\n        }\n      })\n    },\n    solve: function (grid, players, elfAttackPower) {\n      // Adjust the attack power of all elves\n      players.filter(p => p.type === 'E').forEach(p => { p.attack = elfAttackPower })\n      let round = 0\n      while (true) {\n        players = players.sort((a, b) => a.y === b.y ? a.x - b.x : a.y - b.y)\n\n        for (let i = 0; i < players.length; i++) {\n          const player = players[i]\n\n          if (player.health > 0) {\n            if (players.filter(p => p.health > 0 && p.type !== player.type).length < 1) {\n              return round * players.filter(p => p.health > 0).map(p => p.health).reduce((a, b) => a + b)\n            }\n\n            let enemy = this.findEnemy(player, players, grid)\n            const next = enemy ? null : this.findNextMovement(player, players, grid)\n            if (!enemy && next) {\n              grid[player.y][player.x] = '.'\n              player.x = next.x\n              player.y = next.y\n              grid[player.y][player.x] = player.type\n\n              enemy = this.findEnemy(player, players, grid)\n            }\n\n            if (enemy) {\n              enemy.health -= player.attack\n              if (enemy.health < 1) {\n                grid[enemy.y][enemy.x] = '.'\n\n                // If an elf died and this isn't part 1, return\n                if (enemy.type === 'E' && elfAttackPower !== 3) {\n                  return null\n                }\n              }\n            }\n          }\n        }\n\n        round++\n      }\n    },\n    solvePartOne: function () {\n      this.solutions.partOne = this.solve(JSON.parse(JSON.stringify(this.grid)), JSON.parse(JSON.stringify(this.players)), 3)\n    },\n    solvePartTwo: function () {\n      // Start with an attack power of 4\n      let attackPower = 4\n      while (true) {\n        // Get the result\n        const result = this.solve(JSON.parse(JSON.stringify(this.grid)), JSON.parse(JSON.stringify(this.players)), attackPower)\n\n        // If it succeeded, not elf died, so accept the result\n        if (result !== null) {\n          this.solutions.partTwo = result\n          return\n        }\n\n        // Increase the elf attack power\n        attackPower++\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day15.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day15.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day15.vue?vue&type=template&id=5ba2d910\"\nimport script from \"./Day15.vue?vue&type=script&lang=js\"\nexport * from \"./Day15.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","directions","methods","attack","health","type","x","y","findEnemy","filter","reduce","findNextMovement","players","map","forEach","targetKeys","visited","paths","targetPaths","newPaths","getAdjacents","solve","p","grid","player","enemy","round","solvePartOne","solvePartTwo","attackPower","component"],"sourceRoot":""}