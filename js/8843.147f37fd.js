"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[8843],{4693:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day16)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day16.vue?vue&type=template&id=911e3fee\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":16,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day16.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day16vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const binary = [];\n\n      // Convert the input into a binary array. First, convert hex to binary. Then pad to 4 digits, then push onto the array\n      input[0].split('').forEach(c => parseInt(c, 16).toString(2).padStart(4, '0').split('').forEach(b => binary.push(b)));\n\n      // Calculate the tree structure\n      const root = this.parsePacket(binary);\n\n      // Part one is the sum of version numbers\n      this.solutions.partOne = this.sumVersions(root);\n      // Part two is the total value based on the type id\n      this.solutions.partTwo = this.getTotal(root);\n    },\n    sumVersions: function (node) {\n      // Recursively calculate the version number sum as the sum of this version plus the sum of child versions\n      return node.version + node.packets.map(p => this.sumVersions(p)).reduce((a, b) => a + b, 0);\n    },\n    getTotal: function (node) {\n      // Calculate the total for each child packet\n      const subTotals = node.packets.map(p => this.getTotal(p));\n      // Then reduce them together using the rules\n      switch (node.typeId) {\n        case 0:\n          return subTotals.reduce((a, b) => a + b, 0);\n        case 1:\n          return subTotals.reduce((a, b) => a * b, 1);\n        case 2:\n          return Math.min(...subTotals);\n        case 3:\n          return Math.max(...subTotals);\n        case 4:\n          return node.value;\n        case 5:\n          return subTotals[0] > subTotals[1] ? 1 : 0;\n        case 6:\n          return subTotals[0] < subTotals[1] ? 1 : 0;\n        case 7:\n          return subTotals[0] === subTotals[1] ? 1 : 0;\n        default:\n          return 0;\n      }\n    },\n    parsePacket: function (binary) {\n      // Create a new packet\n      const packet = {\n        version: parseInt(parseInt(binary.slice(0, 3).join(''), 2).toString(10)),\n        typeId: parseInt(parseInt(binary.slice(3, 6).join(''), 2).toString(10)),\n        packets: [],\n        endIndex: 0,\n        value: 0\n      };\n      switch (packet.typeId) {\n        case 4:\n          {\n            // Literal packet\n            // Get the data part of the binary string\n            const num = binary.slice(6, binary.length);\n            // Check how many full parts there are in total\n            const parts = Math.floor(num.length / 5);\n            // Keep track of the digits\n            let digits = '';\n            // Run through each chunk\n            let index = 0;\n            for (; index < parts * 5; index += 5) {\n              // Get the digit\n              digits += num.slice(index + 1, index + 5).join('');\n\n              // If the first bit was a zero, stop\n              if (num[index] === '0') {\n                break;\n              }\n            }\n\n            // The value us the decimal of the binary\n            packet.value = parseInt(parseInt(digits, 2).toString(10));\n\n            // Set the end index\n            packet.endIndex = 6 + index + 5;\n            break;\n          }\n        default:\n          {\n            // Operator\n            // Check if it's a length or a count specification\n            const isLength = parseInt(binary[6]) === 0;\n            if (isLength) {\n              // Get the length of the bit array\n              const len = parseInt(parseInt(binary.slice(7, 7 + 15).join(''), 2).toString(10));\n              let index = 0;\n              // While we haven't reaached the end yet\n              while (index < len) {\n                // Parse the child packet\n                const subPacket = this.parsePacket(binary.slice(22 + index, 22 + len));\n\n                // Remember it\n                packet.packets.push(subPacket);\n\n                // Adjust the index\n                index += subPacket.endIndex;\n              }\n\n              // Remember the end index of THIS packet\n              packet.endIndex = 22 + index;\n            } else {\n              // Get the number of child packets\n              const number = parseInt(parseInt(binary.slice(7, 7 + 11).join(''), 2).toString(10));\n              let index = 0;\n              // Iterate through them\n              for (let p = 0; p < number; p++) {\n                const subPacket = this.parsePacket(binary.slice(18 + length + index, binary.length));\n\n                // Remember it\n                packet.packets.push(subPacket);\n\n                // Adjust the index\n                index += subPacket.endIndex;\n              }\n\n              // Remember the end index of THIS packet\n              packet.endIndex = 18 + index;\n            }\n            break;\n          }\n      }\n      return packet;\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2021/Day16.vue?vue&type=script&lang=js\n /* harmony default export */ const _2021_Day16vue_type_script_lang_js = (Day16vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2021/Day16.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2021_Day16vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day16 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY5My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQixPQUFPLCtDQUErQyxLQUFLLG9DQUFvQztBQUN6TTs7Ozs7Ozs7Ozs7O0FDS0E7QUFFQSxtRUFBZTtFQUNmQTtJQUNBQyxHQUFBQSxFQUFBQSxrQkFBQUE7RUFDQTtFQUNBQztJQUNBO01BQ0FDO1FBQ0FDO1FBQ0FDO01BQ0E7SUFDQTtFQUNBO0VBQ0FDO0lBQ0FDO01BQ0E7O01BRUE7TUFDQUM7O01BRUE7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTtNQUNBO01BQ0E7UUFDQTtVQUNBO1FBQ0E7VUFDQTtRQUNBO1VBQ0E7UUFDQTtVQUNBO1FBQ0E7VUFDQTtRQUNBO1VBQ0E7UUFDQTtVQUNBO1FBQ0E7VUFDQTtRQUNBO1VBQ0E7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztNQUNBO01BRUE7UUFDQTtVQUFBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7Y0FDQTtjQUNBQzs7Y0FFQTtjQUNBO2dCQUNBO2NBQ0E7WUFDQTs7WUFFQTtZQUNBQzs7WUFFQTtZQUNBQTtZQUVBO1VBQ0E7UUFDQTtVQUFBO1lBQ0E7WUFDQTtZQUNBO1lBRUE7Y0FDQTtjQUNBO2NBQ0E7Y0FDQTtjQUNBO2dCQUNBO2dCQUNBOztnQkFFQTtnQkFDQUE7O2dCQUVBO2dCQUNBQztjQUNBOztjQUVBO2NBQ0FEO1lBQ0E7Y0FDQTtjQUNBO2NBQ0E7Y0FDQTtjQUNBO2dCQUNBOztnQkFFQTtnQkFDQUE7O2dCQUVBO2dCQUNBQztjQUNBOztjQUVBO2NBQ0FEO1lBQ0E7WUFFQTtVQUNBO01BQ0E7TUFFQTtJQUNBO0VBQ0E7QUFDQSxDQUFDLEU7O0FDeEoyUCxDQUFDLHlFQUFlLDRCQUFHLEVBQUMsQzs7OztBQ0E3TDtBQUMzQjtBQUNMOzs7QUFHbkQ7QUFDQSxDQUFzRztBQUN0RyxnQkFBZ0Isc0NBQVU7QUFDMUIsRUFBRSxrQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjEvRGF5MTYudnVlPzA5NWEiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxNi52dWU/NTcxMSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjEvRGF5MTYudnVlPzRiOWMiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIxL0RheTE2LnZ1ZT8xYWVmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdEYXknLHthdHRyczp7XCJkYXlcIjoxNixcInllYXJcIjoyMDIxLFwic29sdXRpb25zXCI6X3ZtLnNvbHV0aW9uc30sb246e1wiaW5wdXQtY2hhbmdlZFwiOl92bS5vbklucHV0Q2hhbmdlZH19KX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIxNlwiIDp5ZWFyPVwiMjAyMVwiIDpzb2x1dGlvbnM9XCJzb2x1dGlvbnNcIiBAaW5wdXQtY2hhbmdlZD1cIm9uSW5wdXRDaGFuZ2VkXCI+XG4gIDwvRGF5PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBEYXkgZnJvbSAnQC9jb21wb25lbnRzL0RheSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sdXRpb25zOiB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0Q2hhbmdlZDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBjb25zdCBiaW5hcnkgPSBbXVxuXG4gICAgICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbnRvIGEgYmluYXJ5IGFycmF5LiBGaXJzdCwgY29udmVydCBoZXggdG8gYmluYXJ5LiBUaGVuIHBhZCB0byA0IGRpZ2l0cywgdGhlbiBwdXNoIG9udG8gdGhlIGFycmF5XG4gICAgICBpbnB1dFswXS5zcGxpdCgnJykuZm9yRWFjaChjID0+IHBhcnNlSW50KGMsIDE2KS50b1N0cmluZygyKS5wYWRTdGFydCg0LCAnMCcpLnNwbGl0KCcnKS5mb3JFYWNoKGIgPT4gYmluYXJ5LnB1c2goYikpKVxuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHRyZWUgc3RydWN0dXJlXG4gICAgICBjb25zdCByb290ID0gdGhpcy5wYXJzZVBhY2tldChiaW5hcnkpXG5cbiAgICAgIC8vIFBhcnQgb25lIGlzIHRoZSBzdW0gb2YgdmVyc2lvbiBudW1iZXJzXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gdGhpcy5zdW1WZXJzaW9ucyhyb290KVxuICAgICAgLy8gUGFydCB0d28gaXMgdGhlIHRvdGFsIHZhbHVlIGJhc2VkIG9uIHRoZSB0eXBlIGlkXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gdGhpcy5nZXRUb3RhbChyb290KVxuICAgIH0sXG4gICAgc3VtVmVyc2lvbnM6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAvLyBSZWN1cnNpdmVseSBjYWxjdWxhdGUgdGhlIHZlcnNpb24gbnVtYmVyIHN1bSBhcyB0aGUgc3VtIG9mIHRoaXMgdmVyc2lvbiBwbHVzIHRoZSBzdW0gb2YgY2hpbGQgdmVyc2lvbnNcbiAgICAgIHJldHVybiBub2RlLnZlcnNpb24gKyBub2RlLnBhY2tldHMubWFwKHAgPT4gdGhpcy5zdW1WZXJzaW9ucyhwKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgICB9LFxuICAgIGdldFRvdGFsOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBmb3IgZWFjaCBjaGlsZCBwYWNrZXRcbiAgICAgIGNvbnN0IHN1YlRvdGFscyA9IG5vZGUucGFja2V0cy5tYXAocCA9PiB0aGlzLmdldFRvdGFsKHApKVxuICAgICAgLy8gVGhlbiByZWR1Y2UgdGhlbSB0b2dldGhlciB1c2luZyB0aGUgcnVsZXNcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlSWQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzdWJUb3RhbHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBzdWJUb3RhbHMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbiguLi5zdWJUb3RhbHMpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoLi4uc3ViVG90YWxzKVxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWVcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBzdWJUb3RhbHNbMF0gPiBzdWJUb3RhbHNbMV0gPyAxIDogMFxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIHN1YlRvdGFsc1swXSA8IHN1YlRvdGFsc1sxXSA/IDEgOiAwXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gc3ViVG90YWxzWzBdID09PSBzdWJUb3RhbHNbMV0gPyAxIDogMFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZVBhY2tldDogZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhY2tldFxuICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICB2ZXJzaW9uOiBwYXJzZUludChwYXJzZUludChiaW5hcnkuc2xpY2UoMCwgMykuam9pbignJyksIDIpLnRvU3RyaW5nKDEwKSksXG4gICAgICAgIHR5cGVJZDogcGFyc2VJbnQocGFyc2VJbnQoYmluYXJ5LnNsaWNlKDMsIDYpLmpvaW4oJycpLCAyKS50b1N0cmluZygxMCkpLFxuICAgICAgICBwYWNrZXRzOiBbXSxcbiAgICAgICAgZW5kSW5kZXg6IDAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocGFja2V0LnR5cGVJZCkge1xuICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAvLyBMaXRlcmFsIHBhY2tldFxuICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSBwYXJ0IG9mIHRoZSBiaW5hcnkgc3RyaW5nXG4gICAgICAgICAgY29uc3QgbnVtID0gYmluYXJ5LnNsaWNlKDYsIGJpbmFyeS5sZW5ndGgpXG4gICAgICAgICAgLy8gQ2hlY2sgaG93IG1hbnkgZnVsbCBwYXJ0cyB0aGVyZSBhcmUgaW4gdG90YWxcbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IE1hdGguZmxvb3IobnVtLmxlbmd0aCAvIDUpXG4gICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZGlnaXRzXG4gICAgICAgICAgbGV0IGRpZ2l0cyA9ICcnXG4gICAgICAgICAgLy8gUnVuIHRocm91Z2ggZWFjaCBjaHVua1xuICAgICAgICAgIGxldCBpbmRleCA9IDBcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBwYXJ0cyAqIDU7IGluZGV4ICs9IDUpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGlnaXRcbiAgICAgICAgICAgIGRpZ2l0cyArPSBudW0uc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDUpLmpvaW4oJycpXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBiaXQgd2FzIGEgemVybywgc3RvcFxuICAgICAgICAgICAgaWYgKG51bVtpbmRleF0gPT09ICcwJykge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSB2YWx1ZSB1cyB0aGUgZGVjaW1hbCBvZiB0aGUgYmluYXJ5XG4gICAgICAgICAgcGFja2V0LnZhbHVlID0gcGFyc2VJbnQocGFyc2VJbnQoZGlnaXRzLCAyKS50b1N0cmluZygxMCkpXG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGVuZCBpbmRleFxuICAgICAgICAgIHBhY2tldC5lbmRJbmRleCA9IDYgKyBpbmRleCArIDVcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIE9wZXJhdG9yXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGxlbmd0aCBvciBhIGNvdW50IHNwZWNpZmljYXRpb25cbiAgICAgICAgICBjb25zdCBpc0xlbmd0aCA9IHBhcnNlSW50KGJpbmFyeVs2XSkgPT09IDBcblxuICAgICAgICAgIGlmIChpc0xlbmd0aCkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIGJpdCBhcnJheVxuICAgICAgICAgICAgY29uc3QgbGVuID0gcGFyc2VJbnQocGFyc2VJbnQoYmluYXJ5LnNsaWNlKDcsIDcgKyAxNSkuam9pbignJyksIDIpLnRvU3RyaW5nKDEwKSlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDBcbiAgICAgICAgICAgIC8vIFdoaWxlIHdlIGhhdmVuJ3QgcmVhYWNoZWQgdGhlIGVuZCB5ZXRcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgY2hpbGQgcGFja2V0XG4gICAgICAgICAgICAgIGNvbnN0IHN1YlBhY2tldCA9IHRoaXMucGFyc2VQYWNrZXQoYmluYXJ5LnNsaWNlKDIyICsgaW5kZXgsIDIyICsgbGVuKSlcblxuICAgICAgICAgICAgICAvLyBSZW1lbWJlciBpdFxuICAgICAgICAgICAgICBwYWNrZXQucGFja2V0cy5wdXNoKHN1YlBhY2tldClcblxuICAgICAgICAgICAgICAvLyBBZGp1c3QgdGhlIGluZGV4XG4gICAgICAgICAgICAgIGluZGV4ICs9IHN1YlBhY2tldC5lbmRJbmRleFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgZW5kIGluZGV4IG9mIFRISVMgcGFja2V0XG4gICAgICAgICAgICBwYWNrZXQuZW5kSW5kZXggPSAyMiArIGluZGV4XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGNoaWxkIHBhY2tldHNcbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KHBhcnNlSW50KGJpbmFyeS5zbGljZSg3LCA3ICsgMTEpLmpvaW4oJycpLCAyKS50b1N0cmluZygxMCkpXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlbVxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBudW1iZXI7IHArKykge1xuICAgICAgICAgICAgICBjb25zdCBzdWJQYWNrZXQgPSB0aGlzLnBhcnNlUGFja2V0KGJpbmFyeS5zbGljZSgxOCArIGxlbmd0aCArIGluZGV4LCBiaW5hcnkubGVuZ3RoKSlcblxuICAgICAgICAgICAgICAvLyBSZW1lbWJlciBpdFxuICAgICAgICAgICAgICBwYWNrZXQucGFja2V0cy5wdXNoKHN1YlBhY2tldClcblxuICAgICAgICAgICAgICAvLyBBZGp1c3QgdGhlIGluZGV4XG4gICAgICAgICAgICAgIGluZGV4ICs9IHN1YlBhY2tldC5lbmRJbmRleFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgZW5kIGluZGV4IG9mIFRISVMgcGFja2V0XG4gICAgICAgICAgICBwYWNrZXQuZW5kSW5kZXggPSAxOCArIGluZGV4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFja2V0XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuPC9zdHlsZT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNDAudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MTYudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNDAudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MTYudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0RheTE2LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD05MTFlM2ZlZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0RheTE2LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9EYXkxNi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm5hbWVzIjpbImNvbXBvbmVudHMiLCJEYXkiLCJkYXRhIiwic29sdXRpb25zIiwicGFydE9uZSIsInBhcnRUd28iLCJtZXRob2RzIiwib25JbnB1dENoYW5nZWQiLCJpbnB1dCIsInN1bVZlcnNpb25zIiwiZ2V0VG90YWwiLCJwYXJzZVBhY2tldCIsInZlcnNpb24iLCJ0eXBlSWQiLCJwYWNrZXRzIiwiZW5kSW5kZXgiLCJ2YWx1ZSIsImRpZ2l0cyIsInBhY2tldCIsImluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4693\n")}}]);