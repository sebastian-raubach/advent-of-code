{"version":3,"file":"js/7253.eeac2a59.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCMtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAP,eAAAA,SAAAA,GACA,gBAEAQ,EAAAA,SAAAA,IAEA,yBAEA,QAEA,gCAEA,MAQAC,EANA,SAMAA,EAAAA,IAAAA,GALAA,CACAC,KAAAA,EACAC,UAAAA,IAAAA,KAOAC,EAAAA,SAAAA,IACA,MAQAC,EANA,SAMAA,EAAAA,IAAAA,GALAA,CACAH,KAAAA,EACAC,UAAAA,IAAAA,KAOAE,EAAAA,UAAAA,IAAAA,GACAJ,EAAAA,UAAAA,IAAAA,GAGAK,EAAAA,IAAAA,EAAAA,EAAAA,IAIAA,EAAAA,IAAAA,EAAAA,EAAAA,IAKA,cAEA,6BAEA,8BAGAC,EAAAA,IAAAA,IAEA,QAEAD,EAAAA,SAAAA,CAAAA,EAAAA,KAEA,WAKA,6BAEAE,IAAAA,IAGA,wBACA,EACAC,iBAAAA,SAAAA,EAAAA,EAAAA,GAEA,WAKAC,EAAAA,IAAAA,GAGAJ,EAAAA,IAAAA,GAAAA,UAAAA,SAAAA,GAAAA,KAAAA,iBAAAA,EAAAA,EAAAA,KAAAA,KACA,ICzG6P,I,UCOzPK,GAAY,OACd,EACA7B,EACAW,GACA,EACA,KACA,WACA,MAIF,EAAekB,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2017/Day12.vue?1ece","webpack://advent-of-code/src/components/2017/Day12.vue","webpack://advent-of-code/./src/components/2017/Day12.vue?e8c1","webpack://advent-of-code/./src/components/2017/Day12.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":12,\"year\":2017,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"12\" :year=\"2017\" :solutions=\"solutions\" @input-changed=\"onInputChanged\" />\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const nodes = new Map()\n\n      input.forEach(i => {\n        // Split into source and targets\n        const parts = i.split(' <-> ')\n        // Parse the source\n        const left = +parts[0]\n        // Parse the targets\n        const right = parts[1].split(', ').map(p => +p)\n\n        let source\n        // If the source node hasn't already been created, do so\n        if (!nodes.has(left)) {\n          source = {\n            name: left,\n            neighbors: new Set()\n          }\n        } else {\n          source = nodes.get(left)\n        }\n\n        // For each of the targets\n        right.forEach(r => {\n          let target\n          // If the target node hasn't already been created, do so\n          if (!nodes.has(r)) {\n            target = {\n              name: r,\n              neighbors: new Set()\n            }\n          } else {\n            target = nodes.get(r)\n          }\n\n          // Add the connection to each\n          target.neighbors.add(source)\n          source.neighbors.add(target)\n\n          // Store the target back in the map\n          nodes.set(r, target)\n        })\n\n        // Store the source back in the map\n        nodes.set(left, source)\n      })\n\n      // We do a DFS from the first node\n      // Keep track of visited nodes\n      let neighborhood = new Set()\n      // Recurse through all neighbors\n      this.recurseNeighbors(nodes, 0, neighborhood)\n      // The solution is the size of the visited nodes\n      this.solutions.partOne = neighborhood.size\n\n      // Reset for part two\n      neighborhood = new Set()\n      // Count the groups\n      let groups = 0\n      // Iterate over all nodes\n      nodes.forEach((node, name) => {\n        // If it has been visited, ignore it, since it's already part of a group\n        if (neighborhood.has(name)) {\n          return\n        }\n\n        // Otherwise, recurse through all its neighbors with DFS\n        this.recurseNeighbors(nodes, name, neighborhood)\n        // And increase the group counter\n        groups++\n      })\n\n      this.solutions.partTwo = groups\n    },\n    recurseNeighbors: function (nodes, current, visited) {\n      // If we've visited this one before, return\n      if (visited.has(current)) {\n        return\n      }\n\n      // Mark as visited\n      visited.add(current)\n\n      // Recurse through all neighbors\n      nodes.get(current).neighbors.forEach(n => this.recurseNeighbors(nodes, n.name, visited))\n    }\n  }\n}\n</script>\n\n<style scoped>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day12.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day12.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day12.vue?vue&type=template&id=b817c48e&scoped=true\"\nimport script from \"./Day12.vue?vue&type=script&lang=js\"\nexport * from \"./Day12.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"b817c48e\",\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","methods","input","source","name","neighbors","right","target","nodes","neighborhood","groups","recurseNeighbors","visited","component"],"sourceRoot":""}