"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[4730],{89928:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ Day19)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day19.vue?vue&type=template&id=7f9fa6b0&scoped=true\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'Day\',{attrs:{"day":19,"year":2021,"solutions":_vm.solutions},on:{"input-changed":_vm.onInputChanged},scopedSlots:_vm._u([{key:"partOne",fn:function(){return [_c(\'div\',{attrs:{"id":"partOne"}})]},proxy:true}])})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day19.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n// Create a map that, for missing keys, sets them to a default value\nclass MapWithDefault extends Map {\n  get(key) {\n    if (!this.has(key)) {\n      this.set(key, this.default());\n    }\n    return super.get(key);\n  }\n  constructor(defaultFunction, entries) {\n    super(entries);\n    this.default = defaultFunction;\n  }\n}\nconst transforms = [([x, y, z]) => [x, y, z], ([x, y, z]) => [x, y, -z], ([x, y, z]) => [x, -y, z], ([x, y, z]) => [x, -y, -z], ([x, y, z]) => [-x, y, z], ([x, y, z]) => [-x, y, -z], ([x, y, z]) => [-x, -y, z], ([x, y, z]) => [-x, -y, -z], ([x, y, z]) => [z, x, y], ([x, y, z]) => [z, x, -y], ([x, y, z]) => [z, -x, y], ([x, y, z]) => [z, -x, -y], ([x, y, z]) => [-z, x, y], ([x, y, z]) => [-z, x, -y], ([x, y, z]) => [-z, -x, y], ([x, y, z]) => [-z, -x, -y], ([x, y, z]) => [y, z, x], ([x, y, z]) => [y, z, -x], ([x, y, z]) => [y, -z, x], ([x, y, z]) => [y, -z, -x], ([x, y, z]) => [-y, z, x], ([x, y, z]) => [-y, z, -x], ([x, y, z]) => [-y, -z, x], ([x, y, z]) => [-y, -z, -x], ([x, y, z]) => [x, z, y], ([x, y, z]) => [x, z, -y], ([x, y, z]) => [x, -z, y], ([x, y, z]) => [x, -z, -y], ([x, y, z]) => [-x, z, y], ([x, y, z]) => [-x, z, -y], ([x, y, z]) => [-x, -z, y], ([x, y, z]) => [-x, -z, -y], ([x, y, z]) => [y, x, z], ([x, y, z]) => [y, x, -z], ([x, y, z]) => [y, -x, z], ([x, y, z]) => [y, -x, -z], ([x, y, z]) => [-y, x, z], ([x, y, z]) => [-y, x, -z], ([x, y, z]) => [-y, -x, z], ([x, y, z]) => [-y, -x, -z], ([x, y, z]) => [z, y, x], ([x, y, z]) => [z, y, -x], ([x, y, z]) => [z, -y, x], ([x, y, z]) => [z, -y, -x], ([x, y, z]) => [-z, y, x], ([x, y, z]) => [-z, y, -x], ([x, y, z]) => [-z, -y, x], ([x, y, z]) => [-z, -y, -x]];\n/* harmony default export */ const Day19vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const scanners = [];\n      let currentScanner = [];\n      for (let i = 0; i < input.length; i++) {\n        if (input[i].length < 1) {\n          // Empty row, push the scanner data onto the array\n          scanners.push(currentScanner);\n          currentScanner = [];\n        } else if (input[i].startsWith(\'---\')) {\n          // Skip header rows\n        } else {\n          // Add the beacon coordinates\n          currentScanner.push(input[i].split(\',\').map(c => +c));\n        }\n      }\n\n      // Add the last scanner\n      scanners.push(currentScanner);\n\n      // Start by setting the first scanner as the origin\n      const absoluteCoords = {\n        \'0,0,0\': scanners[0]\n      };\n\n      // Keep the rest as unmapped\n      const unmapped = scanners.slice(1);\n\n      // While there are still unmapped scanners\n      restart: while (unmapped.length > 0) {\n        // Iterate through all the fixed scanners\n        for (const ac in absoluteCoords) {\n          // Get the fixed scanner beacon coordinates\n          const known = absoluteCoords[ac];\n          // Go through the unmapped scanners\n          for (let i = 0; i < unmapped.length; i++) {\n            // Go through all transforms\n            for (const transform of transforms) {\n              // Transform the unmapped coordinates using the current transform\n              const possible = unmapped[i].map(transform);\n\n              // Count hits\n              const hits = new MapWithDefault(() => 0);\n\n              // For each of the known coordinates\n              for (let k = 0; k < known.length; k++) {\n                // Compare to all of the unmapped coordinates\n                for (let p = 0; p < possible.length; p++) {\n                  // Get the delta\n                  const v = this.minus(known[k], possible[p]);\n                  // Create the key\n                  const vk = v.join(\',\');\n\n                  // Count a hit\n                  hits.set(vk, hits.get(vk) + 1);\n\n                  // If we found enough hits\n                  if (hits.get(vk) >= 12) {\n                    // Add the delta\n                    const found = possible.map(b => this.plus(v, b));\n                    // Add to mapped scanners\n                    absoluteCoords[vk] = found;\n                    // Remove from unmapped\n                    unmapped.splice(i, 1);\n                    // Start over\n                    continue restart;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      const beacons = new Set();\n      for (const ac in absoluteCoords) {\n        absoluteCoords[ac].forEach(c => beacons.add(c.join(\'\')));\n      }\n      this.solutions.partOne = beacons.size;\n      const scannerCoords = Object.keys(absoluteCoords).map(s => s.split(\',\').map(c => +c));\n      let max = 0;\n      scannerCoords.forEach((a, i) => {\n        scannerCoords.forEach((b, j) => {\n          if (i !== j) {\n            max = Math.max(max, this.manhattan(a, b));\n          }\n        });\n      });\n      this.solutions.partTwo = max;\n    },\n    manhattan: function (a, b) {\n      return a.map((v, i) => Math.abs(v - b[i])).reduce((a, b) => a + b, 0);\n    },\n    plus: function (a, b) {\n      return a.map((v, i) => v + b[i]);\n    },\n    minus: function (a, b) {\n      return a.map((v, i) => v - b[i]);\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2021/Day19.vue?vue&type=script&lang=js\n /* harmony default export */ const _2021_Day19vue_type_script_lang_js = (Day19vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2021/Day19.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2021_Day19vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "7f9fa6b0",\n  null\n  \n)\n\n/* harmony default export */ const Day19 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk5MjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxtQ0FBbUMsc0JBQXNCLDRCQUE0QixrQkFBa0IsT0FBTyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUc7QUFDclQ7Ozs7Ozs7Ozs7Ozs7OztBQ1FBOztBQUVBO0FBQ0E7RUFDQUE7SUFDQTtNQUNBO0lBQ0E7SUFDQTtFQUNBO0VBRUFDO0lBQ0E7SUFDQTtFQUNBO0FBQ0E7QUFFQSxvQkFDQSwwQkFDQSwyQkFDQSwyQkFDQSw0QkFDQSwyQkFDQSw0QkFDQSw0QkFDQSw2QkFDQSwwQkFDQSwyQkFDQSwyQkFDQSw0QkFDQSwyQkFDQSw0QkFDQSw0QkFDQSw2QkFDQSwwQkFDQSwyQkFDQSwyQkFDQSw0QkFDQSwyQkFDQSw0QkFDQSw0QkFDQSw2QkFDQSwwQkFDQSwyQkFDQSwyQkFDQSw0QkFDQSwyQkFDQSw0QkFDQSw0QkFDQSw2QkFDQSwwQkFDQSwyQkFDQSwyQkFDQSw0QkFDQSwyQkFDQSw0QkFDQSw0QkFDQSw2QkFDQSwwQkFDQSwyQkFDQSwyQkFDQSw0QkFDQSwyQkFDQSw0QkFDQSw0QkFDQSw0QkFDQTtBQUVBLG1FQUFlO0VBQ2ZDO0lBQ0FDLEdBQUFBLEVBQUFBLGtCQUFBQTtFQUNBO0VBQ0FDO0lBQ0E7TUFDQUM7UUFDQUM7UUFDQUM7TUFDQTtJQUNBO0VBQ0E7RUFDQUM7SUFDQUM7TUFDQTtNQUVBO01BQ0E7UUFDQTtVQUNBO1VBQ0FDO1VBQ0FDO1FBQ0E7VUFDQTtRQUFBLENBQ0E7VUFDQTtVQUNBQTtRQUNBO01BQ0E7O01BRUE7TUFDQUQ7O01BRUE7TUFDQTtRQUNBO01BQ0E7O01BRUE7TUFDQTs7TUFFQTtNQUNBRTtRQUNBO1FBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtZQUNBO1lBQ0E7Y0FDQTtjQUNBOztjQUVBO2NBQ0E7O2NBRUE7Y0FDQTtnQkFDQTtnQkFDQTtrQkFDQTtrQkFDQTtrQkFDQTtrQkFDQTs7a0JBRUE7a0JBQ0FDOztrQkFFQTtrQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQUM7b0JBQ0E7b0JBQ0FDO29CQUNBO29CQUNBO2tCQUNBO2dCQUNBO2NBQ0E7WUFDQTtVQUNBO1FBQ0E7TUFDQTtNQUVBO01BRUE7UUFDQUQ7TUFDQTtNQUVBO01BRUE7TUFFQTtNQUNBRTtRQUNBQTtVQUNBO1lBQ0FDO1VBQ0E7UUFDQTtNQUNBO01BRUE7SUFDQTtJQUNBQztNQUNBO0lBQ0E7SUFDQUM7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7SUFDQTtFQUNBO0FBQ0EsQ0FBQyxFOztBQ25NMlAsQ0FBQyx5RUFBZSw0QkFBRyxFQUFDLEM7Ozs7QUNBakw7QUFDdkM7QUFDTDs7O0FBR25EO0FBQ0EsQ0FBc0c7QUFDdEcsZ0JBQWdCLHNDQUFVO0FBQzFCLEVBQUUsa0NBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIxL0RheTE5LnZ1ZT9iYTg1Iiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlL3NyYy9jb21wb25lbnRzLzIwMjEvRGF5MTkudnVlPzVjYmIiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIxL0RheTE5LnZ1ZT9lMWQyIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxOS52dWU/YjQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnRGF5Jyx7YXR0cnM6e1wiZGF5XCI6MTksXCJ5ZWFyXCI6MjAyMSxcInNvbHV0aW9uc1wiOl92bS5zb2x1dGlvbnN9LG9uOntcImlucHV0LWNoYW5nZWRcIjpfdm0ub25JbnB1dENoYW5nZWR9LHNjb3BlZFNsb3RzOl92bS5fdShbe2tleTpcInBhcnRPbmVcIixmbjpmdW5jdGlvbigpe3JldHVybiBbX2MoJ2Rpdicse2F0dHJzOntcImlkXCI6XCJwYXJ0T25lXCJ9fSldfSxwcm94eTp0cnVlfV0pfSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPERheSA6ZGF5PVwiMTlcIiA6eWVhcj1cIjIwMjFcIiA6c29sdXRpb25zPVwic29sdXRpb25zXCIgQGlucHV0LWNoYW5nZWQ9XCJvbklucHV0Q2hhbmdlZFwiPlxuICAgIDx0ZW1wbGF0ZSB2LXNsb3Q6cGFydE9uZT5cbiAgICAgIDxkaXYgaWQ9XCJwYXJ0T25lXCIgLz5cbiAgICA8L3RlbXBsYXRlPlxuICA8L0RheT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgRGF5IGZyb20gJ0AvY29tcG9uZW50cy9EYXknXG5cbi8vIENyZWF0ZSBhIG1hcCB0aGF0LCBmb3IgbWlzc2luZyBrZXlzLCBzZXRzIHRoZW0gdG8gYSBkZWZhdWx0IHZhbHVlXG5jbGFzcyBNYXBXaXRoRGVmYXVsdCBleHRlbmRzIE1hcCB7XG4gIGdldCAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLnNldChrZXksIHRoaXMuZGVmYXVsdCgpKVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChkZWZhdWx0RnVuY3Rpb24sIGVudHJpZXMpIHtcbiAgICBzdXBlcihlbnRyaWVzKVxuICAgIHRoaXMuZGVmYXVsdCA9IGRlZmF1bHRGdW5jdGlvblxuICB9XG59XG5cbmNvbnN0IHRyYW5zZm9ybXMgPSBbXG4gIChbeCwgeSwgel0pID0+IFt4LCB5LCB6XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3gsIHksIC16XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3gsIC15LCB6XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3gsIC15LCAtel0sXG4gIChbeCwgeSwgel0pID0+IFsteCwgeSwgel0sXG4gIChbeCwgeSwgel0pID0+IFsteCwgeSwgLXpdLFxuICAoW3gsIHksIHpdKSA9PiBbLXgsIC15LCB6XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy14LCAteSwgLXpdLFxuICAoW3gsIHksIHpdKSA9PiBbeiwgeCwgeV0sXG4gIChbeCwgeSwgel0pID0+IFt6LCB4LCAteV0sXG4gIChbeCwgeSwgel0pID0+IFt6LCAteCwgeV0sXG4gIChbeCwgeSwgel0pID0+IFt6LCAteCwgLXldLFxuICAoW3gsIHksIHpdKSA9PiBbLXosIHgsIHldLFxuICAoW3gsIHksIHpdKSA9PiBbLXosIHgsIC15XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy16LCAteCwgeV0sXG4gIChbeCwgeSwgel0pID0+IFsteiwgLXgsIC15XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3ksIHosIHhdLFxuICAoW3gsIHksIHpdKSA9PiBbeSwgeiwgLXhdLFxuICAoW3gsIHksIHpdKSA9PiBbeSwgLXosIHhdLFxuICAoW3gsIHksIHpdKSA9PiBbeSwgLXosIC14XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy15LCB6LCB4XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy15LCB6LCAteF0sXG4gIChbeCwgeSwgel0pID0+IFsteSwgLXosIHhdLFxuICAoW3gsIHksIHpdKSA9PiBbLXksIC16LCAteF0sXG4gIChbeCwgeSwgel0pID0+IFt4LCB6LCB5XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3gsIHosIC15XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3gsIC16LCB5XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3gsIC16LCAteV0sXG4gIChbeCwgeSwgel0pID0+IFsteCwgeiwgeV0sXG4gIChbeCwgeSwgel0pID0+IFsteCwgeiwgLXldLFxuICAoW3gsIHksIHpdKSA9PiBbLXgsIC16LCB5XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy14LCAteiwgLXldLFxuICAoW3gsIHksIHpdKSA9PiBbeSwgeCwgel0sXG4gIChbeCwgeSwgel0pID0+IFt5LCB4LCAtel0sXG4gIChbeCwgeSwgel0pID0+IFt5LCAteCwgel0sXG4gIChbeCwgeSwgel0pID0+IFt5LCAteCwgLXpdLFxuICAoW3gsIHksIHpdKSA9PiBbLXksIHgsIHpdLFxuICAoW3gsIHksIHpdKSA9PiBbLXksIHgsIC16XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy15LCAteCwgel0sXG4gIChbeCwgeSwgel0pID0+IFsteSwgLXgsIC16XSxcbiAgKFt4LCB5LCB6XSkgPT4gW3osIHksIHhdLFxuICAoW3gsIHksIHpdKSA9PiBbeiwgeSwgLXhdLFxuICAoW3gsIHksIHpdKSA9PiBbeiwgLXksIHhdLFxuICAoW3gsIHksIHpdKSA9PiBbeiwgLXksIC14XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy16LCB5LCB4XSxcbiAgKFt4LCB5LCB6XSkgPT4gWy16LCB5LCAteF0sXG4gIChbeCwgeSwgel0pID0+IFsteiwgLXksIHhdLFxuICAoW3gsIHksIHpdKSA9PiBbLXosIC15LCAteF1cbl1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sdXRpb25zOiB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0Q2hhbmdlZDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBjb25zdCBzY2FubmVycyA9IFtdXG5cbiAgICAgIGxldCBjdXJyZW50U2Nhbm5lciA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnB1dFtpXS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgLy8gRW1wdHkgcm93LCBwdXNoIHRoZSBzY2FubmVyIGRhdGEgb250byB0aGUgYXJyYXlcbiAgICAgICAgICBzY2FubmVycy5wdXNoKGN1cnJlbnRTY2FubmVyKVxuICAgICAgICAgIGN1cnJlbnRTY2FubmVyID0gW11cbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFtpXS5zdGFydHNXaXRoKCctLS0nKSkge1xuICAgICAgICAgIC8vIFNraXAgaGVhZGVyIHJvd3NcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBZGQgdGhlIGJlYWNvbiBjb29yZGluYXRlc1xuICAgICAgICAgIGN1cnJlbnRTY2FubmVyLnB1c2goaW5wdXRbaV0uc3BsaXQoJywnKS5tYXAoYyA9PiArYykpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBsYXN0IHNjYW5uZXJcbiAgICAgIHNjYW5uZXJzLnB1c2goY3VycmVudFNjYW5uZXIpXG5cbiAgICAgIC8vIFN0YXJ0IGJ5IHNldHRpbmcgdGhlIGZpcnN0IHNjYW5uZXIgYXMgdGhlIG9yaWdpblxuICAgICAgY29uc3QgYWJzb2x1dGVDb29yZHMgPSB7XG4gICAgICAgICcwLDAsMCc6IHNjYW5uZXJzWzBdXG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdGhlIHJlc3QgYXMgdW5tYXBwZWRcbiAgICAgIGNvbnN0IHVubWFwcGVkID0gc2Nhbm5lcnMuc2xpY2UoMSlcblxuICAgICAgLy8gV2hpbGUgdGhlcmUgYXJlIHN0aWxsIHVubWFwcGVkIHNjYW5uZXJzXG4gICAgICByZXN0YXJ0OiB3aGlsZSAodW5tYXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIHRoZSBmaXhlZCBzY2FubmVyc1xuICAgICAgICBmb3IgKGNvbnN0IGFjIGluIGFic29sdXRlQ29vcmRzKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBmaXhlZCBzY2FubmVyIGJlYWNvbiBjb29yZGluYXRlc1xuICAgICAgICAgIGNvbnN0IGtub3duID0gYWJzb2x1dGVDb29yZHNbYWNdXG4gICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgdW5tYXBwZWQgc2Nhbm5lcnNcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVubWFwcGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGFsbCB0cmFuc2Zvcm1zXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybSBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgdW5tYXBwZWQgY29vcmRpbmF0ZXMgdXNpbmcgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlID0gdW5tYXBwZWRbaV0ubWFwKHRyYW5zZm9ybSlcblxuICAgICAgICAgICAgICAvLyBDb3VudCBoaXRzXG4gICAgICAgICAgICAgIGNvbnN0IGhpdHMgPSBuZXcgTWFwV2l0aERlZmF1bHQoKCkgPT4gMClcblxuICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBvZiB0aGUga25vd24gY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrbm93bi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgdG8gYWxsIG9mIHRoZSB1bm1hcHBlZCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcG9zc2libGUubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGVsdGFcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLm1pbnVzKGtub3duW2tdLCBwb3NzaWJsZVtwXSlcbiAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUga2V5XG4gICAgICAgICAgICAgICAgICBjb25zdCB2ayA9IHYuam9pbignLCcpXG5cbiAgICAgICAgICAgICAgICAgIC8vIENvdW50IGEgaGl0XG4gICAgICAgICAgICAgICAgICBoaXRzLnNldCh2aywgaGl0cy5nZXQodmspICsgMSlcblxuICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgZW5vdWdoIGhpdHNcbiAgICAgICAgICAgICAgICAgIGlmIChoaXRzLmdldCh2aykgPj0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBkZWx0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IHBvc3NpYmxlLm1hcChiID0+IHRoaXMucGx1cyh2LCBiKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIG1hcHBlZCBzY2FubmVyc1xuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUNvb3Jkc1t2a10gPSBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB1bm1hcHBlZFxuICAgICAgICAgICAgICAgICAgICB1bm1hcHBlZC5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgb3ZlclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSByZXN0YXJ0XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJlYWNvbnMgPSBuZXcgU2V0KClcblxuICAgICAgZm9yIChjb25zdCBhYyBpbiBhYnNvbHV0ZUNvb3Jkcykge1xuICAgICAgICBhYnNvbHV0ZUNvb3Jkc1thY10uZm9yRWFjaChjID0+IGJlYWNvbnMuYWRkKGMuam9pbignJykpKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gYmVhY29ucy5zaXplXG5cbiAgICAgIGNvbnN0IHNjYW5uZXJDb29yZHMgPSBPYmplY3Qua2V5cyhhYnNvbHV0ZUNvb3JkcykubWFwKHMgPT4gcy5zcGxpdCgnLCcpLm1hcChjID0+ICtjKSlcblxuICAgICAgbGV0IG1heCA9IDBcbiAgICAgIHNjYW5uZXJDb29yZHMuZm9yRWFjaCgoYSwgaSkgPT4ge1xuICAgICAgICBzY2FubmVyQ29vcmRzLmZvckVhY2goKGIsIGopID0+IHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB0aGlzLm1hbmhhdHRhbihhLCBiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gbWF4XG4gICAgfSxcbiAgICBtYW5oYXR0YW46IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5tYXAoKHYsIGkpID0+IE1hdGguYWJzKHYgLSBiW2ldKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgICB9LFxuICAgIHBsdXM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5tYXAoKHYsIGkpID0+IHYgKyBiW2ldKVxuICAgIH0sXG4gICAgbWludXM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5tYXAoKHYsIGkpID0+IHYgLSBiW2ldKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxOS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxOS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vRGF5MTkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTdmOWZhNmIwJnNjb3BlZD10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRGF5MTkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0RheTE5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI3ZjlmYTZiMFwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6WyJnZXQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudHMiLCJEYXkiLCJkYXRhIiwic29sdXRpb25zIiwicGFydE9uZSIsInBhcnRUd28iLCJtZXRob2RzIiwib25JbnB1dENoYW5nZWQiLCJzY2FubmVycyIsImN1cnJlbnRTY2FubmVyIiwicmVzdGFydCIsImhpdHMiLCJhYnNvbHV0ZUNvb3JkcyIsInVubWFwcGVkIiwic2Nhbm5lckNvb3JkcyIsIm1heCIsIm1hbmhhdHRhbiIsInBsdXMiLCJtaW51cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89928\n')}}]);