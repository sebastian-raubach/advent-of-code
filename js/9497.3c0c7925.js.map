{"version":3,"file":"js/9497.3c0c7925.js","mappings":"yKAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCOtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAP,eAAAA,SAAAA,GACA,mBACA,oBACA,mBACA,EACAQ,WAAAA,SAAAA,GACA,oBACA,sBACA,eAEA,QACA,2BAEA,cAMA,+BAKA,UACA,QAEA,yBAEA,qBAEA,wDACA,KACA,CACA,OAEA,4CACA,MACA,OAEA,sDACA,YA3BAC,GA8BA,EAMAC,cAAAA,SAAAA,GAEA,mGACA,EACAC,aAAAA,WAEA,oCAEA,sBAEA,SAOA,OANAC,OAAAA,KAAAA,KAAAA,QAAAA,SAAAA,IACA,6CACAC,GAAAA,EACA,KAGA,KAGA,mCAIA,6CACA,EACAC,aAAAA,WAEA,8DAGA,wCACA,gBAEA,OADAC,EAAAA,SAAAA,GAAAA,EAAAA,IAAAA,EAAAA,MACA,iBAIA,0CAEA,KAEA,kEAGA,kBAEA,mBACA,CACAC,MAAAA,EAEAC,QAAAA,OAAAA,KAAAA,GAAAA,QAAAA,GACA,wDAMAC,EAAAA,SAAAA,IAEA,uBAEAC,EAAAA,EAAAA,QAAAA,IAAAA,EAAAA,aAEA,gBAEAC,EAAAA,EAAAA,QAAAA,GAAAA,EAAAA,QAAAA,IACA,GAEA,CAGA,gIACA,IChJ6P,I,UCOzPC,GAAY,OACd,EACA/B,EACAW,GACA,EACA,KACA,KACA,MAIF,EAAeoB,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2020/Day16.vue?af95","webpack://advent-of-code/src/components/2020/Day16.vue","webpack://advent-of-code/./src/components/2020/Day16.vue?68c7","webpack://advent-of-code/./src/components/2020/Day16.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":16,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"16\" :year=\"2020\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.parseInput(input)\n      this.solvePartOne()\n      this.solvePartTwo()\n    },\n    parseInput: function (input) {\n      this.ourTicket = null\n      this.nearbyTickets = []\n      this.fields = {}\n\n      let part = 0\n      for (let i = 0; i < input.length; i++) {\n        // Empty rows indicate a new section\n        if (input[i] === '') {\n          part++\n          continue\n        }\n\n        // Skip ticket rows\n        if (input[i].indexOf('ticket') !== -1) {\n          continue\n        }\n\n        // Handle the row depending on which part we're in\n        switch (part) {\n          case 0: {\n            // Split the field and value\n            const parts = input[i].split(': ')\n            // Split the value ranges\n            const ranges = parts[1].split(' or ')\n            // Remember the field to range mapping\n            this.fields[parts[0]] = ranges.map(r => r.split('-').map(l => +l))\n            break\n          }\n          case 1:\n            // This is our ticket, just split it\n            this.ourTicket = input[i].split(',').map(n => +n)\n            break\n          case 2:\n            // These are other tickets, simply split them\n            this.nearbyTickets.push(input[i].split(',').map(n => +n))\n            break\n        }\n      }\n    },\n    /**\n     * Checks whether the given ticket is valid\n     * @param t The ticket to check\n     * @returns `true` if the ticket is valid, `false` otherwise\n     */\n    isTicketValid: function (t) {\n      // Check if for EVERY value, there exists SOME field that has a valid range this value falls into\n      return t.every(v => Object.keys(this.fields).some(f => this.fields[f].some(r => r[0] <= v && r[1] >= v)))\n    },\n    solvePartOne: function () {\n      // Map all tickets to the sum of their invalid values\n      const filtered = this.nearbyTickets.map(t => {\n        // Filter out all valid values\n        const innerFiltered = t.filter(v => {\n          // Check if there's a field that matches the value\n          let found = false\n          Object.keys(this.fields).forEach(f => {\n            if (this.fields[f].some(a => a[0] <= v && a[1] >= v)) {\n              found = true\n            }\n          })\n          // If there is a match, don't include this one\n          return !found\n        })\n        // Sum up all invalid values (PER TICKET)\n        return innerFiltered.reduce((a, b) => a + b, 0)\n      })\n\n      // Sum up all invalid values (ACROSS TICKETS)\n      this.solutions.partOne = filtered.reduce((a, b) => a + b)\n    },\n    solvePartTwo: function () {\n      // Remove invalid tickets\n      const validTickets = this.nearbyTickets.filter(t => this.isTicketValid(t))\n\n      // Get all distinct values for each position/field/column\n      const positionValues = Object.keys(this.fields).map((f, i) => {\n        const values = new Set()\n        validTickets.forEach(t => values.add(t[i]))\n        return Array.from(values)\n      })\n\n      // Create a copy of the fields, as we'll be deleting keys\n      const fieldCopy = JSON.parse(JSON.stringify(this.fields))\n      // Remember the mapping of field name to index\n      const fieldMapping = {}\n      // Get all position/field/column indices\n      let indices = Array.from(Array(Object.keys(fieldCopy).length).keys()).map(i => i)\n\n      // While there is an index that still hasn't been matched\n      while (indices.length > 0) {\n        // Map each index to the list of matching fields\n        const matchingFields = indices.map(i => {\n          return {\n            index: i,\n            // Filter the fields down to those where EVERY column value is in SOME of the ranges\n            matches: Object.keys(fieldCopy).filter(f => {\n              return positionValues[i].every(v => fieldCopy[f].some(a => a[0] <= v && a[1] >= v))\n            })\n          }\n        })\n\n        // Now, for each matching field\n        matchingFields.forEach(f => {\n          // If there is only one match, there's a unique mapping\n          if (f.matches.length === 1) {\n            // Remember the mapping\n            fieldMapping[f.matches[0]] = f.index\n            // Delete this field, so we won't consider it again\n            delete fieldCopy[f.matches[0]]\n            // And delete the column index, as we've mapped it\n            indices = indices.filter(j => f.index !== j)\n          }\n        })\n      }\n\n      // The solution is using all fields containing 'departure' and multiplying their values together\n      this.solutions.partTwo = Object.keys(fieldMapping).filter(k => k.includes('departure')).map(k => this.ourTicket[fieldMapping[k]]).reduce((a, b) => a * b, 1)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day16.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day16.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day16.vue?vue&type=template&id=1b4075ae\"\nimport script from \"./Day16.vue?vue&type=script&lang=js\"\nexport * from \"./Day16.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","methods","parseInput","part","isTicketValid","solvePartOne","Object","found","solvePartTwo","validTickets","index","matches","matchingFields","fieldMapping","indices","component"],"sourceRoot":""}