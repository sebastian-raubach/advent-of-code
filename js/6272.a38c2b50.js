"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[6272],{49098:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day18)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day18.vue?vue&type=template&id=4850715e&scoped=true\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":18,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(36100);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day18.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day18vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Start with the first\n      let current = input[0];\n      for (let i = 1; i < input.length; i++) {\n        // Then stepwise add the other onto it\n        current = this.add(current, input[i]);\n      }\n\n      // Convert to an array using the convenient JSON.parse\n      const arr = JSON.parse(current);\n      // Get the magnitude by traversing the tree\n      this.solutions.partOne = this.magnitude(arr);\n\n      // Find the maximum\n      let max = 0;\n      // Pairwise comparison of all pairs\n      for (let i = 0; i < input.length; i++) {\n        for (let j = 0; j < input.length; j++) {\n          // Skip same ones\n          if (i === j) {\n            continue;\n          }\n\n          // Calculate the magnitude\n          const result = this.magnitude(JSON.parse(this.add(input[i], input[j])));\n\n          // Update maximum\n          max = Math.max(max, result);\n        }\n      }\n      this.solutions.partTwo = max;\n    },\n    add: function (one, two) {\n      // Create the concatenated array\n      let current = `[${one},${two}]`;\n\n      // While we found something to compact\n      let compacting = false;\n      do {\n        // Explode first\n        let result = this.explode(current);\n        current = result[0];\n        compacting = result[1];\n\n        // If there was no explosion\n        if (!compacting) {\n          // Check for splits\n          result = this.split(current);\n          current = result[0];\n          compacting = result[1];\n        }\n      } while (compacting);\n\n      // Return the result of the addition\n      return current;\n    },\n    magnitude: function (current) {\n      if (isNaN(current)) {\n        // For internal nodes, it's 3 times left plus 2 times right\n        return 3 * this.magnitude(current[0]) + 2 * this.magnitude(current[1]);\n      } else {\n        // For leaf nodes, it's the value\n        return current;\n      }\n    },\n    split: function (current) {\n      const arr = current.split('');\n\n      // Find numbers that are larger or equal to 10\n      let start = null;\n      let end = null;\n      let isNumber = false;\n      // Go through the string from left to right\n      for (let i = 0; i < arr.length; i++) {\n        // If we find a number\n        if (!isNaN(arr[i])) {\n          isNumber = true;\n          if (start === null) {\n            // Set the start (left boundary)\n            start = i;\n            // Set an initial value for the end (right boundary)\n            end = Math.min(i + 1, arr.length - 1);\n          } else {\n            // Update the end (right boundary)\n            end = Math.min(i + 1, arr.length - 1);\n          }\n        } else {\n          isNumber = false;\n        }\n\n        // We got to the end\n        if (i === arr.length - 1) {\n          isNumber = false;\n        }\n\n        // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n        if (!isNumber && start !== null && end !== null) {\n          // Parse the number\n          const n = parseInt(current.substring(start, end));\n          if (n >= 10) {\n            // If it's too large, replace it with an array of floor and ceil\n            return [`${current.substring(0, start)}[${Math.floor(n / 2.0)},${Math.ceil(n / 2.0)}]${current.substring(end, current.length)}`, true];\n          } else {\n            // If it's too small, continue searching\n            start = null;\n            end = null;\n            isNumber = false;\n          }\n        }\n      }\n\n      // Indicate we didn't split\n      return [current, false];\n    },\n    explode: function (current) {\n      const arr = current.split('');\n\n      // Count the level by keeping track of opening and closing brackets\n      let openCount = 0;\n      for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === '[') {\n          openCount++;\n        }\n        if (arr[i] === ']') {\n          openCount--;\n        }\n\n        // We found one that's \"too deep\"\n        if (openCount > 4) {\n          // Get the end index\n          const endIndex = current.indexOf(']', i);\n          // Parse the number pair\n          const pair = current.substring(i + 1, endIndex).split(',').map(c => +c);\n          // Get the left and the right substrings for later\n          let left = current.substring(0, i);\n          let right = current.substring(endIndex + 1);\n\n          // Go from the found index towards the left to find the first number and increase it\n          let start = null;\n          let end = null;\n          let isNumber = false;\n          const leftArr = left.split('');\n          for (let l = leftArr.length - 1; l >= 0; l--) {\n            if (!isNaN(leftArr[l])) {\n              isNumber = true;\n              if (end === null) {\n                // We found the right border\n                end = l;\n                // Initialise the left border\n                start = Math.max(0, l - 1);\n              } else {\n                // Update the left border\n                start = Math.max(0, l - 1);\n              }\n            } else {\n              isNumber = false;\n            }\n            if (l === 0) {\n              isNumber = false;\n            }\n\n            // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n            if (!isNumber && start !== null && end !== null) {\n              // Update the left side by increasing the number value\n              left = `${left.substring(0, start + 1)}${parseInt(left.substring(start + 1, end + 1)) + pair[0]}${left.substring(end + 1, left.length)}`;\n              break;\n            }\n          }\n          start = null;\n          end = null;\n          isNumber = false;\n          const rightArr = right.split('');\n          for (let r = 0; r < rightArr.length; r++) {\n            if (!isNaN(rightArr[r])) {\n              isNumber = true;\n              if (start === null) {\n                // We found the left border\n                start = r;\n                // Initialise the left border\n                end = Math.min(rightArr.length - 1, r + 1);\n              } else {\n                // Update the left border\n                end = Math.min(rightArr.length - 1, r + 1);\n              }\n            } else {\n              isNumber = false;\n            }\n            if (r === rightArr.length - 1) {\n              isNumber = false;\n            }\n\n            // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n            if (!isNumber && start !== null && end !== null) {\n              // Update the right side by increasing the number value\n              right = `${right.substring(0, start)}${parseInt(right.substring(start, end)) + pair[1]}${right.substring(end, right.length)}`;\n              break;\n            }\n          }\n\n          // Reconstitute the whole string by setting a zero in the middle\n          current = `${left}0${right}`;\n\n          // Indicate we exploded\n          return [current, true];\n        }\n      }\n\n      // Indicate we didn't explode\n      return [current, false];\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2021/Day18.vue?vue&type=script&lang=js\n /* harmony default export */ const _2021_Day18vue_type_script_lang_js = (Day18vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2021/Day18.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2021_Day18vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"4850715e\",\n  null\n  \n)\n\n/* harmony default export */ const Day18 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkwOTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxvQ0FBb0M7QUFDek07Ozs7Ozs7Ozs7OztBQ0tBO0FBRUEsbUVBQWU7RUFDZkE7SUFDQUMsR0FBQUEsRUFBQUEsa0JBQUFBO0VBQ0E7RUFDQUM7SUFDQTtNQUNBQztRQUNBQztRQUNBQztNQUNBO0lBQ0E7RUFDQTtFQUNBQztJQUNBQztNQUNBO01BQ0E7TUFDQTtRQUNBO1FBQ0FDO01BQ0E7O01BRUE7TUFDQTtNQUNBO01BQ0E7O01BRUE7TUFDQTtNQUNBO01BQ0E7UUFDQTtVQUNBO1VBQ0E7WUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQUM7UUFDQTtNQUNBO01BRUE7SUFDQTtJQUNBQztNQUNBO01BQ0E7O01BRUE7TUFDQTtNQUNBO1FBQ0E7UUFDQTtRQUNBRjtRQUNBRzs7UUFFQTtRQUNBO1VBQ0E7VUFDQUM7VUFDQUo7VUFDQUc7UUFDQTtNQUNBOztNQUVBO01BQ0E7SUFDQTtJQUNBRTtNQUNBO1FBQ0E7UUFDQTtNQUNBO1FBQ0E7UUFDQTtNQUNBO0lBQ0E7SUFDQUM7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7UUFDQTtRQUNBO1VBQ0FDO1VBQ0E7WUFDQTtZQUNBQztZQUNBO1lBQ0FDO1VBQ0E7WUFDQTtZQUNBQTtVQUNBO1FBQ0E7VUFDQUY7UUFDQTs7UUFFQTtRQUNBO1VBQ0FBO1FBQ0E7O1FBRUE7UUFDQTtVQUNBO1VBQ0E7VUFFQTtZQUNBO1lBQ0E7VUFDQTtZQUNBO1lBQ0FDO1lBQ0FDO1lBQ0FGO1VBQ0E7UUFDQTtNQUNBOztNQUVBO01BQ0E7SUFDQTtJQUNBRztNQUNBOztNQUVBO01BQ0E7TUFDQTtRQUNBO1VBQ0FDO1FBQ0E7UUFDQTtVQUNBQTtRQUNBOztRQUVBO1FBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7WUFDQTtjQUNBSjtjQUNBO2dCQUNBO2dCQUNBRTtnQkFDQTtnQkFDQUQ7Y0FDQTtnQkFDQTtnQkFDQUE7Y0FDQTtZQUNBO2NBQ0FEO1lBQ0E7WUFFQTtjQUNBQTtZQUNBOztZQUVBO1lBQ0E7Y0FDQTtjQUNBSztjQUNBO1lBQ0E7VUFDQTtVQUVBSjtVQUNBQztVQUNBRjtVQUNBO1VBQ0E7WUFDQTtjQUNBQTtjQUNBO2dCQUNBO2dCQUNBQztnQkFDQTtnQkFDQUM7Y0FDQTtnQkFDQTtnQkFDQUE7Y0FDQTtZQUNBO2NBQ0FGO1lBQ0E7WUFFQTtjQUNBQTtZQUNBOztZQUVBO1lBQ0E7Y0FDQTtjQUNBTTtjQUNBO1lBQ0E7VUFDQTs7VUFFQTtVQUNBYjs7VUFFQTtVQUNBO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO0lBQ0E7RUFDQTtBQUNBLENBQUMsRTs7QUM3TzJQLENBQUMseUVBQWUsNEJBQUcsRUFBQyxDOzs7O0FDQWpMO0FBQ3ZDO0FBQ0w7OztBQUduRDtBQUNBLENBQXNHO0FBQ3RHLGdCQUFnQixzQ0FBVTtBQUMxQixFQUFFLGtDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxOC52dWU/YzUzZiIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS9zcmMvY29tcG9uZW50cy8yMDIxL0RheTE4LnZ1ZT9mZmQ1Iiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxOC52dWU/MDcyNyIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjEvRGF5MTgudnVlPzRmZTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ0RheScse2F0dHJzOntcImRheVwiOjE4LFwieWVhclwiOjIwMjEsXCJzb2x1dGlvbnNcIjpfdm0uc29sdXRpb25zfSxvbjp7XCJpbnB1dC1jaGFuZ2VkXCI6X3ZtLm9uSW5wdXRDaGFuZ2VkfX0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxEYXkgOmRheT1cIjE4XCIgOnllYXI9XCIyMDIxXCIgOnNvbHV0aW9ucz1cInNvbHV0aW9uc1wiIEBpbnB1dC1jaGFuZ2VkPVwib25JbnB1dENoYW5nZWRcIj5cbiAgPC9EYXk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IERheSBmcm9tICdAL2NvbXBvbmVudHMvRGF5J1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBEYXlcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb2x1dGlvbnM6IHtcbiAgICAgICAgcGFydE9uZTogbnVsbCxcbiAgICAgICAgcGFydFR3bzogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uSW5wdXRDaGFuZ2VkOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIGZpcnN0XG4gICAgICBsZXQgY3VycmVudCA9IGlucHV0WzBdXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFRoZW4gc3RlcHdpc2UgYWRkIHRoZSBvdGhlciBvbnRvIGl0XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmFkZChjdXJyZW50LCBpbnB1dFtpXSlcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCB0byBhbiBhcnJheSB1c2luZyB0aGUgY29udmVuaWVudCBKU09OLnBhcnNlXG4gICAgICBjb25zdCBhcnIgPSBKU09OLnBhcnNlKGN1cnJlbnQpXG4gICAgICAvLyBHZXQgdGhlIG1hZ25pdHVkZSBieSB0cmF2ZXJzaW5nIHRoZSB0cmVlXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gdGhpcy5tYWduaXR1ZGUoYXJyKVxuXG4gICAgICAvLyBGaW5kIHRoZSBtYXhpbXVtXG4gICAgICBsZXQgbWF4ID0gMFxuICAgICAgLy8gUGFpcndpc2UgY29tcGFyaXNvbiBvZiBhbGwgcGFpcnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbnB1dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIC8vIFNraXAgc2FtZSBvbmVzXG4gICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtYWduaXR1ZGVcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm1hZ25pdHVkZShKU09OLnBhcnNlKHRoaXMuYWRkKGlucHV0W2ldLCBpbnB1dFtqXSkpKVxuXG4gICAgICAgICAgLy8gVXBkYXRlIG1heGltdW1cbiAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJlc3VsdClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gbWF4XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIChvbmUsIHR3bykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBjb25jYXRlbmF0ZWQgYXJyYXlcbiAgICAgIGxldCBjdXJyZW50ID0gYFske29uZX0sJHt0d299XWBcblxuICAgICAgLy8gV2hpbGUgd2UgZm91bmQgc29tZXRoaW5nIHRvIGNvbXBhY3RcbiAgICAgIGxldCBjb21wYWN0aW5nID0gZmFsc2VcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gRXhwbG9kZSBmaXJzdFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5leHBsb2RlKGN1cnJlbnQpXG4gICAgICAgIGN1cnJlbnQgPSByZXN1bHRbMF1cbiAgICAgICAgY29tcGFjdGluZyA9IHJlc3VsdFsxXVxuXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBleHBsb3Npb25cbiAgICAgICAgaWYgKCFjb21wYWN0aW5nKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHNwbGl0c1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc3BsaXQoY3VycmVudClcbiAgICAgICAgICBjdXJyZW50ID0gcmVzdWx0WzBdXG4gICAgICAgICAgY29tcGFjdGluZyA9IHJlc3VsdFsxXVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChjb21wYWN0aW5nKVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb25cbiAgICAgIHJldHVybiBjdXJyZW50XG4gICAgfSxcbiAgICBtYWduaXR1ZGU6IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICBpZiAoaXNOYU4oY3VycmVudCkpIHtcbiAgICAgICAgLy8gRm9yIGludGVybmFsIG5vZGVzLCBpdCdzIDMgdGltZXMgbGVmdCBwbHVzIDIgdGltZXMgcmlnaHRcbiAgICAgICAgcmV0dXJuIDMgKiB0aGlzLm1hZ25pdHVkZShjdXJyZW50WzBdKSArIDIgKiB0aGlzLm1hZ25pdHVkZShjdXJyZW50WzFdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIGxlYWYgbm9kZXMsIGl0J3MgdGhlIHZhbHVlXG4gICAgICAgIHJldHVybiBjdXJyZW50XG4gICAgICB9XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGFyciA9IGN1cnJlbnQuc3BsaXQoJycpXG5cbiAgICAgIC8vIEZpbmQgbnVtYmVycyB0aGF0IGFyZSBsYXJnZXIgb3IgZXF1YWwgdG8gMTBcbiAgICAgIGxldCBzdGFydCA9IG51bGxcbiAgICAgIGxldCBlbmQgPSBudWxsXG4gICAgICBsZXQgaXNOdW1iZXIgPSBmYWxzZVxuICAgICAgLy8gR28gdGhyb3VnaCB0aGUgc3RyaW5nIGZyb20gbGVmdCB0byByaWdodFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gSWYgd2UgZmluZCBhIG51bWJlclxuICAgICAgICBpZiAoIWlzTmFOKGFycltpXSkpIHtcbiAgICAgICAgICBpc051bWJlciA9IHRydWVcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgc3RhcnQgKGxlZnQgYm91bmRhcnkpXG4gICAgICAgICAgICBzdGFydCA9IGlcbiAgICAgICAgICAgIC8vIFNldCBhbiBpbml0aWFsIHZhbHVlIGZvciB0aGUgZW5kIChyaWdodCBib3VuZGFyeSlcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGkgKyAxLCBhcnIubGVuZ3RoIC0gMSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlbmQgKHJpZ2h0IGJvdW5kYXJ5KVxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oaSArIDEsIGFyci5sZW5ndGggLSAxKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBnb3QgdG8gdGhlIGVuZFxuICAgICAgICBpZiAoaSA9PT0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSdyZSBubyBsb25nZXIgaW4gdGhlIHByb2Nlc3Mgb2YgcGFyc2luZyBhIG11bHRpLWRpZ2l0IG51bWJlciBhbmQgd2UgZm91bmQgYSBzdGFydCBhbmQgYW4gZW5kXG4gICAgICAgIGlmICghaXNOdW1iZXIgJiYgc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUGFyc2UgdGhlIG51bWJlclxuICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUludChjdXJyZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKSlcblxuICAgICAgICAgIGlmIChuID49IDEwKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHRvbyBsYXJnZSwgcmVwbGFjZSBpdCB3aXRoIGFuIGFycmF5IG9mIGZsb29yIGFuZCBjZWlsXG4gICAgICAgICAgICByZXR1cm4gW2Ake2N1cnJlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0KX1bJHtNYXRoLmZsb29yKG4gLyAyLjApfSwke01hdGguY2VpbChuIC8gMi4wKX1dJHtjdXJyZW50LnN1YnN0cmluZyhlbmQsIGN1cnJlbnQubGVuZ3RoKX1gLCB0cnVlXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHRvbyBzbWFsbCwgY29udGludWUgc2VhcmNoaW5nXG4gICAgICAgICAgICBzdGFydCA9IG51bGxcbiAgICAgICAgICAgIGVuZCA9IG51bGxcbiAgICAgICAgICAgIGlzTnVtYmVyID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5kaWNhdGUgd2UgZGlkbid0IHNwbGl0XG4gICAgICByZXR1cm4gW2N1cnJlbnQsIGZhbHNlXVxuICAgIH0sXG4gICAgZXhwbG9kZTogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGFyciA9IGN1cnJlbnQuc3BsaXQoJycpXG5cbiAgICAgIC8vIENvdW50IHRoZSBsZXZlbCBieSBrZWVwaW5nIHRyYWNrIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgYnJhY2tldHNcbiAgICAgIGxldCBvcGVuQ291bnQgPSAwXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSAnWycpIHtcbiAgICAgICAgICBvcGVuQ291bnQrK1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJbaV0gPT09ICddJykge1xuICAgICAgICAgIG9wZW5Db3VudC0tXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBmb3VuZCBvbmUgdGhhdCdzIFwidG9vIGRlZXBcIlxuICAgICAgICBpZiAob3BlbkNvdW50ID4gNCkge1xuICAgICAgICAgIC8vIEdldCB0aGUgZW5kIGluZGV4XG4gICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjdXJyZW50LmluZGV4T2YoJ10nLCBpKVxuICAgICAgICAgIC8vIFBhcnNlIHRoZSBudW1iZXIgcGFpclxuICAgICAgICAgIGNvbnN0IHBhaXIgPSBjdXJyZW50LnN1YnN0cmluZyhpICsgMSwgZW5kSW5kZXgpLnNwbGl0KCcsJykubWFwKGMgPT4gK2MpXG4gICAgICAgICAgLy8gR2V0IHRoZSBsZWZ0IGFuZCB0aGUgcmlnaHQgc3Vic3RyaW5ncyBmb3IgbGF0ZXJcbiAgICAgICAgICBsZXQgbGVmdCA9IGN1cnJlbnQuc3Vic3RyaW5nKDAsIGkpXG4gICAgICAgICAgbGV0IHJpZ2h0ID0gY3VycmVudC5zdWJzdHJpbmcoZW5kSW5kZXggKyAxKVxuXG4gICAgICAgICAgLy8gR28gZnJvbSB0aGUgZm91bmQgaW5kZXggdG93YXJkcyB0aGUgbGVmdCB0byBmaW5kIHRoZSBmaXJzdCBudW1iZXIgYW5kIGluY3JlYXNlIGl0XG4gICAgICAgICAgbGV0IHN0YXJ0ID0gbnVsbFxuICAgICAgICAgIGxldCBlbmQgPSBudWxsXG4gICAgICAgICAgbGV0IGlzTnVtYmVyID0gZmFsc2VcbiAgICAgICAgICBjb25zdCBsZWZ0QXJyID0gbGVmdC5zcGxpdCgnJylcbiAgICAgICAgICBmb3IgKGxldCBsID0gbGVmdEFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICAgICAgaWYgKCFpc05hTihsZWZ0QXJyW2xdKSkge1xuICAgICAgICAgICAgICBpc051bWJlciA9IHRydWVcbiAgICAgICAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHRoZSByaWdodCBib3JkZXJcbiAgICAgICAgICAgICAgICBlbmQgPSBsXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgbGVmdCBib3JkZXJcbiAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGwgLSAxKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVmdCBib3JkZXJcbiAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGwgLSAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgICAgICAgIGlzTnVtYmVyID0gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm8gbG9uZ2VyIGluIHRoZSBwcm9jZXNzIG9mIHBhcnNpbmcgYSBtdWx0aS1kaWdpdCBudW1iZXIgYW5kIHdlIGZvdW5kIGEgc3RhcnQgYW5kIGFuIGVuZFxuICAgICAgICAgICAgaWYgKCFpc051bWJlciAmJiBzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsZWZ0IHNpZGUgYnkgaW5jcmVhc2luZyB0aGUgbnVtYmVyIHZhbHVlXG4gICAgICAgICAgICAgIGxlZnQgPSBgJHtsZWZ0LnN1YnN0cmluZygwLCBzdGFydCArIDEpfSR7cGFyc2VJbnQobGVmdC5zdWJzdHJpbmcoc3RhcnQgKyAxLCBlbmQgKyAxKSkgKyBwYWlyWzBdfSR7bGVmdC5zdWJzdHJpbmcoZW5kICsgMSwgbGVmdC5sZW5ndGgpfWBcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFydCA9IG51bGxcbiAgICAgICAgICBlbmQgPSBudWxsXG4gICAgICAgICAgaXNOdW1iZXIgPSBmYWxzZVxuICAgICAgICAgIGNvbnN0IHJpZ2h0QXJyID0gcmlnaHQuc3BsaXQoJycpXG4gICAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByaWdodEFyci5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgaWYgKCFpc05hTihyaWdodEFycltyXSkpIHtcbiAgICAgICAgICAgICAgaXNOdW1iZXIgPSB0cnVlXG4gICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHRoZSBsZWZ0IGJvcmRlclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gclxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIGxlZnQgYm9yZGVyXG4gICAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4ocmlnaHRBcnIubGVuZ3RoIC0gMSwgciArIDEpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsZWZ0IGJvcmRlclxuICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKHJpZ2h0QXJyLmxlbmd0aCAtIDEsIHIgKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyID09PSByaWdodEFyci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGlzTnVtYmVyID0gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm8gbG9uZ2VyIGluIHRoZSBwcm9jZXNzIG9mIHBhcnNpbmcgYSBtdWx0aS1kaWdpdCBudW1iZXIgYW5kIHdlIGZvdW5kIGEgc3RhcnQgYW5kIGFuIGVuZFxuICAgICAgICAgICAgaWYgKCFpc051bWJlciAmJiBzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByaWdodCBzaWRlIGJ5IGluY3JlYXNpbmcgdGhlIG51bWJlciB2YWx1ZVxuICAgICAgICAgICAgICByaWdodCA9IGAke3JpZ2h0LnN1YnN0cmluZygwLCBzdGFydCl9JHtwYXJzZUludChyaWdodC5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpICsgcGFpclsxXX0ke3JpZ2h0LnN1YnN0cmluZyhlbmQsIHJpZ2h0Lmxlbmd0aCl9YFxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlY29uc3RpdHV0ZSB0aGUgd2hvbGUgc3RyaW5nIGJ5IHNldHRpbmcgYSB6ZXJvIGluIHRoZSBtaWRkbGVcbiAgICAgICAgICBjdXJyZW50ID0gYCR7bGVmdH0wJHtyaWdodH1gXG5cbiAgICAgICAgICAvLyBJbmRpY2F0ZSB3ZSBleHBsb2RlZFxuICAgICAgICAgIHJldHVybiBbY3VycmVudCwgdHJ1ZV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbmRpY2F0ZSB3ZSBkaWRuJ3QgZXhwbG9kZVxuICAgICAgcmV0dXJuIFtjdXJyZW50LCBmYWxzZV1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuPC9zdHlsZT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNDAudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MTgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNDAudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MTgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0RheTE4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00ODUwNzE1ZSZzY29wZWQ9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0RheTE4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9EYXkxOC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNDg1MDcxNWVcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOlsiY29tcG9uZW50cyIsIkRheSIsImRhdGEiLCJzb2x1dGlvbnMiLCJwYXJ0T25lIiwicGFydFR3byIsIm1ldGhvZHMiLCJvbklucHV0Q2hhbmdlZCIsImN1cnJlbnQiLCJtYXgiLCJhZGQiLCJjb21wYWN0aW5nIiwicmVzdWx0IiwibWFnbml0dWRlIiwic3BsaXQiLCJpc051bWJlciIsInN0YXJ0IiwiZW5kIiwiZXhwbG9kZSIsIm9wZW5Db3VudCIsImxlZnQiLCJyaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///49098\n")}}]);