{"version":3,"file":"js/4730.1231ac84.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,gBAAgBC,YAAYV,EAAIW,GAAG,CAAC,CAACC,IAAI,UAAUC,GAAG,WAAW,MAAO,CAACT,EAAG,MAAM,CAACE,MAAM,CAAC,GAAK,aAAa,EAAEQ,OAAM,MAAS,EAClTC,EAAkB,G,WCWtB,MAAMC,UAAuBC,IAC7BC,GAAAA,CAAAA,GAIA,OAHA,aACA,2BAEA,YACA,CAEAC,WAAAA,CAAAA,EAAAA,GACA,SACA,cACA,EAGA,MAAMC,EAAa,CACnB,mBACA,oBACA,oBACA,qBACA,oBACA,qBACA,qBACA,sBACA,mBACA,oBACA,oBACA,qBACA,oBACA,qBACA,qBACA,sBACA,mBACA,oBACA,oBACA,qBACA,oBACA,qBACA,qBACA,sBACA,mBACA,oBACA,oBACA,qBACA,oBACA,qBACA,qBACA,sBACA,mBACA,oBACA,oBACA,qBACA,oBACA,qBACA,qBACA,sBACA,mBACA,oBACA,oBACA,qBACA,oBACA,qBACA,qBACA,uBAGA,OACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAhB,UAAAA,CACAiB,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAjB,eAAAA,SAAAA,GACA,WAEA,SACA,2BACA,eAEAkB,EAAAA,KAAAA,GACAC,EAAAA,IACA,wBAIAA,EAAAA,KAAAA,EAAAA,GAAAA,MAAAA,KAAAA,KAAAA,IAAAA,KAKAD,EAAAA,KAAAA,GAGA,SACA,cAIA,aAGAE,EAAAA,MAAAA,EAAAA,OAAAA,EAEA,kBAEA,aAEA,2BAEA,kBAEA,oBAGA,iBAGA,2BAEA,4BAEA,8BAEA,cAMA,GAHAC,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,GAAAA,GAGA,cAEA,mCAEAC,EAAAA,GAAAA,EAEAC,EAAAA,OAAAA,EAAAA,GAEA,UACA,CACA,CAEA,CAEA,CAGA,gBAEA,iBACAD,EAAAA,GAAAA,SAAAA,GAAAA,EAAAA,IAAAA,EAAAA,KAAAA,OAGA,8BAEA,2DAEA,QACAE,EAAAA,SAAAA,CAAAA,EAAAA,KACAA,EAAAA,SAAAA,CAAAA,EAAAA,KACA,QACAC,EAAAA,KAAAA,IAAAA,EAAAA,KAAAA,UAAAA,EAAAA,IACA,GACA,IAGA,wBACA,EACAC,UAAAA,SAAAA,EAAAA,GACA,8DACA,EACAC,KAAAA,SAAAA,EAAAA,GACA,6BACA,EACAC,MAAAA,SAAAA,EAAAA,GACA,6BACA,ICjM6P,I,UCOzPC,GAAY,OACd,EACAvC,EACAgB,GACA,EACA,KACA,WACA,MAIF,EAAeuB,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2021/Day19.vue?ba85","webpack://advent-of-code/src/components/2021/Day19.vue","webpack://advent-of-code/./src/components/2021/Day19.vue?e1d2","webpack://advent-of-code/./src/components/2021/Day19.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":19,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{attrs:{\"id\":\"partOne\"}})]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"19\" :year=\"2021\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partOne>\n      <div id=\"partOne\" />\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\n// Create a map that, for missing keys, sets them to a default value\nclass MapWithDefault extends Map {\n  get (key) {\n    if (!this.has(key)) {\n      this.set(key, this.default())\n    }\n    return super.get(key)\n  }\n\n  constructor (defaultFunction, entries) {\n    super(entries)\n    this.default = defaultFunction\n  }\n}\n\nconst transforms = [\n  ([x, y, z]) => [x, y, z],\n  ([x, y, z]) => [x, y, -z],\n  ([x, y, z]) => [x, -y, z],\n  ([x, y, z]) => [x, -y, -z],\n  ([x, y, z]) => [-x, y, z],\n  ([x, y, z]) => [-x, y, -z],\n  ([x, y, z]) => [-x, -y, z],\n  ([x, y, z]) => [-x, -y, -z],\n  ([x, y, z]) => [z, x, y],\n  ([x, y, z]) => [z, x, -y],\n  ([x, y, z]) => [z, -x, y],\n  ([x, y, z]) => [z, -x, -y],\n  ([x, y, z]) => [-z, x, y],\n  ([x, y, z]) => [-z, x, -y],\n  ([x, y, z]) => [-z, -x, y],\n  ([x, y, z]) => [-z, -x, -y],\n  ([x, y, z]) => [y, z, x],\n  ([x, y, z]) => [y, z, -x],\n  ([x, y, z]) => [y, -z, x],\n  ([x, y, z]) => [y, -z, -x],\n  ([x, y, z]) => [-y, z, x],\n  ([x, y, z]) => [-y, z, -x],\n  ([x, y, z]) => [-y, -z, x],\n  ([x, y, z]) => [-y, -z, -x],\n  ([x, y, z]) => [x, z, y],\n  ([x, y, z]) => [x, z, -y],\n  ([x, y, z]) => [x, -z, y],\n  ([x, y, z]) => [x, -z, -y],\n  ([x, y, z]) => [-x, z, y],\n  ([x, y, z]) => [-x, z, -y],\n  ([x, y, z]) => [-x, -z, y],\n  ([x, y, z]) => [-x, -z, -y],\n  ([x, y, z]) => [y, x, z],\n  ([x, y, z]) => [y, x, -z],\n  ([x, y, z]) => [y, -x, z],\n  ([x, y, z]) => [y, -x, -z],\n  ([x, y, z]) => [-y, x, z],\n  ([x, y, z]) => [-y, x, -z],\n  ([x, y, z]) => [-y, -x, z],\n  ([x, y, z]) => [-y, -x, -z],\n  ([x, y, z]) => [z, y, x],\n  ([x, y, z]) => [z, y, -x],\n  ([x, y, z]) => [z, -y, x],\n  ([x, y, z]) => [z, -y, -x],\n  ([x, y, z]) => [-z, y, x],\n  ([x, y, z]) => [-z, y, -x],\n  ([x, y, z]) => [-z, -y, x],\n  ([x, y, z]) => [-z, -y, -x]\n]\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const scanners = []\n\n      let currentScanner = []\n      for (let i = 0; i < input.length; i++) {\n        if (input[i].length < 1) {\n          // Empty row, push the scanner data onto the array\n          scanners.push(currentScanner)\n          currentScanner = []\n        } else if (input[i].startsWith('---')) {\n          // Skip header rows\n        } else {\n          // Add the beacon coordinates\n          currentScanner.push(input[i].split(',').map(c => +c))\n        }\n      }\n\n      // Add the last scanner\n      scanners.push(currentScanner)\n\n      // Start by setting the first scanner as the origin\n      const absoluteCoords = {\n        '0,0,0': scanners[0]\n      }\n\n      // Keep the rest as unmapped\n      const unmapped = scanners.slice(1)\n\n      // While there are still unmapped scanners\n      restart: while (unmapped.length > 0) {\n        // Iterate through all the fixed scanners\n        for (const ac in absoluteCoords) {\n          // Get the fixed scanner beacon coordinates\n          const known = absoluteCoords[ac]\n          // Go through the unmapped scanners\n          for (let i = 0; i < unmapped.length; i++) {\n            // Go through all transforms\n            for (const transform of transforms) {\n              // Transform the unmapped coordinates using the current transform\n              const possible = unmapped[i].map(transform)\n\n              // Count hits\n              const hits = new MapWithDefault(() => 0)\n\n              // For each of the known coordinates\n              for (let k = 0; k < known.length; k++) {\n                // Compare to all of the unmapped coordinates\n                for (let p = 0; p < possible.length; p++) {\n                  // Get the delta\n                  const v = this.minus(known[k], possible[p])\n                  // Create the key\n                  const vk = v.join(',')\n\n                  // Count a hit\n                  hits.set(vk, hits.get(vk) + 1)\n\n                  // If we found enough hits\n                  if (hits.get(vk) >= 12) {\n                    // Add the delta\n                    const found = possible.map(b => this.plus(v, b))\n                    // Add to mapped scanners\n                    absoluteCoords[vk] = found\n                    // Remove from unmapped\n                    unmapped.splice(i, 1)\n                    // Start over\n                    continue restart\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      const beacons = new Set()\n\n      for (const ac in absoluteCoords) {\n        absoluteCoords[ac].forEach(c => beacons.add(c.join('')))\n      }\n\n      this.solutions.partOne = beacons.size\n\n      const scannerCoords = Object.keys(absoluteCoords).map(s => s.split(',').map(c => +c))\n\n      let max = 0\n      scannerCoords.forEach((a, i) => {\n        scannerCoords.forEach((b, j) => {\n          if (i !== j) {\n            max = Math.max(max, this.manhattan(a, b))\n          }\n        })\n      })\n\n      this.solutions.partTwo = max\n    },\n    manhattan: function (a, b) {\n      return a.map((v, i) => Math.abs(v - b[i])).reduce((a, b) => a + b, 0)\n    },\n    plus: function (a, b) {\n      return a.map((v, i) => v + b[i])\n    },\n    minus: function (a, b) {\n      return a.map((v, i) => v - b[i])\n    }\n  }\n}\n</script>\n\n<style scoped>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day19.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day19.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day19.vue?vue&type=template&id=7f9fa6b0&scoped=true\"\nimport script from \"./Day19.vue?vue&type=script&lang=js\"\nexport * from \"./Day19.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"7f9fa6b0\",\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","proxy","staticRenderFns","MapWithDefault","Map","get","constructor","transforms","components","Day","data","partOne","partTwo","methods","scanners","currentScanner","restart","hits","absoluteCoords","unmapped","scannerCoords","max","manhattan","plus","minus","component"],"sourceRoot":""}