{"version":3,"file":"js/5226.e8c95ce4.js","mappings":"+GAAA,MAAM,QAAEA,GAAY,EAAQ,QACtB,QAAEC,GAAY,EAAQ,QACtB,WAAEC,GAAe,EAAQ,OAE/BC,EAAQH,QAAUA,EAClBG,EAAQF,QAAUA,EAClBE,EAAQD,WAAaA,C;;;;;ACDrB,MAAM,KAAEE,GAAS,EAAQ,OAMzB,MAAMF,UAAmBE,EACvB,WAAAC,CAAYC,EAAYC,EAAOC,GAC7B,GAA0B,oBAAfF,EACT,MAAM,IAAIG,MAAM,4CAElBC,MAAMH,EAAOC,GACbG,KAAKC,YAAcN,CACrB,CAWA,QAAAO,CAASC,EAAYC,GACnB,OAAOJ,KAAKC,YAAYE,EAAYC,IAAc,CACpD,CAUA,sBAAAC,CAAuBC,EAAOC,EAAgBC,GAC5C,MAAMC,EAAUT,KAAKC,YACnBD,KAAKU,OAAOF,GACZR,KAAKU,OAAOH,IAGd,OAAIE,GAAW,GAAKD,EAAkBF,EAC7BE,EAGFD,CACT,CAOA,KAAAI,GACE,OAAO,IAAIpB,EACTS,KAAKC,YACLD,KAAKU,OAAOE,QACZZ,KAAKa,MAET,CAUA,cAAOC,CAAQC,EAAMpB,GACnB,IAAKqB,MAAMC,QAAQF,GACjB,MAAM,IAAIjB,MAAM,6BAGlB,GAA0B,oBAAfH,EACT,MAAM,IAAIG,MAAM,0CAGlB,OAAO,IAAIP,EAAWI,EAAYoB,GAAMG,KAC1C,CAUA,kBAAOC,CAAYJ,EAAMpB,GACvB,IAAKqB,MAAMC,QAAQF,GACjB,MAAM,IAAIjB,MAAM,6BAGlB,GAA0B,oBAAfH,EACT,MAAM,IAAIG,MAAM,8CAGlB,OAAO,IAAIP,EAAWI,EAAYoB,GAAMK,SAC1C,EAGF5B,EAAQD,WAAaA,C;;;;;;;;ACrGrB,MAAME,EAOJ,WAAAC,CAAYE,EAAOC,GACjBG,KAAKU,OAASM,MAAMC,QAAQrB,GAASA,EAAQ,GAC7CI,KAAKa,MAAQhB,GAAQ,IACvB,CAQA,aAAAwB,CAAcC,GACZ,MAAMf,EAAgC,EAAde,EAAmB,EAC3C,OAAOf,EAAiBP,KAAKuB,MAC/B,CAQA,cAAAC,CAAeF,GACb,MAAMd,EAAiC,EAAdc,EAAmB,EAC5C,OAAOd,EAAkBR,KAAKuB,MAChC,CAQA,OAAAE,CAAQC,GACN,MAAoB,kBAATA,EAA0BA,EAAKC,IACnCD,CACT,CAQA,KAAAE,CAAMC,EAAGC,GACP,MAAMC,EAAO/B,KAAKU,OAAOmB,GACzB7B,KAAKU,OAAOmB,GAAK7B,KAAKU,OAAOoB,GAC7B9B,KAAKU,OAAOoB,GAAKC,CACnB,CAWA,QAAA7B,CAASC,EAAYC,GACnB,OAAOJ,KAAKgC,aACVhC,KAAKyB,QAAQtB,GACbH,KAAKyB,QAAQrB,GAEjB,CASA,WAAA6B,CAAYX,EAAaY,GACvB,QAAIZ,EAAc,GAAKA,GAAetB,KAAKuB,YACvCW,EAAa,GAAKA,GAAclC,KAAKuB,UAEjCvB,KAAKE,SACXF,KAAKU,OAAOY,GACZtB,KAAKU,OAAOwB,IAEhB,CAOA,SAAAC,CAAUC,GACR,IAAIF,EAAaE,EACbd,EAAce,KAAKC,OAAOJ,EAAa,GAAK,GAEhD,MAAOlC,KAAKiC,YAAYX,EAAaY,GACnClC,KAAK4B,MAAMN,EAAaY,GACxBA,EAAaZ,EACbA,EAAce,KAAKC,OAAOJ,EAAa,GAAK,EAEhD,CAQA,kBAAAK,CAAmBjB,GACjB,IACGtB,KAAKqB,cAAcC,KAChBtB,KAAKwB,eAAeF,GAExB,OAAQ,EAGV,MAAMf,EAAgC,EAAde,EAAmB,EACrCd,EAAiC,EAAdc,EAAmB,EAE5C,IAAKtB,KAAKqB,cAAcC,GACtB,OAAOd,EAGT,IAAKR,KAAKwB,eAAeF,GACvB,OAAOf,EAGT,MAAMiC,EAASxC,KAAKE,SAClBF,KAAKU,OAAOH,GACZP,KAAKU,OAAOF,IAGd,OAAOgC,EAASjC,EAAiBC,CACnC,CAMA,YAAAiC,CAAaL,GACX,IAAId,EAAcc,EACdF,EAAalC,KAAKuC,mBAAmBjB,GAEzC,MAAOtB,KAAKiC,YAAYX,EAAaY,GACnClC,KAAK4B,MAAMN,EAAaY,GACxBZ,EAAcY,EACdA,EAAalC,KAAKuC,mBAAmBjB,EAEzC,CAOA,WAAAoB,GACE,GAAI1C,KAAK2C,UAAW,OAAO,KAE3B,MAAMC,EAAO5C,KAAK4C,OASlB,OARA5C,KAAKU,OAAO,GAAKV,KAAKU,OAAOV,KAAKuB,OAAS,GAC3CvB,KAAKU,OAAOmC,MACZ7C,KAAKyC,aAAa,GAEdG,IAAS5C,KAAKa,QAChBb,KAAKa,MAAQb,KAAK4C,QAGbA,CACT,CAOA,iBAAAE,CAAkBxC,GAChB,IAGI4B,EAHAZ,EAAc,EACdf,EAAiB,EACjBC,EAAkB,EAGtB,MAAOD,EAAiBD,EACtB4B,EAAalC,KAAKK,uBAChBC,EACAC,EACAC,GAGER,KAAKiC,YAAYX,EAAaY,IAChClC,KAAK4B,MAAMN,EAAaY,GAG1BZ,EAAcY,EACd3B,EAAgC,EAAde,EAAmB,EACrCd,EAAiC,EAAdc,EAAmB,CAE1C,CAQA,MAAAyB,CAAOC,GACL,OAAO,IAAIA,EAAShD,KAAKU,OAAOE,QAASZ,KAAKa,MAChD,CAOA,IAAAoC,GACE,IAAK,IAAIpB,EAAI7B,KAAKuB,OAAS,EAAGM,EAAI,EAAGA,GAAK,EACxC7B,KAAK4B,MAAM,EAAGC,GACd7B,KAAK8C,kBAAkBjB,GAGzB,OAAO7B,KAAKU,MACd,CASA,MAAAwC,CAAOvB,EAAKwB,GACV,MAAMC,OAAoBC,IAAVF,EAAsB,CAAExB,MAAKwB,SAAUxB,EAMvD,OALA3B,KAAKU,OAAO4C,KAAKF,GACjBpD,KAAKmC,UAAUnC,KAAKuB,OAAS,GACV,OAAfvB,KAAKa,OAAmBb,KAAKE,SAASkD,EAASpD,KAAKa,SACtDb,KAAKa,MAAQuC,GAERpD,IACT,CAOA,GAAAkB,GACE,IAAK,IAAIW,EAAI,EAAGA,EAAI7B,KAAKuB,OAAQM,GAAK,EACpC7B,KAAKmC,UAAUN,GAEjB,OAAO7B,IACT,CAOA,OAAAoB,GACE,MAAMmC,EAAoBjC,IACxB,IAAIkC,GAAc,EACdC,GAAe,EAEnB,GAAIzD,KAAKqB,cAAcC,GAAc,CACnC,MAAMf,EAAgC,EAAde,EAAmB,EAM3C,GALAkC,EAAcxD,KAAKE,SACjBF,KAAKU,OAAOY,GACZtB,KAAKU,OAAOH,KAGTiD,EACH,OAAO,EAGTA,EAAcD,EAAiBhD,EACjC,CAEA,GAAIP,KAAKwB,eAAeF,GAAc,CACpC,MAAMd,EAAiC,EAAdc,EAAmB,EAM5C,GALAmC,EAAezD,KAAKE,SAClBF,KAAKU,OAAOY,GACZtB,KAAKU,OAAOF,KAGTiD,EACH,OAAO,EAGTA,EAAeF,EAAiB/C,EAClC,CAEA,OAAOgD,GAAeC,CAAY,EAGpC,OAAOF,EAAiB,EAC1B,CAOA,IAAAX,GACE,OAAI5C,KAAK2C,UAAkB,KACpB3C,KAAKU,OAAO,EACrB,CAOA,IAAAb,GACE,OAAOG,KAAKa,KACd,CAOA,IAAAU,GACE,OAAOvB,KAAKU,OAAOgD,MACrB,CAOA,OAAAf,GACE,OAAuB,IAAhB3C,KAAKuB,MACd,CAMA,KAAAoC,GACE3D,KAAKU,OAAS,GACdV,KAAKa,MAAQ,IACf,CAUA,eAAO+C,CAAS7C,EAAMiC,GACpB,IAAKhC,MAAMC,QAAQF,GACjB,MAAM,IAAIjB,MAAM,6BAGlB,OAAO,IAAIkD,EAASjC,GAAMG,KAC5B,CAUA,mBAAO2C,CAAa9C,EAAMiC,GACxB,OAAO,IAAIA,EAASjC,GAAMK,SAC5B,EAGF5B,EAAQC,KAAOA,C;;;;;ACxXf,MAAM,KAAEA,GAAS,EAAQ,OAMzB,MAAMH,UAAgBG,EAQpB,YAAAuC,CAAa8B,EAAWC,GACtB,OAAOD,EAAYC,CACrB,CAUA,sBAAA1D,CAAuBC,EAAOC,EAAgBC,GAC5C,MAAMwD,EAAehE,KAAKyB,QAAQzB,KAAKU,OAAOH,IACxC0D,EAAgBjE,KAAKyB,QAAQzB,KAAKU,OAAOF,IAE/C,OAAIyD,EAAgBD,GAAgBxD,EAAkBF,EAC7CE,EAEFD,CACT,CAOA,KAAAI,GACE,OAAOZ,MAAMgD,OAAOzD,EACtB,CASA,cAAOwB,CAAQC,GACb,OAAOhB,MAAM6D,SAAS7C,EAAMzB,EAC9B,CASA,kBAAO6B,CAAYJ,GACjB,OAAOhB,MAAM8D,aAAa9C,EAAMzB,EAClC,EAGFE,EAAQF,QAAUA,C;;;;;ACpElB,MAAM,KAAEG,GAAS,EAAQ,OAMzB,MAAMJ,UAAgBI,EAQpB,YAAAuC,CAAa8B,EAAWC,GACtB,OAAOD,EAAYC,CACrB,CAUA,sBAAA1D,CAAuBC,EAAOC,EAAgBC,GAC5C,MAAMwD,EAAehE,KAAKyB,QAAQzB,KAAKU,OAAOH,IACxC0D,EAAgBjE,KAAKyB,QAAQzB,KAAKU,OAAOF,IAE/C,OAAIyD,EAAgBD,GAAgBxD,EAAkBF,EAC7CE,EAEFD,CACT,CAOA,KAAAI,GACE,OAAOZ,MAAMgD,OAAO1D,EACtB,CASA,cAAOyB,CAAQC,GACb,OAAOhB,MAAM6D,SAAS7C,EAAM1B,EAC9B,CASA,kBAAO8B,CAAYJ,GACjB,OAAOhB,MAAM8D,aAAa9C,EAAM1B,EAClC,EAGFG,EAAQH,QAAUA,C,wBCzElB,MAAM,iBAAE6E,GAAqB,EAAQ,QAC/B,iBAAEC,GAAqB,EAAQ,QAC/B,cAAEC,GAAkB,EAAQ,OAElCC,EAAO7E,QAAU,CAAE0E,mBAAkBC,mBAAkBC,gB;;;;;ACCvD,MAAM,QAAE9E,GAAY,EAAQ,OACtB,cAAE8E,GAAkB,EAAQ,OAMlC,MAAMD,UAAyBC,EAC7B,WAAA1E,CAAY4E,GACVvE,MAAMuE,GACDtE,KAAKE,WACRF,KAAKuE,MAAQ,IAAIjF,EAErB,EAGFE,EAAQ2E,iBAAmBA,C;;;;;AChB3B,MAAM,QAAE9E,GAAY,EAAQ,OACtB,cAAE+E,GAAkB,EAAQ,OAMlC,MAAMF,UAAyBE,EAC7B,WAAA1E,CAAY4E,GACVvE,MAAMuE,GACDtE,KAAKE,WACRF,KAAKuE,MAAQ,IAAIlF,EAErB,EAGFG,EAAQ0E,iBAAmBA,C;;;;;AChB3B,MAAM,WAAE3E,GAAe,EAAQ,MAK/B,MAAM6E,EAMJ,WAAA1E,CAAY4E,EAAU,CAAC,GACrB,MAAM,SAAEE,EAAQ,QAAE/D,GAAY6D,EAC9B,GAAI7D,EAAS,CACX,GAAuB,oBAAZA,EACT,MAAM,IAAIX,MAAM,iDAElBE,KAAKE,SAAWO,EAChBT,KAAKuE,MAAQ,IAAIhF,EAAWS,KAAKE,SACnC,KAAO,CACL,QAAiBmD,IAAbmB,GAA8C,oBAAbA,EACnC,MAAM,IAAI1E,MAAM,kDAGlBE,KAAKyE,UAAYD,GAAY,CAAEE,IAAQA,EACzC,CACF,CAMA,uBAAAC,CAAwBjD,GACtB,MAAO,CACL8C,SAAU9C,EAAKC,IACfiD,QAASlD,EAAKyB,MAElB,CAMA,IAAA5B,GACE,OAAOvB,KAAKuE,MAAMhD,MACpB,CAMA,OAAAoB,GACE,OAAO3C,KAAKuE,MAAM5B,SACpB,CAOA,KAAAkC,GACE,OAAI7E,KAAK2C,UAAkB,KAEvB3C,KAAKE,SACAF,KAAKuE,MAAM3B,OAGb5C,KAAK2E,wBAAwB3E,KAAKuE,MAAM3B,OACjD,CAOA,IAAAkC,GACE,OAAI9E,KAAK2C,UAAkB,KAEvB3C,KAAKE,SACAF,KAAKuE,MAAM1E,OAGbG,KAAK2E,wBAAwB3E,KAAKuE,MAAM1E,OACjD,CASA,OAAAkF,CAAQH,EAASI,GACf,GAAIhF,KAAKE,SAEP,OADAF,KAAKuE,MAAMrB,OAAO0B,GACX5E,KAGT,GAAIgF,GAAKC,OAAOC,OAAOF,GACrB,MAAM,IAAIlF,MAAM,uCAGlB,GAAImF,OAAOC,OAAOF,IAAMC,OAAOC,MAAMlF,KAAKyE,UAAUG,IAClD,MAAM,IAAI9E,MACR,uFAKJ,MAAM0E,EAAYS,OAAOC,OAAOF,GAAShF,KAAKyE,UAAUG,GAAnBI,EAErC,OADAhF,KAAKuE,MAAMrB,QAAQsB,EAAUI,GACtB5E,IACT,CAOA,OAAAmF,GACE,OAAInF,KAAK2C,UAAkB,KAEvB3C,KAAKE,SACAF,KAAKuE,MAAM7B,cAGb1C,KAAK2E,wBAAwB3E,KAAKuE,MAAM7B,cACjD,CAOA,OAAA0C,GACE,OAAIpF,KAAKE,SACAF,KAAKuE,MAAM5D,QAAQsC,OAAOoC,UAG5BrF,KAAKuE,MACT5D,QACAsC,OACAqC,KAAKC,GAAMvF,KAAK2E,wBAAwBY,KACxCF,SACL,CAMA,KAAA1B,GACE3D,KAAKuE,MAAMZ,OACb,EAGFnE,EAAQ4E,cAAgBA,C,kFChKxB,IAAIoB,EAAS,WAAa,IAAIC,EAAIzF,KAAS0F,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYL,EAAIM,WAAWC,GAAG,CAAC,gBAAgBP,EAAIQ,iBAAiB,EACtMC,EAAkB,G,WCOtB,MAAM,cAAN9B,GAAA,SAEA,OACA+B,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAEAC,UAAAA,CACAC,EAAAA,EACAC,EAAAA,GACAC,EAAAA,IACAC,EAAAA,KAEAC,MAAAA,CACA,gBACA,iBACA,kBACA,mBAEAC,SAAAA,CACA,4BACA,6BACA,8BACA,+BAEAC,KAAAA,CAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,IAEA,EACAC,QAAAA,CACAf,eAAAA,SAAAA,GACA,mBACA,UACA,2BACA,8BACA,qCACA,oBACAgB,EAAAA,IAAAA,EAAAA,CACAC,QAAAA,EACAC,KAAAA,KAAAA,UAAAA,EAAAA,GAAAA,KAEA,CAIA,+CAkBA,EACAC,MAAAA,SAAAA,EAAAA,GACAC,OAAAA,KAAAA,GAAAA,SAAAA,IACA,aACA,+BACA,uCAEA,2BACA,OAEAC,EAAAA,QAAAA,CAEA,KAGAC,QAAAA,IAAAA,GAGA,eACA9G,QAAAA,CAAAA,EAAAA,IAAAA,EAAAA,UAAAA,EAAAA,YAGA+G,EAAAA,QAAAA,CACAP,UAAAA,EACAQ,UAAAA,EACAC,WAAAA,KAAAA,cAAAA,EAAAA,KAGA,gBAEA,+BACA,IACA,kBACA,oBAEA,gEAOA,GALA,MACAH,QAAAA,IAAAA,EAAAA,OAAAA,EAAAA,KAAAA,GACAI,EAAAA,GAGA,cACA,MAGAA,EAAAA,KAAAA,IAAAA,EAAAA,MAAAA,KAAAA,EAAAA,UAAAA,UAAAA,QAAAA,GAAAA,EAAAA,SAAAA,QAEA,sDACAC,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,WAEAC,EAAAA,UAAAA,SAAAA,CAAAA,EAAAA,KACA,cACA,kCAEA,aAEA,yDAEA,aACA,gBACAA,EAAAA,UAAAA,SAAAA,CAAAA,EAAAA,KACA,MAEAC,EAAAA,IAAAA,GAAAA,EAAAA,EAAAA,MAAAA,GAAAA,MAAAA,IAAAA,CACAZ,QAAAA,EACAC,KAAAA,EAAAA,OAGAW,EAAAA,IAAAA,EAAAA,CACAZ,OAAAA,EAAAA,OACAC,KAAAA,EAAAA,MAEA,IAGA,yBACA,WACA,iEAEA,cACAY,EAAAA,IAAAA,EAAAA,EAAAA,WAEAP,EAAAA,QAAAA,CACAP,UAAAA,EACAQ,UAAAA,EACAC,WAAAA,KAAAA,cAAAA,EAAAA,KAGA,CACA,MAEA,6CAEAM,EAAAA,SAAAA,IACA,gBACAH,EAAAA,UAAAA,SAAAA,CAAAA,EAAAA,KACA,MAEAC,EAAAA,IAAAA,GAAAA,MAAAA,CACAZ,QAAAA,EACAC,KAAAA,EAAAA,OAGAW,EAAAA,IAAAA,EAAAA,CACAZ,OAAAA,EAAAA,OACAC,KAAAA,EAAAA,MAEA,IAGA,yBACA,WACA,mDAEA,cACAY,EAAAA,IAAAA,EAAAA,EAAAA,WAEAP,EAAAA,QAAAA,CACAP,UAAAA,EACAQ,UAAAA,EACAC,WAAAA,KAAAA,cAAAA,EAAAA,KAEA,GAEA,CACA,IAGA,CAEA,QACA,EACAO,oBAAAA,SAAAA,EAAAA,EAAAA,EAAAA,GACA,aAGA,gEACA,mBACA,YAyCA,WACA,8BACA,iCAEA,cAGA,CACA,cAEA,YAGA,KAEA,CATAC,EAAAA,CAUA,CAEA,QACA,EACAC,iBAAAA,SAAAA,EAAAA,GAEA,yBACA,yBAEA,SAIA,WACA,qCACA,yCACAH,EAAAA,KAAAA,GAGA,sDACA,yCACAA,EAAAA,KAAAA,GAIA,QACA,EACAI,cAAAA,SAAAA,EAAAA,GACA,QAUA,OATAnB,EAAAA,SAAAA,CAAAA,EAAAA,KACA,kCACA,gCACA,SACAoB,GAAAA,KAAAA,UAAAA,EAAAA,GAAAA,EAAAA,KAEAA,IAAAA,EAAAA,EAAAA,MAAAA,OAAAA,KAAAA,IAAAA,EAAAA,GAAAA,GAAAA,KAAAA,IAAAA,EAAAA,GAAAA,EAAAA,KAAAA,EAAAA,IACA,IAEA,CACA,EACAC,UAAAA,SAAAA,EAAAA,GACA,8CACA,EACAC,SAAAA,SAAAA,GACA,8EACA,IC5T6P,I,UCOzPC,GAAY,OACd,EACAhD,EACAU,GACA,EACA,KACA,WACA,MAIF,EAAesC,EAAiB,O","sources":["webpack://advent-of-code/./node_modules/@datastructures-js/heap/index.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/customHeap.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/heap.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/maxHeap.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/minHeap.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/index.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/src/priorityQueue.js","webpack://advent-of-code/./src/components/2021/Day23.vue?eaaf","webpack://advent-of-code/src/components/2021/Day23.vue","webpack://advent-of-code/./src/components/2021/Day23.vue?c1ec","webpack://advent-of-code/./src/components/2021/Day23.vue"],"sourcesContent":["const { MinHeap } = require('./src/minHeap');\nconst { MaxHeap } = require('./src/maxHeap');\nconst { CustomHeap } = require('./src/customHeap');\n\nexports.MinHeap = MinHeap;\nexports.MaxHeap = MaxHeap;\nexports.CustomHeap = CustomHeap;\n","/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n */\n\nconst { Heap } = require('./heap');\n\n/**\n * @class CustomHeap\n * @extends Heap\n */\nclass CustomHeap extends Heap {\n  constructor(comparator, nodes, leaf) {\n    if (typeof comparator !== 'function') {\n      throw new Error('CustomHeap expects a comparator function');\n    }\n    super(nodes, leaf);\n    this._comparator = comparator;\n  }\n\n  /**\n   * Compares parent & child nodes\n   * and returns true if they are in right positions\n   *\n   * @private\n   * @param {object|number|string} parent\n   * @param {object|number|string} child\n   * @returns {number}\n   */\n  _compare(parentNode, childNode) {\n    return this._comparator(parentNode, childNode) <= 0;\n  }\n\n  /**\n   * Returns child's index of two children before an index\n   * @private\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    const compare = this._comparator(\n      this._nodes[rightChildIndex],\n      this._nodes[leftChildIndex]\n    );\n\n    if (compare <= 0 && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n\n    return leftChildIndex;\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @public\n   * @returns {CustomHeap}\n   */\n  clone() {\n    return new CustomHeap(\n      this._comparator,\n      this._nodes.slice(),\n      this._leaf\n    );\n  }\n\n  /**\n   * Builds a custom heap from an array of items\n   * @public\n   * @static\n   * @param {array} list\n   * @param {function} comparator\n   * @returns {CustomHeap}\n   */\n  static heapify(list, comparator) {\n    if (!Array.isArray(list)) {\n      throw new Error('.heapify expects an array');\n    }\n\n    if (typeof comparator !== 'function') {\n      throw new Error('.heapify expects a comparator function');\n    }\n\n    return new CustomHeap(comparator, list).fix();\n  }\n\n  /**\n   * Checks if a list of items is a valid custom heap\n   * @public\n   * @static\n   * @param {array} list\n   * @param {function} comparator\n   * @returns {boolean}\n   */\n  static isHeapified(list, comparator) {\n    if (!Array.isArray(list)) {\n      throw new Error('.heapify expects an array');\n    }\n\n    if (typeof comparator !== 'function') {\n      throw new Error('.isHeapified expects a comparator function');\n    }\n\n    return new CustomHeap(comparator, list).isValid();\n  }\n}\n\nexports.CustomHeap = CustomHeap;\n","/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n *\n * @class\n * @abstract\n */\nclass Heap {\n  /**\n   * Creates a heap instance\n   * @param {array<string|number|object>} nodes\n   * @param {string|number|object} [leaf]\n   * @returns {number}\n   */\n  constructor(nodes, leaf) {\n    this._nodes = Array.isArray(nodes) ? nodes : [];\n    this._leaf = leaf || null;\n  }\n\n  /**\n   * Checks if a parent has a left child\n   * @private\n   * @param {number} parentIndex\n   * @returns {boolean}\n   */\n  _hasLeftChild(parentIndex) {\n    const leftChildIndex = (parentIndex * 2) + 1;\n    return leftChildIndex < this.size();\n  }\n\n  /**\n   * Checks if a parent has a right child\n   * @private\n   * @param {number} parentIndex\n   * @returns {boolean}\n   */\n  _hasRightChild(parentIndex) {\n    const rightChildIndex = (parentIndex * 2) + 2;\n    return rightChildIndex < this.size();\n  }\n\n  /**\n   * Returns heap node's key\n   * @private\n   * @param {object|number|string} node\n   * @returns {number|string}\n   */\n  _getKey(node) {\n    if (typeof node === 'object') return node.key;\n    return node;\n  }\n\n  /**\n   * Swaps two nodes in the heap\n   * @private\n   * @param {number} i\n   * @param {number} j\n   */\n  _swap(i, j) {\n    const temp = this._nodes[i];\n    this._nodes[i] = this._nodes[j];\n    this._nodes[j] = temp;\n  }\n\n  /**\n   * Compares parent & child nodes\n   * and returns true if they are in right positions\n   *\n   * @private\n   * @param {object|number|string} parent\n   * @param {object|number|string} child\n   * @returns {boolean}\n   */\n  _compare(parentNode, childNode) {\n    return this._compareKeys(\n      this._getKey(parentNode),\n      this._getKey(childNode)\n    );\n  }\n\n  /**\n   * Checks if parent and child nodes should be swapped\n   * @private\n   * @param {number} parentIndex\n   * @param {number} childIndex\n   * @returns {boolean}\n   */\n  _shouldSwap(parentIndex, childIndex) {\n    if (parentIndex < 0 || parentIndex >= this.size()) return false;\n    if (childIndex < 0 || childIndex >= this.size()) return false;\n\n    return !this._compare(\n      this._nodes[parentIndex],\n      this._nodes[childIndex]\n    );\n  }\n\n  /**\n   * Bubbles a node from a starting index up in the heap\n   * @param {number} startingIndex\n   * @public\n   */\n  heapifyUp(startingIndex) {\n    let childIndex = startingIndex;\n    let parentIndex = Math.floor((childIndex - 1) / 2);\n\n    while (this._shouldSwap(parentIndex, childIndex)) {\n      this._swap(parentIndex, childIndex);\n      childIndex = parentIndex;\n      parentIndex = Math.floor((childIndex - 1) / 2);\n    }\n  }\n\n  /**\n   * Compares left and right & children of a parent\n   * @private\n   * @param {number} parentIndex\n   * @returns {number} - a child's index\n   */\n  _compareChildrenOf(parentIndex) {\n    if (\n      !this._hasLeftChild(parentIndex)\n      && !this._hasRightChild(parentIndex)\n    ) {\n      return -1;\n    }\n\n    const leftChildIndex = (parentIndex * 2) + 1;\n    const rightChildIndex = (parentIndex * 2) + 2;\n\n    if (!this._hasLeftChild(parentIndex)) {\n      return rightChildIndex;\n    }\n\n    if (!this._hasRightChild(parentIndex)) {\n      return leftChildIndex;\n    }\n\n    const isLeft = this._compare(\n      this._nodes[leftChildIndex],\n      this._nodes[rightChildIndex]\n    );\n\n    return isLeft ? leftChildIndex : rightChildIndex;\n  }\n\n  /**\n   * Pushes a node from a starting index down in the heap\n   * @private\n   */\n  _heapifyDown(startingIndex) {\n    let parentIndex = startingIndex;\n    let childIndex = this._compareChildrenOf(parentIndex);\n\n    while (this._shouldSwap(parentIndex, childIndex)) {\n      this._swap(parentIndex, childIndex);\n      parentIndex = childIndex;\n      childIndex = this._compareChildrenOf(parentIndex);\n    }\n  }\n\n  /**\n   * Removes and returns the root node in the heap\n   * @public\n   * @returns {object}\n   */\n  extractRoot() {\n    if (this.isEmpty()) return null;\n\n    const root = this.root();\n    this._nodes[0] = this._nodes[this.size() - 1];\n    this._nodes.pop();\n    this._heapifyDown(0);\n\n    if (root === this._leaf) {\n      this._leaf = this.root();\n    }\n\n    return root;\n  }\n\n  /**\n   * Pushes a node with down in the heap before an index\n   * @private\n   * @param {number} index\n   */\n  _heapifyDownUntil(index) {\n    let parentIndex = 0;\n    let leftChildIndex = 1;\n    let rightChildIndex = 2;\n    let childIndex;\n\n    while (leftChildIndex < index) {\n      childIndex = this._compareChildrenBefore(\n        index,\n        leftChildIndex,\n        rightChildIndex\n      );\n\n      if (this._shouldSwap(parentIndex, childIndex)) {\n        this._swap(parentIndex, childIndex);\n      }\n\n      parentIndex = childIndex;\n      leftChildIndex = (parentIndex * 2) + 1;\n      rightChildIndex = (parentIndex * 2) + 2;\n    }\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @protected\n   * @param {class} HeapType\n   * @returns {Heap}\n   */\n  _clone(HeapType) {\n    return new HeapType(this._nodes.slice(), this._leaf);\n  }\n\n  /**\n   * Sorts the heap by swapping root with all nodes and fixing positions\n   * @public\n   * @returns {array} the sorted nodes\n   */\n  sort() {\n    for (let i = this.size() - 1; i > 0; i -= 1) {\n      this._swap(0, i);\n      this._heapifyDownUntil(i);\n    }\n\n    return this._nodes;\n  }\n\n  /**\n   * Inserts a node in the right position into the heap\n   * @public\n   * @param {number|string} key\n   * @param {any} [value]\n   * @returns {Heap}\n   */\n  insert(key, value) {\n    const newNode = value !== undefined ? { key, value } : key;\n    this._nodes.push(newNode);\n    this.heapifyUp(this.size() - 1);\n    if (this._leaf === null || !this._compare(newNode, this._leaf)) {\n      this._leaf = newNode;\n    }\n    return this;\n  }\n\n  /**\n   * Fixes all positions of the nodes in the heap\n   * @public\n   * @returns {Heap}\n   */\n  fix() {\n    for (let i = 0; i < this.size(); i += 1) {\n      this.heapifyUp(i);\n    }\n    return this;\n  }\n\n  /**\n   * Verifies that the heap is valid\n   * @public\n   * @returns {boolean}\n   */\n  isValid() {\n    const isValidRecursive = (parentIndex) => {\n      let isValidLeft = true;\n      let isValidRight = true;\n\n      if (this._hasLeftChild(parentIndex)) {\n        const leftChildIndex = (parentIndex * 2) + 1;\n        isValidLeft = this._compare(\n          this._nodes[parentIndex],\n          this._nodes[leftChildIndex]\n        );\n\n        if (!isValidLeft) {\n          return false;\n        }\n\n        isValidLeft = isValidRecursive(leftChildIndex);\n      }\n\n      if (this._hasRightChild(parentIndex)) {\n        const rightChildIndex = (parentIndex * 2) + 2;\n        isValidRight = this._compare(\n          this._nodes[parentIndex],\n          this._nodes[rightChildIndex]\n        );\n\n        if (!isValidRight) {\n          return false;\n        }\n\n        isValidRight = isValidRecursive(rightChildIndex);\n      }\n\n      return isValidLeft && isValidRight;\n    };\n\n    return isValidRecursive(0);\n  }\n\n  /**\n   * Returns the root node in the heap\n   * @public\n   * @returns {object|number|string|null}\n   */\n  root() {\n    if (this.isEmpty()) return null;\n    return this._nodes[0];\n  }\n\n  /**\n   * Returns a leaf node in the heap\n   * @public\n   * @returns {object|number|string|null}\n   */\n  leaf() {\n    return this._leaf;\n  }\n\n  /**\n   * Returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._nodes.length;\n  }\n\n  /**\n   * Checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Clears the heap\n   * @public\n   */\n  clear() {\n    this._nodes = [];\n    this._leaf = null;\n  }\n\n  /**\n   * Convert a list of items into a heap\n   * @protected\n   * @static\n   * @param {array} array\n   * @param {class} HeapType\n   * @returns {Heap}\n   */\n  static _heapify(list, HeapType) {\n    if (!Array.isArray(list)) {\n      throw new Error('.heapify expects an array');\n    }\n\n    return new HeapType(list).fix();\n  }\n\n  /**\n   * Checks if a list of items is a valid heap\n   * @protected\n   * @static\n   * @param {array} array\n   * @param {class} HeapType\n   * @returns {boolean}\n   */\n  static _isHeapified(list, HeapType) {\n    return new HeapType(list).isValid();\n  }\n}\n\nexports.Heap = Heap;\n","/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n */\n\nconst { Heap } = require('./heap');\n\n/**\n * @class MaxHeap\n * @extends Heap\n */\nclass MaxHeap extends Heap {\n  /**\n   * Checks two nodes are in relatively valid position\n   * @private\n   * @param {object} parent\n   * @param {object} child\n   * @returns {boolean}\n   */\n  _compareKeys(parentKey, childKey) {\n    return parentKey > childKey;\n  }\n\n  /**\n   * Returns max child's index of two children before an index\n   * @private\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    const leftChildKey = this._getKey(this._nodes[leftChildIndex]);\n    const rightChildKey = this._getKey(this._nodes[rightChildIndex]);\n\n    if (rightChildKey > leftChildKey && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n    return leftChildIndex;\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @public\n   * @returns {MaxHeap}\n   */\n  clone() {\n    return super._clone(MaxHeap);\n  }\n\n  /**\n   * Builds a max heap from an array of items\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {MaxHeap}\n   */\n  static heapify(list) {\n    return super._heapify(list, MaxHeap);\n  }\n\n  /**\n   * Checks if a list of items is a valid max heap\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {boolean}\n   */\n  static isHeapified(list) {\n    return super._isHeapified(list, MaxHeap);\n  }\n}\n\nexports.MaxHeap = MaxHeap;\n","/**\n * @license MIT\n * @copyright 2019 Eyas Ranjous <eyas.ranjous@gmail.com>\n */\n\nconst { Heap } = require('./heap');\n\n/**\n * @class MinHeap\n * @extends Heap\n */\nclass MinHeap extends Heap {\n  /**\n   * Checks two nodes are in relatively valid position\n   * @private\n   * @param {object} parent\n   * @param {object} child\n   * @returns {boolean}\n   */\n  _compareKeys(parentKey, childKey) {\n    return parentKey < childKey;\n  }\n\n  /**\n   * Returns min child's index of two children before an index\n   * @protected\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    const leftChildKey = this._getKey(this._nodes[leftChildIndex]);\n    const rightChildKey = this._getKey(this._nodes[rightChildIndex]);\n\n    if (rightChildKey < leftChildKey && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n    return leftChildIndex;\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @public\n   * @returns {MinHeap}\n   */\n  clone() {\n    return super._clone(MinHeap);\n  }\n\n  /**\n   * Builds a min heap from an array of items\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {MinHeap}\n   */\n  static heapify(list) {\n    return super._heapify(list, MinHeap);\n  }\n\n  /**\n   * Checks if a list of list is a valid min heap\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {boolean}\n   */\n  static isHeapified(list) {\n    return super._isHeapified(list, MinHeap);\n  }\n}\n\nexports.MinHeap = MinHeap;\n","const { MinPriorityQueue } = require('./src/minPriorityQueue');\nconst { MaxPriorityQueue } = require('./src/maxPriorityQueue');\nconst { PriorityQueue } = require('./src/priorityQueue')\n\nmodule.exports = { MinPriorityQueue, MaxPriorityQueue, PriorityQueue };\n","/**\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { MaxHeap } = require('@datastructures-js/heap');\nconst { PriorityQueue } = require('./priorityQueue');\n\n/**\n * @class MaxPriorityQueue\n * @extends PriorityQueue\n */\nclass MaxPriorityQueue extends PriorityQueue {\n  constructor(options) {\n    super(options);\n    if (!this._compare) {\n      this._heap = new MaxHeap();\n    }\n  }\n}\n\nexports.MaxPriorityQueue = MaxPriorityQueue;\n","/**\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { MinHeap } = require('@datastructures-js/heap');\nconst { PriorityQueue } = require('./priorityQueue');\n\n/**\n * @class MinPriorityQueue\n * @extends PriorityQueue\n */\nclass MinPriorityQueue extends PriorityQueue {\n  constructor(options) {\n    super(options);\n    if (!this._compare) {\n      this._heap = new MinHeap();\n    }\n  }\n}\n\nexports.MinPriorityQueue = MinPriorityQueue;\n","/**\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { CustomHeap } = require('@datastructures-js/heap');\n\n/**\n * @class PriorityQueue\n */\nclass PriorityQueue {\n  /**\n   * Creates a priority queue\n   * @public\n   * @params {object} [options]\n   */\n  constructor(options = {}) {\n    const { priority, compare } = options;\n    if (compare) {\n      if (typeof compare !== 'function') {\n        throw new Error('.constructor expects a valid compare function');\n      }\n      this._compare = compare;\n      this._heap = new CustomHeap(this._compare);\n    } else {\n      if (priority !== undefined && typeof priority !== 'function') {\n        throw new Error('.constructor expects a valid priority function');\n      }\n\n      this._priority = priority || ((el) => +el);\n    }\n  }\n\n  /**\n   * @private\n   * @returns {object}\n   */\n  _getElementWithPriority(node) {\n    return {\n      priority: node.key,\n      element: node.value\n    };\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * Returns an element with highest priority in the queue\n   * @public\n   * @returns {object}\n   */\n  front() {\n    if (this.isEmpty()) return null;\n\n    if (this._compare) {\n      return this._heap.root();\n    }\n\n    return this._getElementWithPriority(this._heap.root());\n  }\n\n  /**\n   * Returns an element with lowest priority in the queue\n   * @public\n   * @returns {object}\n   */\n  back() {\n    if (this.isEmpty()) return null;\n\n    if (this._compare) {\n      return this._heap.leaf();\n    }\n\n    return this._getElementWithPriority(this._heap.leaf());\n  }\n\n  /**\n   * Adds an element to the queue\n   * @public\n   * @param {any} element\n   * @param {number} p - priority\n   * @throws {Error} if priority is not a valid number\n   */\n  enqueue(element, p) {\n    if (this._compare) {\n      this._heap.insert(element);\n      return this;\n    }\n\n    if (p && Number.isNaN(+p)) {\n      throw new Error('.enqueue expects a numeric priority');\n    }\n\n    if (Number.isNaN(+p) && Number.isNaN(this._priority(element))) {\n      throw new Error(\n        '.enqueue expects a numeric priority '\n        + 'or a constructor callback that returns a number'\n      );\n    }\n\n    const priority = !Number.isNaN(+p) ? p : this._priority(element);\n    this._heap.insert(+priority, element);\n    return this;\n  }\n\n  /**\n   * Removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {object}\n   */\n  dequeue() {\n    if (this.isEmpty()) return null;\n\n    if (this._compare) {\n      return this._heap.extractRoot();\n    }\n\n    return this._getElementWithPriority(this._heap.extractRoot());\n  }\n\n  /**\n   * Returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    if (this._compare) {\n      return this._heap.clone().sort().reverse();\n    }\n\n    return this._heap\n      .clone()\n      .sort()\n      .map((n) => this._getElementWithPriority(n))\n      .reverse();\n  }\n\n  /**\n   * Clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n}\n\nexports.PriorityQueue = PriorityQueue;\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":23,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"23\" :year=\"2021\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nconst { PriorityQueue } = require('@datastructures-js/priority-queue')\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      moveCosts: {\n        A: 1,\n        B: 10,\n        C: 100,\n        D: 1000\n      },\n      rooms: {\n        1: [[3, 2], [3, 3]],\n        10: [[5, 2], [5, 3]],\n        100: [[7, 2], [7, 3]],\n        1000: [[9, 2], [9, 3]]\n      },\n      roomsTwo: {\n        1: [[3, 2], [3, 3], [3, 4], [3, 5]],\n        10: [[5, 2], [5, 3], [5, 4], [5, 5]],\n        100: [[7, 2], [7, 3], [7, 4], [7, 5]],\n        1000: [[9, 2], [9, 3], [9, 4], [9, 5]]\n      },\n      hall: [1, 2, 4, 6, 8, 10, 11]\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const copy = input.concat()\n      const amphipods = new Map()\n      for (let y = 0; y < copy.length; y++) {\n        for (let x = 0; x < copy[y].length; x++) {\n          if (![' ', '#', '.'].includes(copy[y][x])) {\n            const coords = `${x},${y}`\n            amphipods.set(coords, {\n              isDone: false,\n              type: this.moveCosts[copy[y][x]]\n            })\n          }\n        }\n      }\n\n      this.solutions.partOne = this.solve(amphipods, this.rooms)\n\n      // copy.splice(3, 0, '  #D#C#B#A#', '  #D#B#A#C#')\n\n      // amphipods = new Map()\n      // for (let y = 0; y < copy.length; y++) {\n      //   for (let x = 0; x < copy[y].length; x++) {\n      //     if (![' ', '#', '.'].includes(copy[y][x])) {\n      //       const coords = `${x},${y}`\n      //       amphipods.set(coords, {\n      //         isDone: false,\n      //         type: this.moveCosts[copy[y][x]]\n      //       })\n      //     }\n      //   }\n      // }\n\n      // this.solutions.partTwo = this.solve(amphipods, this.roomsTwo)\n    },\n    solve: function (amphipods, rooms) {\n      Object.keys(rooms).forEach(type => {\n        const r = rooms[type]\n        for (let i = r.length - 1; i >= 0; i--) {\n          const a = amphipods.get(`${r[i][0]},${r[i][1]}`)\n\n          if (a === undefined || a.type !== (+type)) {\n            return\n          } else {\n            a.isDone = true\n          }\n        }\n      })\n\n      console.log(amphipods)\n\n      // Use a priority queue to keep track of the configurations with lowest cost\n      const queue = new PriorityQueue({\n        compare: (a, b) => a.costTotal - b.costTotal\n      })\n\n      queue.enqueue({\n        amphipods: amphipods,\n        costTotal: 0,\n        costApprox: this.getApproxCost(amphipods, rooms)\n      })\n\n      const seenCosts = new Map()\n\n      let min = Number.POSITIVE_INFINITY\n      let max = 0\n      while (queue.size() > 0) {\n        const current = queue.dequeue()\n\n        const curMax = Array.from(current.amphipods.values()).filter(a => a.isDone).length\n\n        if (curMax > max) {\n          console.log(queue.size(), seenCosts.size, curMax)\n          max = curMax\n        }\n\n        if (current.costTotal > min) {\n          break\n        }\n\n        max = Math.max(max, Array.from(current.amphipods.values()).filter(a => a.isDone).length)\n\n        if (Array.from(current.amphipods.values()).every(a => a.isDone)) {\n          min = Math.min(min, current.costTotal)\n        } else {\n          current.amphipods.forEach((amphipod, key) => {\n            if (!amphipod.isDone) {\n              const coords = key.split(',').map(c => +c)\n\n              if (coords[1] === 1) {\n                // We're in the hall\n                const roomPositionY = this.getFreeRoomPosition(coords, amphipod.type, current.amphipods, rooms)\n\n                if (roomPositionY !== null) {\n                  const newAmphipods = new Map()\n                  current.amphipods.forEach((v, k) => {\n                    if (k === key) {\n                      // This is our current one\n                      newAmphipods.set(`${rooms[amphipod.type][0][0]},${roomPositionY}`, {\n                        isDone: true,\n                        type: v.type\n                      })\n                    } else {\n                      newAmphipods.set(k, {\n                        isDone: v.isDone,\n                        type: v.type\n                      })\n                    }\n                  })\n\n                  const stringified = this.toString(newAmphipods)\n                  const prevCost = seenCosts.get(stringified)\n                  const costTotal = current.costTotal + this.manhattan(coords, [rooms[amphipod.type][0][0], roomPositionY]) * amphipod.type\n\n                  if (prevCost === undefined || prevCost > costTotal) {\n                    seenCosts.set(stringified, current.costTotal)\n\n                    queue.enqueue({\n                      amphipods: newAmphipods,\n                      costTotal: costTotal,\n                      costApprox: this.getApproxCost(newAmphipods, rooms)\n                    })\n                  }\n                }\n              } else {\n                // We're in a room and we're not done\n                const possibleHallPositions = this.getHallPositions(coords, current.amphipods)\n\n                possibleHallPositions.forEach(hx => {\n                  const newAmphipods = new Map()\n                  current.amphipods.forEach((v, k) => {\n                    if (k === key) {\n                      // This is our current one\n                      newAmphipods.set(`${hx},1`, {\n                        isDone: false,\n                        type: v.type\n                      })\n                    } else {\n                      newAmphipods.set(k, {\n                        isDone: v.isDone,\n                        type: v.type\n                      })\n                    }\n                  })\n\n                  const stringified = this.toString(newAmphipods)\n                  const prevCost = seenCosts.get(stringified)\n                  const costTotal = current.costTotal + this.manhattan(coords, [hx, 1]) * amphipod.type\n\n                  if (prevCost === undefined || prevCost > costTotal) {\n                    seenCosts.set(stringified, current.costTotal)\n\n                    queue.enqueue({\n                      amphipods: newAmphipods,\n                      costTotal: costTotal,\n                      costApprox: this.getApproxCost(newAmphipods, rooms)\n                    })\n                  }\n                })\n              }\n            }\n          })\n        }\n      }\n\n      return min\n    },\n    getFreeRoomPosition: function (current, type, amphipods, rooms) {\n      const room = rooms[type]\n\n      // Check the hall leading to the room\n      for (let x = Math.min(room[0][0], current[0]) + 1; x < Math.max(room[0][0], current[0]); x++) {\n        if (amphipods.has(`${x},${1}`)) {\n          return null\n        }\n      }\n\n      // const roomAmph = []\n\n      // for (let y = 2; y < room.length + 2; y++) {\n      //   const amph = amphipods.get(`${room[0][0]},${y}`)\n\n      //   roomAmph.push(amph ? amph.type : null)\n      // }\n\n      // // Room completely empty, move to bottom\n      // if (roomAmph.every(r => r === null)) {\n      //   return 1 + room.length\n      // }\n\n      // // Amphipod of wrong type in the room\n      // if (roomAmph.some(r => r !== null && r !== type)) {\n      //   return null\n      // }\n\n      // let result = null\n      // for (let y = room.length + 1; y >= 2; y--) {\n      //   const amph = amphipods.get(`${room[0][0]},${y}`)\n\n      //   if (amph === undefined) {\n      //     if (result === null) {\n      //       // Found a free spot\n      //       result = y\n      //     }\n      //   } else {\n      //     // If we found an empty one and then there's one that isn't empty, then don't move into the room, cause it's not properly filled from the bottom\n      //     if (result !== null) {\n      //       return null\n      //     }\n      //   }\n      // }\n\n      // return result\n\n      let result = null\n      for (let y = 2; y < room.length + 2; y++) {\n        const amph = amphipods.get(`${room[0][0]},${y}`)\n\n        if (amph === undefined) {\n          // Found a free spot\n          result = y\n        } else {\n          if (amph.type !== type) {\n            // There's an amphipod of the wrong type => we cannot go in\n            return null\n          } else {\n            // We found another amphipod of the right type => stop looking further down\n            break\n          }\n        }\n      }\n\n      return result\n    },\n    getHallPositions: function (current, amphipods) {\n      // Check the way out of the room\n      for (let y = current[1] - 1; y > 1; y--) {\n        if (amphipods.has(`${current[0]},${y}`)) {\n          // Someone is in the way, we can't reach the hall\n          return []\n        }\n      }\n\n      const possibleHallPositions = []\n      for (let x = current[0] - 1; x >= this.hall[0]; x--) {\n        if (this.hall.includes(x) && !amphipods.has(`${x},1`)) {\n          possibleHallPositions.push(x)\n        }\n      }\n      for (let x = current[0] + 1; x <= this.hall[this.hall.length - 1]; x++) {\n        if (this.hall.includes(x) && !amphipods.has(`${x},1`)) {\n          possibleHallPositions.push(x)\n        }\n      }\n\n      return possibleHallPositions\n    },\n    getApproxCost: function (amphipods, rooms) {\n      let cost = 0\n      amphipods.forEach((value, key) => {\n        const coords = key.split(',').map(c => +c)\n        const target = rooms[value.type][rooms[value.type].length - 1]\n        if (coords[1] === 1) {\n          cost += this.manhattan(coords, target) * value.type\n        } else {\n          cost += (rooms[value.type].length + Math.abs(coords[1] - 1) + Math.abs(coords[0] - target[0])) * value.type\n        }\n      })\n      return cost\n    },\n    manhattan: function (a, b) {\n      return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1])\n    },\n    toString: function (amphipods) {\n      return Array.from(amphipods.keys()).sort().map(k => `${k},${amphipods.get(k).type}`).join('|')\n    }\n  }\n}\n</script>\n\n<style scoped>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day23.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day23.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day23.vue?vue&type=template&id=8b2e0644&scoped=true\"\nimport script from \"./Day23.vue?vue&type=script&lang=js\"\nexport * from \"./Day23.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"8b2e0644\",\n  null\n  \n)\n\nexport default component.exports"],"names":["MinHeap","MaxHeap","CustomHeap","exports","Heap","constructor","comparator","nodes","leaf","Error","super","this","_comparator","_compare","parentNode","childNode","_compareChildrenBefore","index","leftChildIndex","rightChildIndex","compare","_nodes","clone","slice","_leaf","heapify","list","Array","isArray","fix","isHeapified","isValid","_hasLeftChild","parentIndex","size","_hasRightChild","_getKey","node","key","_swap","i","j","temp","_compareKeys","_shouldSwap","childIndex","heapifyUp","startingIndex","Math","floor","_compareChildrenOf","isLeft","_heapifyDown","extractRoot","isEmpty","root","pop","_heapifyDownUntil","_clone","HeapType","sort","insert","value","newNode","undefined","push","isValidRecursive","isValidLeft","isValidRight","length","clear","_heapify","_isHeapified","parentKey","childKey","leftChildKey","rightChildKey","MinPriorityQueue","MaxPriorityQueue","PriorityQueue","module","options","_heap","priority","_priority","el","_getElementWithPriority","element","front","back","enqueue","p","Number","isNaN","dequeue","toArray","reverse","map","n","render","_vm","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","moveCosts","A","B","C","D","rooms","roomsTwo","hall","methods","amphipods","isDone","type","solve","Object","a","console","queue","costTotal","costApprox","max","min","current","newAmphipods","seenCosts","possibleHallPositions","getFreeRoomPosition","result","getHallPositions","getApproxCost","cost","manhattan","toString","component"],"sourceRoot":""}