{"version":3,"file":"js/8303.37afde30.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCOtB,MAAMC,EAAW,EACXC,EAAQ,EACRC,EAAQ,EAEd,OACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAT,UAAAA,CACAU,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAV,eAAAA,SAAAA,GAEA,WACA,KAEA,4BAEAW,EAAAA,KAAAA,KAAAA,MAAAA,EAAAA,EAAAA,KACAC,EAAAA,KAAAA,KAAAA,MAAAA,EAAAA,KAIA,QACA,4BAEA,8BAEA,QAEAC,GAAAA,EAAAA,EAEA,CAGA,yBAGA,0CAGA,wEAGA,oEACA,EACAC,MAAAA,SAAAA,EAAAA,GAEA,yBACA,mBAEA,cAEA,SACA,cAEA,SAGA,UAEA,aAEA,EAGA,QAEA,SAEA,oCACA,qBAEA,8BAEA,SAEA,QAEA,CAGA,QACA,aAEA,kBACA,MAEA,uBAFA,CAIA,ICxG6P,I,UCOzPC,GAAY,OACd,EACAzB,EACAW,GACA,EACA,KACA,KACA,MAIF,EAAec,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2022/Day13.vue?073d","webpack://advent-of-code/src/components/2022/Day13.vue","webpack://advent-of-code/./src/components/2022/Day13.vue?100e","webpack://advent-of-code/./src/components/2022/Day13.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":13,\"year\":2022,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"13\" :year=\"2022\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nconst CONTINUE = 0\nconst RIGHT = 1\nconst WRONG = 2\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Keep track of the left and right inputs\n      const left = []\n      const right = []\n\n      for (let i = 1; i < input.length; i += 3) {\n        // Parse them using JSON.parse() into JSON\n        left.push(JSON.parse(input[i - 1]))\n        right.push(JSON.parse(input[i]))\n      }\n\n      // Sum up the indices\n      let sum = 0\n      for (let i = 0; i < left.length; i++) {\n        // Check whether they are in order\n        const result = this.check(left[i], right[i])\n\n        if (result === RIGHT) {\n          // If so, add the index\n          sum += i + 1\n        }\n      }\n\n      // Solution for part one is the sum\n      this.solutions.partOne = sum\n\n      // Now concatenate all packets together and add the two dividers\n      const allPackets = left.concat(right).concat([[[2]], [[6]]])\n\n      // Then sort the packets using our implementation and map them to their string representation\n      const mapped = allPackets.sort((a, b) => this.check(a, b) === RIGHT ? -1 : 1).map(p => JSON.stringify(p))\n\n      // Now search for the divider packets and multiply their indices together\n      this.solutions.partTwo = (mapped.indexOf('[[2]]') + 1) * (mapped.indexOf('[[6]]') + 1)\n    },\n    check: function (left, right) {\n      // Check for both whether they are arrays\n      const lIsArray = Array.isArray(left)\n      const rIsArray = Array.isArray(right)\n\n      if (left === undefined) {\n        // If the left is undefined, this means that the containing array ran out of items, it's in the right order\n        return RIGHT\n      } else if (right === undefined) {\n        // If the right is undefined, the containing array ran out of items, it's in the wrong order\n        return WRONG\n      }\n\n      if (!lIsArray && !rIsArray) {\n        // If both aren't arrays => they're numbers\n        if (left === right) {\n          // Same number, keep looking\n          return CONTINUE\n        } else {\n          // Left number is smaller than right\n          return left < right ? RIGHT : WRONG\n        }\n      } else if (lIsArray && rIsArray) {\n        // If both are arrays, iterate through them\n        const max = Math.max(left.length, right.length)\n        for (let i = 0; i < max; i++) {\n          // For each pair, check them recursively\n          const result = this.check(left[i], right[i])\n\n          if (result !== CONTINUE) {\n            // We found a result (either RIGHT or WRONG), therefore, return it\n            return result\n          }\n        }\n\n        // If we didn't find a result, tell the recursion source to keep looking\n        return CONTINUE\n      } else if (!lIsArray && rIsArray) {\n        // If the left isn't an array, make it one\n        return this.check([left], right)\n      } else if (lIsArray && !rIsArray) {\n        // If the right isn't an array, make it one\n        return this.check(left, [right])\n      }\n    }\n  }\n}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day13.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day13.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day13.vue?vue&type=template&id=444796f2\"\nimport script from \"./Day13.vue?vue&type=script&lang=js\"\nexport * from \"./Day13.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","CONTINUE","RIGHT","WRONG","components","Day","data","partOne","partTwo","methods","left","right","sum","check","component"],"sourceRoot":""}