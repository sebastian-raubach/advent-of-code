"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[5641,1978],{31125:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ Day18)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day18.vue?vue&type=template&id=4850715e&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'Day\',{attrs:{"day":18,"year":2021,"solutions":_vm.solutions},on:{"input-changed":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js\nvar es_array_concat = __webpack_require__(92222);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js\nvar es_regexp_exec = __webpack_require__(74916);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js\nvar es_string_split = __webpack_require__(23123);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js\nvar es_array_map = __webpack_require__(21249);\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(85619);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day18.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n//\n//\n//\n//\n//\n\n/* harmony default export */ const Day18vue_type_script_lang_js_ = ({\n  components: {\n    Day: Day["default"]\n  },\n  data: function data() {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function onInputChanged(input) {\n      // Start with the first\n      var current = input[0];\n\n      for (var i = 1; i < input.length; i++) {\n        // Then stepwise add the other onto it\n        current = this.add(current, input[i]);\n      } // Convert to an array using the convenient JSON.parse\n\n\n      var arr = JSON.parse(current); // Get the magnitude by traversing the tree\n\n      this.solutions.partOne = this.magnitude(arr); // Find the maximum\n\n      var max = 0; // Pairwise comparison of all pairs\n\n      for (var _i = 0; _i < input.length; _i++) {\n        for (var j = 0; j < input.length; j++) {\n          // Skip same ones\n          if (_i === j) {\n            continue;\n          } // Calculate the magnitude\n\n\n          var result = this.magnitude(JSON.parse(this.add(input[_i], input[j]))); // Update maximum\n\n          max = Math.max(max, result);\n        }\n      }\n\n      this.solutions.partTwo = max;\n    },\n    add: function add(one, two) {\n      // Create the concatenated array\n      var current = "[".concat(one, ",").concat(two, "]"); // While we found something to compact\n\n      var compacting = false;\n\n      do {\n        // Explode first\n        var result = this.explode(current);\n        current = result[0];\n        compacting = result[1]; // If there was no explosion\n\n        if (!compacting) {\n          // Check for splits\n          result = this.split(current);\n          current = result[0];\n          compacting = result[1];\n        }\n      } while (compacting); // Return the result of the addition\n\n\n      return current;\n    },\n    magnitude: function magnitude(current) {\n      if (isNaN(current)) {\n        // For internal nodes, it\'s 3 times left plus 2 times right\n        return 3 * this.magnitude(current[0]) + 2 * this.magnitude(current[1]);\n      } else {\n        // For leaf nodes, it\'s the value\n        return current;\n      }\n    },\n    split: function split(current) {\n      var arr = current.split(\'\'); // Find numbers that are larger or equal to 10\n\n      var start = null;\n      var end = null;\n      var isNumber = false; // Go through the string from left to right\n\n      for (var i = 0; i < arr.length; i++) {\n        // If we find a number\n        if (!isNaN(arr[i])) {\n          isNumber = true;\n\n          if (start === null) {\n            // Set the start (left boundary)\n            start = i; // Set an initial value for the end (right boundary)\n\n            end = Math.min(i + 1, arr.length - 1);\n          } else {\n            // Update the end (right boundary)\n            end = Math.min(i + 1, arr.length - 1);\n          }\n        } else {\n          isNumber = false;\n        } // We got to the end\n\n\n        if (i === arr.length - 1) {\n          isNumber = false;\n        } // If we\'re no longer in the process of parsing a multi-digit number and we found a start and an end\n\n\n        if (!isNumber && start !== null && end !== null) {\n          // Parse the number\n          var n = parseInt(current.substring(start, end));\n\n          if (n >= 10) {\n            // If it\'s too large, replace it with an array of floor and ceil\n            return ["".concat(current.substring(0, start), "[").concat(Math.floor(n / 2.0), ",").concat(Math.ceil(n / 2.0), "]").concat(current.substring(end, current.length)), true];\n          } else {\n            // If it\'s too small, continue searching\n            start = null;\n            end = null;\n            isNumber = false;\n          }\n        }\n      } // Indicate we didn\'t split\n\n\n      return [current, false];\n    },\n    explode: function explode(current) {\n      var arr = current.split(\'\'); // Count the level by keeping track of opening and closing brackets\n\n      var openCount = 0;\n\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] === \'[\') {\n          openCount++;\n        }\n\n        if (arr[i] === \']\') {\n          openCount--;\n        } // We found one that\'s "too deep"\n\n\n        if (openCount > 4) {\n          // Get the end index\n          var endIndex = current.indexOf(\']\', i); // Parse the number pair\n\n          var pair = current.substring(i + 1, endIndex).split(\',\').map(function (c) {\n            return +c;\n          }); // Get the left and the right substrings for later\n\n          var left = current.substring(0, i);\n          var right = current.substring(endIndex + 1); // Go from the found index towards the left to find the first number and increase it\n\n          var start = null;\n          var end = null;\n          var isNumber = false;\n          var leftArr = left.split(\'\');\n\n          for (var l = leftArr.length - 1; l >= 0; l--) {\n            if (!isNaN(leftArr[l])) {\n              isNumber = true;\n\n              if (end === null) {\n                // We found the right border\n                end = l; // Initialise the left border\n\n                start = Math.max(0, l - 1);\n              } else {\n                // Update the left border\n                start = Math.max(0, l - 1);\n              }\n            } else {\n              isNumber = false;\n            }\n\n            if (l === 0) {\n              isNumber = false;\n            } // If we\'re no longer in the process of parsing a multi-digit number and we found a start and an end\n\n\n            if (!isNumber && start !== null && end !== null) {\n              // Update the left side by increasing the number value\n              left = "".concat(left.substring(0, start + 1)).concat(parseInt(left.substring(start + 1, end + 1)) + pair[0]).concat(left.substring(end + 1, left.length));\n              break;\n            }\n          }\n\n          start = null;\n          end = null;\n          isNumber = false;\n          var rightArr = right.split(\'\');\n\n          for (var r = 0; r < rightArr.length; r++) {\n            if (!isNaN(rightArr[r])) {\n              isNumber = true;\n\n              if (start === null) {\n                // We found the left border\n                start = r; // Initialise the left border\n\n                end = Math.min(rightArr.length - 1, r + 1);\n              } else {\n                // Update the left border\n                end = Math.min(rightArr.length - 1, r + 1);\n              }\n            } else {\n              isNumber = false;\n            }\n\n            if (r === rightArr.length - 1) {\n              isNumber = false;\n            } // If we\'re no longer in the process of parsing a multi-digit number and we found a start and an end\n\n\n            if (!isNumber && start !== null && end !== null) {\n              // Update the right side by increasing the number value\n              right = "".concat(right.substring(0, start)).concat(parseInt(right.substring(start, end)) + pair[1]).concat(right.substring(end, right.length));\n              break;\n            }\n          } // Reconstitute the whole string by setting a zero in the middle\n\n\n          current = "".concat(left, "0").concat(right); // Indicate we exploded\n\n          return [current, true];\n        }\n      } // Indicate we didn\'t explode\n\n\n      return [current, false];\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2021/Day18.vue?vue&type=script&lang=js&\n /* harmony default export */ const _2021_Day18vue_type_script_lang_js_ = (Day18vue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2021/Day18.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2021_Day18vue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "4850715e",\n  null\n  \n)\n\n/* harmony default export */ const Day18 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjEvRGF5MTgudnVlP2Y0ZjUiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxOC52dWU/ZmZkNSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjEvRGF5MTgudnVlPzVhNTIiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIxL0RheTE4LnZ1ZT80ZmUzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdEYXknLHthdHRyczp7XCJkYXlcIjoxOCxcInllYXJcIjoyMDIxLFwic29sdXRpb25zXCI6X3ZtLnNvbHV0aW9uc30sb246e1wiaW5wdXQtY2hhbmdlZFwiOl92bS5vbklucHV0Q2hhbmdlZH19KX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIxOFwiIDp5ZWFyPVwiMjAyMVwiIDpzb2x1dGlvbnM9XCJzb2x1dGlvbnNcIiBAaW5wdXQtY2hhbmdlZD1cIm9uSW5wdXRDaGFuZ2VkXCI+XG4gIDwvRGF5PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBEYXkgZnJvbSAnQC9jb21wb25lbnRzL0RheSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sdXRpb25zOiB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0Q2hhbmdlZDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAvLyBTdGFydCB3aXRoIHRoZSBmaXJzdFxuICAgICAgbGV0IGN1cnJlbnQgPSBpbnB1dFswXVxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBUaGVuIHN0ZXB3aXNlIGFkZCB0aGUgb3RoZXIgb250byBpdFxuICAgICAgICBjdXJyZW50ID0gdGhpcy5hZGQoY3VycmVudCwgaW5wdXRbaV0pXG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgdG8gYW4gYXJyYXkgdXNpbmcgdGhlIGNvbnZlbmllbnQgSlNPTi5wYXJzZVxuICAgICAgY29uc3QgYXJyID0gSlNPTi5wYXJzZShjdXJyZW50KVxuICAgICAgLy8gR2V0IHRoZSBtYWduaXR1ZGUgYnkgdHJhdmVyc2luZyB0aGUgdHJlZVxuICAgICAgdGhpcy5zb2x1dGlvbnMucGFydE9uZSA9IHRoaXMubWFnbml0dWRlKGFycilcblxuICAgICAgLy8gRmluZCB0aGUgbWF4aW11bVxuICAgICAgbGV0IG1heCA9IDBcbiAgICAgIC8vIFBhaXJ3aXNlIGNvbXBhcmlzb24gb2YgYWxsIHBhaXJzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5wdXQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAvLyBTa2lwIHNhbWUgb25lc1xuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWFnbml0dWRlXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5tYWduaXR1ZGUoSlNPTi5wYXJzZSh0aGlzLmFkZChpbnB1dFtpXSwgaW5wdXRbal0pKSlcblxuICAgICAgICAgIC8vIFVwZGF0ZSBtYXhpbXVtXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByZXN1bHQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zb2x1dGlvbnMucGFydFR3byA9IG1heFxuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiAob25lLCB0d28pIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgY29uY2F0ZW5hdGVkIGFycmF5XG4gICAgICBsZXQgY3VycmVudCA9IGBbJHtvbmV9LCR7dHdvfV1gXG5cbiAgICAgIC8vIFdoaWxlIHdlIGZvdW5kIHNvbWV0aGluZyB0byBjb21wYWN0XG4gICAgICBsZXQgY29tcGFjdGluZyA9IGZhbHNlXG4gICAgICBkbyB7XG4gICAgICAgIC8vIEV4cGxvZGUgZmlyc3RcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZXhwbG9kZShjdXJyZW50KVxuICAgICAgICBjdXJyZW50ID0gcmVzdWx0WzBdXG4gICAgICAgIGNvbXBhY3RpbmcgPSByZXN1bHRbMV1cblxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gZXhwbG9zaW9uXG4gICAgICAgIGlmICghY29tcGFjdGluZykge1xuICAgICAgICAgIC8vIENoZWNrIGZvciBzcGxpdHNcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLnNwbGl0KGN1cnJlbnQpXG4gICAgICAgICAgY3VycmVudCA9IHJlc3VsdFswXVxuICAgICAgICAgIGNvbXBhY3RpbmcgPSByZXN1bHRbMV1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoY29tcGFjdGluZylcblxuICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uXG4gICAgICByZXR1cm4gY3VycmVudFxuICAgIH0sXG4gICAgbWFnbml0dWRlOiBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgaWYgKGlzTmFOKGN1cnJlbnQpKSB7XG4gICAgICAgIC8vIEZvciBpbnRlcm5hbCBub2RlcywgaXQncyAzIHRpbWVzIGxlZnQgcGx1cyAyIHRpbWVzIHJpZ2h0XG4gICAgICAgIHJldHVybiAzICogdGhpcy5tYWduaXR1ZGUoY3VycmVudFswXSkgKyAyICogdGhpcy5tYWduaXR1ZGUoY3VycmVudFsxXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBsZWFmIG5vZGVzLCBpdCdzIHRoZSB2YWx1ZVxuICAgICAgICByZXR1cm4gY3VycmVudFxuICAgICAgfVxuICAgIH0sXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICBjb25zdCBhcnIgPSBjdXJyZW50LnNwbGl0KCcnKVxuXG4gICAgICAvLyBGaW5kIG51bWJlcnMgdGhhdCBhcmUgbGFyZ2VyIG9yIGVxdWFsIHRvIDEwXG4gICAgICBsZXQgc3RhcnQgPSBudWxsXG4gICAgICBsZXQgZW5kID0gbnVsbFxuICAgICAgbGV0IGlzTnVtYmVyID0gZmFsc2VcbiAgICAgIC8vIEdvIHRocm91Z2ggdGhlIHN0cmluZyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIElmIHdlIGZpbmQgYSBudW1iZXJcbiAgICAgICAgaWYgKCFpc05hTihhcnJbaV0pKSB7XG4gICAgICAgICAgaXNOdW1iZXIgPSB0cnVlXG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0IChsZWZ0IGJvdW5kYXJ5KVxuICAgICAgICAgICAgc3RhcnQgPSBpXG4gICAgICAgICAgICAvLyBTZXQgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGVuZCAocmlnaHQgYm91bmRhcnkpXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihpICsgMSwgYXJyLmxlbmd0aCAtIDEpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZW5kIChyaWdodCBib3VuZGFyeSlcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGkgKyAxLCBhcnIubGVuZ3RoIC0gMSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNOdW1iZXIgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZ290IHRvIHRoZSBlbmRcbiAgICAgICAgaWYgKGkgPT09IGFyci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaXNOdW1iZXIgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UncmUgbm8gbG9uZ2VyIGluIHRoZSBwcm9jZXNzIG9mIHBhcnNpbmcgYSBtdWx0aS1kaWdpdCBudW1iZXIgYW5kIHdlIGZvdW5kIGEgc3RhcnQgYW5kIGFuIGVuZFxuICAgICAgICBpZiAoIWlzTnVtYmVyICYmIHN0YXJ0ICE9PSBudWxsICYmIGVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSBudW1iZXJcbiAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoY3VycmVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpXG5cbiAgICAgICAgICBpZiAobiA+PSAxMCkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyB0b28gbGFyZ2UsIHJlcGxhY2UgaXQgd2l0aCBhbiBhcnJheSBvZiBmbG9vciBhbmQgY2VpbFxuICAgICAgICAgICAgcmV0dXJuIFtgJHtjdXJyZW50LnN1YnN0cmluZygwLCBzdGFydCl9WyR7TWF0aC5mbG9vcihuIC8gMi4wKX0sJHtNYXRoLmNlaWwobiAvIDIuMCl9XSR7Y3VycmVudC5zdWJzdHJpbmcoZW5kLCBjdXJyZW50Lmxlbmd0aCl9YCwgdHJ1ZV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgaXQncyB0b28gc21hbGwsIGNvbnRpbnVlIHNlYXJjaGluZ1xuICAgICAgICAgICAgc3RhcnQgPSBudWxsXG4gICAgICAgICAgICBlbmQgPSBudWxsXG4gICAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluZGljYXRlIHdlIGRpZG4ndCBzcGxpdFxuICAgICAgcmV0dXJuIFtjdXJyZW50LCBmYWxzZV1cbiAgICB9LFxuICAgIGV4cGxvZGU6IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICBjb25zdCBhcnIgPSBjdXJyZW50LnNwbGl0KCcnKVxuXG4gICAgICAvLyBDb3VudCB0aGUgbGV2ZWwgYnkga2VlcGluZyB0cmFjayBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGJyYWNrZXRzXG4gICAgICBsZXQgb3BlbkNvdW50ID0gMFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gJ1snKSB7XG4gICAgICAgICAgb3BlbkNvdW50KytcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyW2ldID09PSAnXScpIHtcbiAgICAgICAgICBvcGVuQ291bnQtLVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZm91bmQgb25lIHRoYXQncyBcInRvbyBkZWVwXCJcbiAgICAgICAgaWYgKG9wZW5Db3VudCA+IDQpIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIGVuZCBpbmRleFxuICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY3VycmVudC5pbmRleE9mKCddJywgaSlcbiAgICAgICAgICAvLyBQYXJzZSB0aGUgbnVtYmVyIHBhaXJcbiAgICAgICAgICBjb25zdCBwYWlyID0gY3VycmVudC5zdWJzdHJpbmcoaSArIDEsIGVuZEluZGV4KS5zcGxpdCgnLCcpLm1hcChjID0+ICtjKVxuICAgICAgICAgIC8vIEdldCB0aGUgbGVmdCBhbmQgdGhlIHJpZ2h0IHN1YnN0cmluZ3MgZm9yIGxhdGVyXG4gICAgICAgICAgbGV0IGxlZnQgPSBjdXJyZW50LnN1YnN0cmluZygwLCBpKVxuICAgICAgICAgIGxldCByaWdodCA9IGN1cnJlbnQuc3Vic3RyaW5nKGVuZEluZGV4ICsgMSlcblxuICAgICAgICAgIC8vIEdvIGZyb20gdGhlIGZvdW5kIGluZGV4IHRvd2FyZHMgdGhlIGxlZnQgdG8gZmluZCB0aGUgZmlyc3QgbnVtYmVyIGFuZCBpbmNyZWFzZSBpdFxuICAgICAgICAgIGxldCBzdGFydCA9IG51bGxcbiAgICAgICAgICBsZXQgZW5kID0gbnVsbFxuICAgICAgICAgIGxldCBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgY29uc3QgbGVmdEFyciA9IGxlZnQuc3BsaXQoJycpXG4gICAgICAgICAgZm9yIChsZXQgbCA9IGxlZnRBcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4obGVmdEFycltsXSkpIHtcbiAgICAgICAgICAgICAgaXNOdW1iZXIgPSB0cnVlXG4gICAgICAgICAgICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCB0aGUgcmlnaHQgYm9yZGVyXG4gICAgICAgICAgICAgICAgZW5kID0gbFxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIGxlZnQgYm9yZGVyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBsIC0gMSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxlZnQgYm9yZGVyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBsIC0gMSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNOdW1iZXIgPSBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vIGxvbmdlciBpbiB0aGUgcHJvY2VzcyBvZiBwYXJzaW5nIGEgbXVsdGktZGlnaXQgbnVtYmVyIGFuZCB3ZSBmb3VuZCBhIHN0YXJ0IGFuZCBhbiBlbmRcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIgJiYgc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVmdCBzaWRlIGJ5IGluY3JlYXNpbmcgdGhlIG51bWJlciB2YWx1ZVxuICAgICAgICAgICAgICBsZWZ0ID0gYCR7bGVmdC5zdWJzdHJpbmcoMCwgc3RhcnQgKyAxKX0ke3BhcnNlSW50KGxlZnQuc3Vic3RyaW5nKHN0YXJ0ICsgMSwgZW5kICsgMSkpICsgcGFpclswXX0ke2xlZnQuc3Vic3RyaW5nKGVuZCArIDEsIGxlZnQubGVuZ3RoKX1gXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnQgPSBudWxsXG4gICAgICAgICAgZW5kID0gbnVsbFxuICAgICAgICAgIGlzTnVtYmVyID0gZmFsc2VcbiAgICAgICAgICBjb25zdCByaWdodEFyciA9IHJpZ2h0LnNwbGl0KCcnKVxuICAgICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgcmlnaHRBcnIubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocmlnaHRBcnJbcl0pKSB7XG4gICAgICAgICAgICAgIGlzTnVtYmVyID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCB0aGUgbGVmdCBib3JkZXJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSBsZWZ0IGJvcmRlclxuICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKHJpZ2h0QXJyLmxlbmd0aCAtIDEsIHIgKyAxKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVmdCBib3JkZXJcbiAgICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihyaWdodEFyci5sZW5ndGggLSAxLCByICsgMSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNOdW1iZXIgPSBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAociA9PT0gcmlnaHRBcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpc051bWJlciA9IGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vIGxvbmdlciBpbiB0aGUgcHJvY2VzcyBvZiBwYXJzaW5nIGEgbXVsdGktZGlnaXQgbnVtYmVyIGFuZCB3ZSBmb3VuZCBhIHN0YXJ0IGFuZCBhbiBlbmRcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIgJiYgc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmlnaHQgc2lkZSBieSBpbmNyZWFzaW5nIHRoZSBudW1iZXIgdmFsdWVcbiAgICAgICAgICAgICAgcmlnaHQgPSBgJHtyaWdodC5zdWJzdHJpbmcoMCwgc3RhcnQpfSR7cGFyc2VJbnQocmlnaHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKSArIHBhaXJbMV19JHtyaWdodC5zdWJzdHJpbmcoZW5kLCByaWdodC5sZW5ndGgpfWBcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWNvbnN0aXR1dGUgdGhlIHdob2xlIHN0cmluZyBieSBzZXR0aW5nIGEgemVybyBpbiB0aGUgbWlkZGxlXG4gICAgICAgICAgY3VycmVudCA9IGAke2xlZnR9MCR7cmlnaHR9YFxuXG4gICAgICAgICAgLy8gSW5kaWNhdGUgd2UgZXhwbG9kZWRcbiAgICAgICAgICByZXR1cm4gW2N1cnJlbnQsIHRydWVdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5kaWNhdGUgd2UgZGlkbid0IGV4cGxvZGVcbiAgICAgIHJldHVybiBbY3VycmVudCwgZmFsc2VdXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwWzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTE4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MFswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxOC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0RheTE4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00ODUwNzE1ZSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkxOC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0RheTE4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNDg1MDcxNWVcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOlsiY29tcG9uZW50cyIsIkRheSIsImRhdGEiLCJzb2x1dGlvbnMiLCJwYXJ0T25lIiwicGFydFR3byIsIm1ldGhvZHMiLCJvbklucHV0Q2hhbmdlZCIsImN1cnJlbnQiLCJtYXgiLCJhZGQiLCJjb21wYWN0aW5nIiwicmVzdWx0IiwibWFnbml0dWRlIiwic3BsaXQiLCJpc051bWJlciIsInN0YXJ0IiwiZW5kIiwiZXhwbG9kZSIsIm9wZW5Db3VudCIsImxlZnQiLCJyaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31125\n')},21249:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("\nvar $ = __webpack_require__(82109);\nvar $map = (__webpack_require__(42092).map);\nvar arrayMethodHasSpeciesSupport = __webpack_require__(81194);\nvar arrayMethodUsesToLength = __webpack_require__(29207);\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n// FF49- issue\nvar USES_TO_LENGTH = arrayMethodUsesToLength('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEyNDkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLG1CQUFPLENBQUMsS0FBcUI7QUFDckMsV0FBVyxnQ0FBMkM7QUFDdEQsbUNBQW1DLG1CQUFPLENBQUMsS0FBK0M7QUFDMUYsOEJBQThCLG1CQUFPLENBQUMsS0FBMEM7O0FBRWhGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtFQUErRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcz8zZmUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykubWFwO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdtYXAnKTtcbi8vIEZGNDktIGlzc3VlXG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnbWFwJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIHx8ICFVU0VTX1RPX0xFTkdUSCB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21249\n")}}]);