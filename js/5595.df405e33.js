"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[5595],{80520:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day12)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day12.vue?vue&type=template&id=36abffa0&scoped=true\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":12,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day12.vue?vue&type=script&lang=js\n//\n//\n//\n//\n\n/* eslint-disable new-cap */\n\n// import { createColorGradient } from '@/util/color'\n\n/* harmony default export */ const Day12vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Keep trackk of (source -> [targets])\n      const nodeToNeighbor = new Map();\n\n      // Parse the input\n      input.forEach(i => {\n        const [source, target] = i.split('-');\n        let sourceNeighbors = nodeToNeighbor.get(source);\n        let targetNeighbors = nodeToNeighbor.get(target);\n        if (!sourceNeighbors) {\n          sourceNeighbors = [];\n        }\n        if (!targetNeighbors) {\n          targetNeighbors = [];\n        }\n        if (sourceNeighbors.indexOf(target) === -1) {\n          sourceNeighbors.push(target);\n        }\n        if (targetNeighbors.indexOf(source) === -1) {\n          targetNeighbors.push(source);\n        }\n        nodeToNeighbor.set(source, sourceNeighbors);\n        nodeToNeighbor.set(target, targetNeighbors);\n      });\n      const pathsPartOne = this.findAllPaths(nodeToNeighbor);\n      this.solutions.partOne = pathsPartOne.size;\n      const pathsPartTwo = this.findAllPathsWithMultiples(nodeToNeighbor);\n      this.solutions.partTwo = pathsPartTwo.size;\n      this.$nextTick(() => this.drawGraph(nodeToNeighbor, this.$refs.partOne, pathsPartOne));\n      this.$nextTick(() => this.drawGraph(nodeToNeighbor, this.$refs.partTwo, pathsPartTwo));\n    },\n    drawGraph: function (nodeToNeighbor, element, paths) {\n      // const nodeCount = new Map()\n\n      // console.log(paths)\n\n      // let min = 0\n      // let max = 0\n      // paths.forEach(p => p.split(',').forEach(l => {\n      //   if (!nodeCount.has(l)) {\n      //     nodeCount.set(l, 0)\n      //   }\n      //   const count = nodeCount.get(l) + 1\n      //   nodeCount.set(l, count)\n\n      //   min = Math.min(min, count)\n      //   max = Math.max(max, count)\n      // }))\n\n      // const g = new dagreD3.graphlib.Graph().setGraph({})\n\n      // const nodes = []\n      // const edges = new Set()\n\n      // const gradient = createColorGradient('#C4E538', '#006266', max - min + 1)\n\n      // console.log(nodeCount)\n\n      // nodeToNeighbor.forEach((v, k) => nodes.push({\n      //   label: k,\n      //   shape: 'circle',\n      //   style: `stroke: black; fill: ${nodeCount.has(k) ? gradient[nodeCount.get(k) - min] : 'white'};`,\n      //   labelStyle: `font-size: ${k === k.toLowerCase() ? 1 : 2}em`\n      // }))\n      // nodeToNeighbor.forEach((v, k) => v.forEach(t => {\n      //   const arr = [k, t]\n      //   arr.sort((a, b) => {\n      //     if (a === 'start' || b === 'end') {\n      //       return -1\n      //     } else if (b === 'start' || a === 'end') {\n      //       return 1\n      //     } else {\n      //       return a.localeCompare(b)\n      //     }\n      //   })\n      //   edges.add(`${arr[0]},${arr[1]}`)\n      // }))\n\n      // nodes.sort((a, b) => {\n      //   if (a.label === 'start' || b.label === 'end') {\n      //     return -1\n      //   } else if (b.label === 'start' || a.label === 'end') {\n      //     return 1\n      //   } else {\n      //     return a.label.localeCompare(b.label)\n      //   }\n      // })\n\n      // nodes.forEach(n => g.setNode(n.label, n))\n      // edges.forEach(e => {\n      //   const [source, target] = e.split(',')\n      //   g.setEdge(source, target, {\n      //     style: 'stroke: black; fill: none;',\n      //     arrowhead: 'undirected'\n      //   })\n      // })\n\n      // const render = new dagreD3.render()\n\n      // const svg = d3Select.select(element)\n      // const svgGroup = svg.append('g')\n\n      // // Run the renderer. This is what draws the final graph.\n      // render(svgGroup, g)\n\n      // // Center the graph\n      // const xCenterOffset = (svg.attr('width') - g.graph().width) / 2\n      // svgGroup.attr('transform', 'translate(' + xCenterOffset + ', 20)')\n      // svg.attr('height', g.graph().height + 40)\n    },\n    findAllPaths: function (nodeToNeighbor) {\n      const source = 'start';\n\n      // Keep track of all found paths. Use a set to ignore multiples found in part 2\n      const paths = new Set();\n      // Find them by recursive DFS from the start\n      this.recurse(source, nodeToNeighbor, null, [], [], paths);\n      return paths;\n    },\n    findAllPathsWithMultiples: function (nodeToNeighbor) {\n      const source = 'start';\n\n      // Keep track of all found paths. Use a set to ignore multiples found in part 2\n      const paths = new Set();\n\n      // Get all lowercase caves\n      // Find the paths by recursive DFS from the start allowing this single cave to appear multiple times\n      Array.from(nodeToNeighbor.keys()).filter(k => k !== 'start' && k !== 'end' && k.toLowerCase() === k).forEach(l => this.recurse(source, nodeToNeighbor, l, [], [], paths));\n      return paths;\n    },\n    recurse: function (current, nodeToNeighbor, multiple, visitedNodes, path, paths) {\n      // Remember we visited this one\n      visitedNodes.push(current);\n      // Add it to the path\n      path.push(current);\n      if (current === 'end') {\n        // If we reached the end, return the path\n        paths.add(path.join(','));\n        return;\n      }\n\n      // Count how often we've visited the small cave we can visit twice\n      const multipleCount = path.filter(p => p === multiple).length;\n      // For each neighbor\n      nodeToNeighbor.get(current)\n      // Filter out visited notes unless they are upper case or it's the one we can visit twice and we haven't yet\n      .filter(n => n !== 'start' && (n === multiple && multipleCount < 2 || n === n.toUpperCase() || visitedNodes.indexOf(n) === -1))\n      // DFS into them\n      .forEach(n => this.recurse(n, nodeToNeighbor, multiple, visitedNodes.concat(), path.concat(), paths));\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2021/Day12.vue?vue&type=script&lang=js\n /* harmony default export */ const _2021_Day12vue_type_script_lang_js = (Day12vue_type_script_lang_js); \n;// CONCATENATED MODULE: ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-12.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day12.vue?vue&type=style&index=0&id=36abffa0&prod&scoped=true&lang=css\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./src/components/2021/Day12.vue?vue&type=style&index=0&id=36abffa0&prod&scoped=true&lang=css\n\n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2021/Day12.vue\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2021_Day12vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"36abffa0\",\n  null\n  \n)\n\n/* harmony default export */ const Day12 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA1MjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxvQ0FBb0M7QUFDek07Ozs7Ozs7Ozs7O0FDSUE7QUFDQTtBQUNBOztBQUVBLG1FQUFlO0VBQ2ZBO0lBQ0FDLEdBQUFBLEVBQUFBLGtCQUFBQTtFQUNBO0VBQ0FDO0lBQ0E7TUFDQUM7UUFDQUM7UUFDQUM7TUFDQTtJQUNBO0VBQ0E7RUFDQUM7SUFDQUM7TUFDQTtNQUNBOztNQUVBO01BQ0FDO1FBQ0E7UUFFQTtRQUNBO1FBRUE7VUFDQUM7UUFDQTtRQUNBO1VBQ0FDO1FBQ0E7UUFFQTtVQUNBRDtRQUNBO1FBQ0E7VUFDQUM7UUFDQTtRQUVBQztRQUNBQTtNQUNBO01BRUE7TUFDQTtNQUNBO01BQ0E7TUFFQTtNQUNBO0lBQ0E7SUFDQUM7TUFDQTs7TUFFQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztNQUVBO01BQ0E7TUFDQTs7TUFFQTs7TUFFQTtNQUNBOztNQUVBOztNQUVBOztNQUVBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztNQUVBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztNQUVBOztNQUVBO01BQ0E7O01BRUE7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtJQUFBLENBQ0E7SUFDQUM7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTtNQUVBO0lBQ0E7SUFDQUM7TUFDQTs7TUFFQTtNQUNBOztNQUVBO01BQ0E7TUFDQUMscUdBQ0FDO01BRUE7SUFDQTtJQUNBQztNQUNBO01BQ0FDO01BQ0E7TUFDQUM7TUFFQTtRQUNBO1FBQ0FDO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQVQ7TUFDQTtNQUFBLENBQ0FVO01BQ0E7TUFBQSxDQUNBTDtJQUNBO0VBQ0E7QUFDQSxDQUFDLEU7O0FDdkwyUCxDQUFDLHlFQUFlLDRCQUFHLEVBQUMsQzs7QUNBaFI7Ozs7Ozs7QUVBK0Y7QUFDdkM7QUFDTDtBQUNuRCxDQUE2Rjs7O0FBRzdGO0FBQ3NHO0FBQ3RHLGdCQUFnQixzQ0FBVTtBQUMxQixFQUFFLGtDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxMi52dWU/OGI3MSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS9zcmMvY29tcG9uZW50cy8yMDIxL0RheTEyLnZ1ZT9mNjUxIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxMi52dWU/ZTdhZCIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjEvRGF5MTIudnVlPzQ5NmMiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIxL0RheTEyLnZ1ZT8wZTQ3Iiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXkxMi52dWU/ZDY3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnRGF5Jyx7YXR0cnM6e1wiZGF5XCI6MTIsXCJ5ZWFyXCI6MjAyMSxcInNvbHV0aW9uc1wiOl92bS5zb2x1dGlvbnN9LG9uOntcImlucHV0LWNoYW5nZWRcIjpfdm0ub25JbnB1dENoYW5nZWR9fSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPERheSA6ZGF5PVwiMTJcIiA6eWVhcj1cIjIwMjFcIiA6c29sdXRpb25zPVwic29sdXRpb25zXCIgQGlucHV0LWNoYW5nZWQ9XCJvbklucHV0Q2hhbmdlZFwiIC8+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuaW1wb3J0IERheSBmcm9tICdAL2NvbXBvbmVudHMvRGF5J1xuLy8gaW1wb3J0IHsgY3JlYXRlQ29sb3JHcmFkaWVudCB9IGZyb20gJ0AvdXRpbC9jb2xvcidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sdXRpb25zOiB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbklucHV0Q2hhbmdlZDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAvLyBLZWVwIHRyYWNrayBvZiAoc291cmNlIC0+IFt0YXJnZXRzXSlcbiAgICAgIGNvbnN0IG5vZGVUb05laWdoYm9yID0gbmV3IE1hcCgpXG5cbiAgICAgIC8vIFBhcnNlIHRoZSBpbnB1dFxuICAgICAgaW5wdXQuZm9yRWFjaChpID0+IHtcbiAgICAgICAgY29uc3QgW3NvdXJjZSwgdGFyZ2V0XSA9IGkuc3BsaXQoJy0nKVxuXG4gICAgICAgIGxldCBzb3VyY2VOZWlnaGJvcnMgPSBub2RlVG9OZWlnaGJvci5nZXQoc291cmNlKVxuICAgICAgICBsZXQgdGFyZ2V0TmVpZ2hib3JzID0gbm9kZVRvTmVpZ2hib3IuZ2V0KHRhcmdldClcblxuICAgICAgICBpZiAoIXNvdXJjZU5laWdoYm9ycykge1xuICAgICAgICAgIHNvdXJjZU5laWdoYm9ycyA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXJnZXROZWlnaGJvcnMpIHtcbiAgICAgICAgICB0YXJnZXROZWlnaGJvcnMgPSBbXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZU5laWdoYm9ycy5pbmRleE9mKHRhcmdldCkgPT09IC0xKSB7XG4gICAgICAgICAgc291cmNlTmVpZ2hib3JzLnB1c2godGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXROZWlnaGJvcnMuaW5kZXhPZihzb3VyY2UpID09PSAtMSkge1xuICAgICAgICAgIHRhcmdldE5laWdoYm9ycy5wdXNoKHNvdXJjZSlcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVUb05laWdoYm9yLnNldChzb3VyY2UsIHNvdXJjZU5laWdoYm9ycylcbiAgICAgICAgbm9kZVRvTmVpZ2hib3Iuc2V0KHRhcmdldCwgdGFyZ2V0TmVpZ2hib3JzKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgcGF0aHNQYXJ0T25lID0gdGhpcy5maW5kQWxsUGF0aHMobm9kZVRvTmVpZ2hib3IpXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gcGF0aHNQYXJ0T25lLnNpemVcbiAgICAgIGNvbnN0IHBhdGhzUGFydFR3byA9IHRoaXMuZmluZEFsbFBhdGhzV2l0aE11bHRpcGxlcyhub2RlVG9OZWlnaGJvcilcbiAgICAgIHRoaXMuc29sdXRpb25zLnBhcnRUd28gPSBwYXRoc1BhcnRUd28uc2l6ZVxuXG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB0aGlzLmRyYXdHcmFwaChub2RlVG9OZWlnaGJvciwgdGhpcy4kcmVmcy5wYXJ0T25lLCBwYXRoc1BhcnRPbmUpKVxuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gdGhpcy5kcmF3R3JhcGgobm9kZVRvTmVpZ2hib3IsIHRoaXMuJHJlZnMucGFydFR3bywgcGF0aHNQYXJ0VHdvKSlcbiAgICB9LFxuICAgIGRyYXdHcmFwaDogZnVuY3Rpb24gKG5vZGVUb05laWdoYm9yLCBlbGVtZW50LCBwYXRocykge1xuICAgICAgLy8gY29uc3Qgbm9kZUNvdW50ID0gbmV3IE1hcCgpXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKHBhdGhzKVxuXG4gICAgICAvLyBsZXQgbWluID0gMFxuICAgICAgLy8gbGV0IG1heCA9IDBcbiAgICAgIC8vIHBhdGhzLmZvckVhY2gocCA9PiBwLnNwbGl0KCcsJykuZm9yRWFjaChsID0+IHtcbiAgICAgIC8vICAgaWYgKCFub2RlQ291bnQuaGFzKGwpKSB7XG4gICAgICAvLyAgICAgbm9kZUNvdW50LnNldChsLCAwKVxuICAgICAgLy8gICB9XG4gICAgICAvLyAgIGNvbnN0IGNvdW50ID0gbm9kZUNvdW50LmdldChsKSArIDFcbiAgICAgIC8vICAgbm9kZUNvdW50LnNldChsLCBjb3VudClcblxuICAgICAgLy8gICBtaW4gPSBNYXRoLm1pbihtaW4sIGNvdW50KVxuICAgICAgLy8gICBtYXggPSBNYXRoLm1heChtYXgsIGNvdW50KVxuICAgICAgLy8gfSkpXG5cbiAgICAgIC8vIGNvbnN0IGcgPSBuZXcgZGFncmVEMy5ncmFwaGxpYi5HcmFwaCgpLnNldEdyYXBoKHt9KVxuXG4gICAgICAvLyBjb25zdCBub2RlcyA9IFtdXG4gICAgICAvLyBjb25zdCBlZGdlcyA9IG5ldyBTZXQoKVxuXG4gICAgICAvLyBjb25zdCBncmFkaWVudCA9IGNyZWF0ZUNvbG9yR3JhZGllbnQoJyNDNEU1MzgnLCAnIzAwNjI2NicsIG1heCAtIG1pbiArIDEpXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKG5vZGVDb3VudClcblxuICAgICAgLy8gbm9kZVRvTmVpZ2hib3IuZm9yRWFjaCgodiwgaykgPT4gbm9kZXMucHVzaCh7XG4gICAgICAvLyAgIGxhYmVsOiBrLFxuICAgICAgLy8gICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAvLyAgIHN0eWxlOiBgc3Ryb2tlOiBibGFjazsgZmlsbDogJHtub2RlQ291bnQuaGFzKGspID8gZ3JhZGllbnRbbm9kZUNvdW50LmdldChrKSAtIG1pbl0gOiAnd2hpdGUnfTtgLFxuICAgICAgLy8gICBsYWJlbFN0eWxlOiBgZm9udC1zaXplOiAke2sgPT09IGsudG9Mb3dlckNhc2UoKSA/IDEgOiAyfWVtYFxuICAgICAgLy8gfSkpXG4gICAgICAvLyBub2RlVG9OZWlnaGJvci5mb3JFYWNoKCh2LCBrKSA9PiB2LmZvckVhY2godCA9PiB7XG4gICAgICAvLyAgIGNvbnN0IGFyciA9IFtrLCB0XVxuICAgICAgLy8gICBhcnIuc29ydCgoYSwgYikgPT4ge1xuICAgICAgLy8gICAgIGlmIChhID09PSAnc3RhcnQnIHx8IGIgPT09ICdlbmQnKSB7XG4gICAgICAvLyAgICAgICByZXR1cm4gLTFcbiAgICAgIC8vICAgICB9IGVsc2UgaWYgKGIgPT09ICdzdGFydCcgfHwgYSA9PT0gJ2VuZCcpIHtcbiAgICAgIC8vICAgICAgIHJldHVybiAxXG4gICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgIC8vICAgICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYilcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH0pXG4gICAgICAvLyAgIGVkZ2VzLmFkZChgJHthcnJbMF19LCR7YXJyWzFdfWApXG4gICAgICAvLyB9KSlcblxuICAgICAgLy8gbm9kZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgLy8gICBpZiAoYS5sYWJlbCA9PT0gJ3N0YXJ0JyB8fCBiLmxhYmVsID09PSAnZW5kJykge1xuICAgICAgLy8gICAgIHJldHVybiAtMVxuICAgICAgLy8gICB9IGVsc2UgaWYgKGIubGFiZWwgPT09ICdzdGFydCcgfHwgYS5sYWJlbCA9PT0gJ2VuZCcpIHtcbiAgICAgIC8vICAgICByZXR1cm4gMVxuICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgLy8gICAgIHJldHVybiBhLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5sYWJlbClcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSlcblxuICAgICAgLy8gbm9kZXMuZm9yRWFjaChuID0+IGcuc2V0Tm9kZShuLmxhYmVsLCBuKSlcbiAgICAgIC8vIGVkZ2VzLmZvckVhY2goZSA9PiB7XG4gICAgICAvLyAgIGNvbnN0IFtzb3VyY2UsIHRhcmdldF0gPSBlLnNwbGl0KCcsJylcbiAgICAgIC8vICAgZy5zZXRFZGdlKHNvdXJjZSwgdGFyZ2V0LCB7XG4gICAgICAvLyAgICAgc3R5bGU6ICdzdHJva2U6IGJsYWNrOyBmaWxsOiBub25lOycsXG4gICAgICAvLyAgICAgYXJyb3doZWFkOiAndW5kaXJlY3RlZCdcbiAgICAgIC8vICAgfSlcbiAgICAgIC8vIH0pXG5cbiAgICAgIC8vIGNvbnN0IHJlbmRlciA9IG5ldyBkYWdyZUQzLnJlbmRlcigpXG5cbiAgICAgIC8vIGNvbnN0IHN2ZyA9IGQzU2VsZWN0LnNlbGVjdChlbGVtZW50KVxuICAgICAgLy8gY29uc3Qgc3ZnR3JvdXAgPSBzdmcuYXBwZW5kKCdnJylcblxuICAgICAgLy8gLy8gUnVuIHRoZSByZW5kZXJlci4gVGhpcyBpcyB3aGF0IGRyYXdzIHRoZSBmaW5hbCBncmFwaC5cbiAgICAgIC8vIHJlbmRlcihzdmdHcm91cCwgZylcblxuICAgICAgLy8gLy8gQ2VudGVyIHRoZSBncmFwaFxuICAgICAgLy8gY29uc3QgeENlbnRlck9mZnNldCA9IChzdmcuYXR0cignd2lkdGgnKSAtIGcuZ3JhcGgoKS53aWR0aCkgLyAyXG4gICAgICAvLyBzdmdHcm91cC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4Q2VudGVyT2Zmc2V0ICsgJywgMjApJylcbiAgICAgIC8vIHN2Zy5hdHRyKCdoZWlnaHQnLCBnLmdyYXBoKCkuaGVpZ2h0ICsgNDApXG4gICAgfSxcbiAgICBmaW5kQWxsUGF0aHM6IGZ1bmN0aW9uIChub2RlVG9OZWlnaGJvcikge1xuICAgICAgY29uc3Qgc291cmNlID0gJ3N0YXJ0J1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBmb3VuZCBwYXRocy4gVXNlIGEgc2V0IHRvIGlnbm9yZSBtdWx0aXBsZXMgZm91bmQgaW4gcGFydCAyXG4gICAgICBjb25zdCBwYXRocyA9IG5ldyBTZXQoKVxuICAgICAgLy8gRmluZCB0aGVtIGJ5IHJlY3Vyc2l2ZSBERlMgZnJvbSB0aGUgc3RhcnRcbiAgICAgIHRoaXMucmVjdXJzZShzb3VyY2UsIG5vZGVUb05laWdoYm9yLCBudWxsLCBbXSwgW10sIHBhdGhzKVxuXG4gICAgICByZXR1cm4gcGF0aHNcbiAgICB9LFxuICAgIGZpbmRBbGxQYXRoc1dpdGhNdWx0aXBsZXM6IGZ1bmN0aW9uIChub2RlVG9OZWlnaGJvcikge1xuICAgICAgY29uc3Qgc291cmNlID0gJ3N0YXJ0J1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBmb3VuZCBwYXRocy4gVXNlIGEgc2V0IHRvIGlnbm9yZSBtdWx0aXBsZXMgZm91bmQgaW4gcGFydCAyXG4gICAgICBjb25zdCBwYXRocyA9IG5ldyBTZXQoKVxuXG4gICAgICAvLyBHZXQgYWxsIGxvd2VyY2FzZSBjYXZlc1xuICAgICAgLy8gRmluZCB0aGUgcGF0aHMgYnkgcmVjdXJzaXZlIERGUyBmcm9tIHRoZSBzdGFydCBhbGxvd2luZyB0aGlzIHNpbmdsZSBjYXZlIHRvIGFwcGVhciBtdWx0aXBsZSB0aW1lc1xuICAgICAgQXJyYXkuZnJvbShub2RlVG9OZWlnaGJvci5rZXlzKCkpLmZpbHRlcihrID0+IGsgIT09ICdzdGFydCcgJiYgayAhPT0gJ2VuZCcgJiYgay50b0xvd2VyQ2FzZSgpID09PSBrKVxuICAgICAgICAuZm9yRWFjaChsID0+IHRoaXMucmVjdXJzZShzb3VyY2UsIG5vZGVUb05laWdoYm9yLCBsLCBbXSwgW10sIHBhdGhzKSlcblxuICAgICAgcmV0dXJuIHBhdGhzXG4gICAgfSxcbiAgICByZWN1cnNlOiBmdW5jdGlvbiAoY3VycmVudCwgbm9kZVRvTmVpZ2hib3IsIG11bHRpcGxlLCB2aXNpdGVkTm9kZXMsIHBhdGgsIHBhdGhzKSB7XG4gICAgICAvLyBSZW1lbWJlciB3ZSB2aXNpdGVkIHRoaXMgb25lXG4gICAgICB2aXNpdGVkTm9kZXMucHVzaChjdXJyZW50KVxuICAgICAgLy8gQWRkIGl0IHRvIHRoZSBwYXRoXG4gICAgICBwYXRoLnB1c2goY3VycmVudClcblxuICAgICAgaWYgKGN1cnJlbnQgPT09ICdlbmQnKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIGVuZCwgcmV0dXJuIHRoZSBwYXRoXG4gICAgICAgIHBhdGhzLmFkZChwYXRoLmpvaW4oJywnKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIENvdW50IGhvdyBvZnRlbiB3ZSd2ZSB2aXNpdGVkIHRoZSBzbWFsbCBjYXZlIHdlIGNhbiB2aXNpdCB0d2ljZVxuICAgICAgY29uc3QgbXVsdGlwbGVDb3VudCA9IHBhdGguZmlsdGVyKHAgPT4gcCA9PT0gbXVsdGlwbGUpLmxlbmd0aFxuICAgICAgLy8gRm9yIGVhY2ggbmVpZ2hib3JcbiAgICAgIG5vZGVUb05laWdoYm9yLmdldChjdXJyZW50KVxuICAgICAgICAvLyBGaWx0ZXIgb3V0IHZpc2l0ZWQgbm90ZXMgdW5sZXNzIHRoZXkgYXJlIHVwcGVyIGNhc2Ugb3IgaXQncyB0aGUgb25lIHdlIGNhbiB2aXNpdCB0d2ljZSBhbmQgd2UgaGF2ZW4ndCB5ZXRcbiAgICAgICAgLmZpbHRlcihuID0+IG4gIT09ICdzdGFydCcgJiYgKChuID09PSBtdWx0aXBsZSAmJiBtdWx0aXBsZUNvdW50IDwgMikgfHwgbiA9PT0gbi50b1VwcGVyQ2FzZSgpIHx8IHZpc2l0ZWROb2Rlcy5pbmRleE9mKG4pID09PSAtMSkpXG4gICAgICAgIC8vIERGUyBpbnRvIHRoZW1cbiAgICAgICAgLmZvckVhY2gobiA9PiB0aGlzLnJlY3Vyc2Uobiwgbm9kZVRvTmVpZ2hib3IsIG11bHRpcGxlLCB2aXNpdGVkTm9kZXMuY29uY2F0KCksIHBhdGguY29uY2F0KCksIHBhdGhzKSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuLnN2Zy1ob2xkZXIge1xuICBvdmVyZmxvdzogYXV0bztcbiAgaGVpZ2h0OiA1MDBweDtcbiAgd2lkdGg6IDEwMCU7XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxMi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxMi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/Y2xvbmVkUnVsZVNldC0xMi51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MTIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MzZhYmZmYTAmcHJvZCZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9EYXkxMi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzZhYmZmYTAmc2NvcGVkPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkxMi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5MTIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vRGF5MTIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MzZhYmZmYTAmcHJvZCZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIzNmFiZmZhMFwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6WyJjb21wb25lbnRzIiwiRGF5IiwiZGF0YSIsInNvbHV0aW9ucyIsInBhcnRPbmUiLCJwYXJ0VHdvIiwibWV0aG9kcyIsIm9uSW5wdXRDaGFuZ2VkIiwiaW5wdXQiLCJzb3VyY2VOZWlnaGJvcnMiLCJ0YXJnZXROZWlnaGJvcnMiLCJub2RlVG9OZWlnaGJvciIsImRyYXdHcmFwaCIsImZpbmRBbGxQYXRocyIsImZpbmRBbGxQYXRoc1dpdGhNdWx0aXBsZXMiLCJBcnJheSIsImZvckVhY2giLCJyZWN1cnNlIiwidmlzaXRlZE5vZGVzIiwicGF0aCIsInBhdGhzIiwiZmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///80520\n")}}]);