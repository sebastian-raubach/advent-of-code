{"version":3,"file":"js/3713.9ef9264d.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCOtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAP,eAAAA,SAAAA,GACA,+DACAQ,EAAAA,QACAA,EAAAA,QACA,sBACA,wBACA,mCACA,aAEA,OACAC,YACAC,SACA,IAGA,oBACA,mBACA,EACAC,MAAAA,SAAAA,GACA,QAGA,0BAEA,sBAEA,mBAEA,sBAEAC,IACAC,EAAAA,SAAAA,GAEA,mCACAA,EAAAA,MAAAA,GAIA,mBAGA,8BAEA,kCAEA,mJAIAC,EAAAA,QAFA,eAKAA,CAEA,CAGAC,EAAAA,EAAAA,QACA,CAGA,QACA,4BACA,YACA,OACAC,GAAAA,EAEA,CAEA,QACA,EACAC,aAAAA,WACA,qCACA,EACAC,aAAAA,WAQA,WAEA,QAEA,IAEA,0CAEA,wBAEAC,EAAAA,KAAAA,EAAAA,GAEAC,EAAAA,EAGA,aACAD,EAAAA,OAEA,CAIA,wDACA,IC9H6P,I,UCOzPE,GAAY,OACd,EACA/B,EACAW,GACA,EACA,KACA,KACA,MAIF,EAAeoB,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2018/Day12.vue?7618","webpack://advent-of-code/src/components/2018/Day12.vue","webpack://advent-of-code/./src/components/2018/Day12.vue?d9ba","webpack://advent-of-code/./src/components/2018/Day12.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":12,\"year\":2018,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"12\" :year=\"2018\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.startGrid = input[0].split(': ')[1].split('').map(c => c === '#')\n      input.shift()\n      input.shift()\n      this.rules = input.map(r => {\n        const parts = r.split(' => ')\n        const positions = parts[0].split('').map(c => c === '#')\n        const result = parts[1] === '#'\n\n        return {\n          positions,\n          result\n        }\n      })\n\n      this.solvePartOne()\n      this.solvePartTwo()\n    },\n    solve: function (generations) {\n      let startIndex = 0\n\n      // Take a copy as the previous grid\n      let prevGrid = this.startGrid.concat()\n      // For each generation\n      for (let gen = 1; gen <= generations; gen++) {\n        // Take a copy to store the new values\n        const tempGrid = prevGrid.concat()\n        // Pad them with '.'/false if necessary\n        while (tempGrid.indexOf(true) < 5) {\n          // Adjust the start index so we know where the original 0 index is\n          startIndex++\n          tempGrid.unshift(false)\n        }\n        while (tempGrid.lastIndexOf(true) > tempGrid.length - 6) {\n          tempGrid.push(false)\n        }\n\n        // Store the result\n        const targetGrid = tempGrid.concat()\n\n        // Go through all positions\n        for (let pos = 2; pos < tempGrid.length - 3; pos++) {\n          // Get the important positions\n          const [ll, l, c, r, rr] = tempGrid.slice(pos - 2, pos + 3)\n          // Find the rule that matches\n          const newValue = this.rules.filter(rule => rule.positions[0] === ll && rule.positions[1] === l && rule.positions[2] === c && rule.positions[3] === r && rule.positions[4] === rr).map(r => r.result)[0]\n\n          if (newValue === undefined || newValue === false) {\n            // If there is no matching rule (example) or the the rule says it should be dead, set to false\n            targetGrid[pos] = false\n          } else {\n            // Otherwise, use the new value\n            targetGrid[pos] = newValue\n          }\n        }\n\n        // Store for next iteration\n        prevGrid = targetGrid.concat()\n      }\n\n      // Sum up indices\n      let sum = 0\n      for (let i = 0; i < prevGrid.length; i++) {\n        const index = i - startIndex\n        if (prevGrid[i]) {\n          sum += index\n        }\n      }\n\n      return sum\n    },\n    solvePartOne: function () {\n      this.solutions.partOne = this.solve(20)\n    },\n    solvePartTwo: function () {\n      // For part 2 I ran the first few hundred generations to see if there's any pattern.\n      // After about 200 I noticed that the difference between two generations is constant.\n      // We can exploit this by searching for this repeat and then calculating the total by\n      // Using the last result before the repeat and then adding the diff times the number\n      // Of remaining iterations to it.\n\n      // Keep track of all the diffs between runs\n      const diffs = []\n      // Start at 1 generation\n      let gen = 1\n      // Track the result of the previous generation\n      let prev = 0\n      // While there aren't yet 10 entries in the diffs OR they aren't all the same\n      while (diffs.length < 10 || diffs.some(d => d !== diffs[0])) {\n        // Solve for the next generation\n        const curr = this.solve(gen++)\n        // Store the diff\n        diffs.push(curr - prev)\n        // Remember previous result\n        prev = curr\n\n        // Only keep the last 10 diffs\n        if (diffs.length > 10) {\n          diffs.shift()\n        }\n      }\n\n      // At this point the last ten diffs were the same, meaning we reached a point where the increase is identical in each run\n      // Therefore, calculate the result as the remaining gems times the diff + the last result before the diff repeat\n      this.solutions.partTwo = (50000000000 - gen + 11) * diffs[0] + this.solve(gen - 11)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day12.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day12.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day12.vue?vue&type=template&id=36d56a62\"\nimport script from \"./Day12.vue?vue&type=script&lang=js\"\nexport * from \"./Day12.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","methods","input","positions","result","solve","startIndex","tempGrid","targetGrid","prevGrid","sum","solvePartOne","solvePartTwo","diffs","prev","component"],"sourceRoot":""}