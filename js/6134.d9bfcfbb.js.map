{"version":3,"file":"js/6134.d9bfcfbb.js","mappings":"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","sources":["webpack://advent-of-code/./node_modules/@datastructures-js/heap/index.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/customHeap.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/heap.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/maxHeap.js","webpack://advent-of-code/./node_modules/@datastructures-js/heap/src/minHeap.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/index.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js","webpack://advent-of-code/./node_modules/@datastructures-js/priority-queue/src/priorityQueue.js","webpack://advent-of-code/./src/components/2021/Day15.vue?1e62","webpack://advent-of-code/src/components/2021/Day15.vue","webpack://advent-of-code/./src/components/2021/Day15.vue?7888","webpack://advent-of-code/./src/components/2021/Day15.vue","webpack://advent-of-code/./src/util/color.js"],"sourcesContent":["const { MinHeap } = require('./src/minHeap');\nconst { MaxHeap } = require('./src/maxHeap');\nconst { CustomHeap } = require('./src/customHeap');\n\nexports.MinHeap = MinHeap;\nexports.MaxHeap = MaxHeap;\nexports.CustomHeap = CustomHeap;\n","/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n */\n\nconst { Heap } = require('./heap');\n\n/**\n * @class CustomHeap\n * @extends Heap\n */\nclass CustomHeap extends Heap {\n  constructor(comparator, nodes, leaf) {\n    if (typeof comparator !== 'function') {\n      throw new Error('CustomHeap expects a comparator function');\n    }\n    super(nodes, leaf);\n    this._comparator = comparator;\n  }\n\n  /**\n   * Compares parent & child nodes\n   * and returns true if they are in right positions\n   *\n   * @private\n   * @param {object|number|string} parent\n   * @param {object|number|string} child\n   * @returns {number}\n   */\n  _compare(parentNode, childNode) {\n    return this._comparator(parentNode, childNode) <= 0;\n  }\n\n  /**\n   * Returns child's index of two children before an index\n   * @private\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    const compare = this._comparator(\n      this._nodes[rightChildIndex],\n      this._nodes[leftChildIndex]\n    );\n\n    if (compare <= 0 && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n\n    return leftChildIndex;\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @public\n   * @returns {CustomHeap}\n   */\n  clone() {\n    return new CustomHeap(\n      this._comparator,\n      this._nodes.slice(),\n      this._leaf\n    );\n  }\n\n  /**\n   * Builds a custom heap from an array of items\n   * @public\n   * @static\n   * @param {array} list\n   * @param {function} comparator\n   * @returns {CustomHeap}\n   */\n  static heapify(list, comparator) {\n    if (!Array.isArray(list)) {\n      throw new Error('.heapify expects an array');\n    }\n\n    if (typeof comparator !== 'function') {\n      throw new Error('.heapify expects a comparator function');\n    }\n\n    return new CustomHeap(comparator, list).fix();\n  }\n\n  /**\n   * Checks if a list of items is a valid custom heap\n   * @public\n   * @static\n   * @param {array} list\n   * @param {function} comparator\n   * @returns {boolean}\n   */\n  static isHeapified(list, comparator) {\n    if (!Array.isArray(list)) {\n      throw new Error('.heapify expects an array');\n    }\n\n    if (typeof comparator !== 'function') {\n      throw new Error('.isHeapified expects a comparator function');\n    }\n\n    return new CustomHeap(comparator, list).isValid();\n  }\n}\n\nexports.CustomHeap = CustomHeap;\n","/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n *\n * @class\n * @abstract\n */\nclass Heap {\n  /**\n   * Creates a heap instance\n   * @param {array<string|number|object>} nodes\n   * @param {string|number|object} [leaf]\n   * @returns {number}\n   */\n  constructor(nodes, leaf) {\n    this._nodes = Array.isArray(nodes) ? nodes : [];\n    this._leaf = leaf || null;\n  }\n\n  /**\n   * Checks if a parent has a left child\n   * @private\n   * @param {number} parentIndex\n   * @returns {boolean}\n   */\n  _hasLeftChild(parentIndex) {\n    const leftChildIndex = (parentIndex * 2) + 1;\n    return leftChildIndex < this.size();\n  }\n\n  /**\n   * Checks if a parent has a right child\n   * @private\n   * @param {number} parentIndex\n   * @returns {boolean}\n   */\n  _hasRightChild(parentIndex) {\n    const rightChildIndex = (parentIndex * 2) + 2;\n    return rightChildIndex < this.size();\n  }\n\n  /**\n   * Returns heap node's key\n   * @private\n   * @param {object|number|string} node\n   * @returns {number|string}\n   */\n  _getKey(node) {\n    if (typeof node === 'object') return node.key;\n    return node;\n  }\n\n  /**\n   * Swaps two nodes in the heap\n   * @private\n   * @param {number} i\n   * @param {number} j\n   */\n  _swap(i, j) {\n    const temp = this._nodes[i];\n    this._nodes[i] = this._nodes[j];\n    this._nodes[j] = temp;\n  }\n\n  /**\n   * Compares parent & child nodes\n   * and returns true if they are in right positions\n   *\n   * @private\n   * @param {object|number|string} parent\n   * @param {object|number|string} child\n   * @returns {boolean}\n   */\n  _compare(parentNode, childNode) {\n    return this._compareKeys(\n      this._getKey(parentNode),\n      this._getKey(childNode)\n    );\n  }\n\n  /**\n   * Checks if parent and child nodes should be swapped\n   * @private\n   * @param {number} parentIndex\n   * @param {number} childIndex\n   * @returns {boolean}\n   */\n  _shouldSwap(parentIndex, childIndex) {\n    if (parentIndex < 0 || parentIndex >= this.size()) return false;\n    if (childIndex < 0 || childIndex >= this.size()) return false;\n\n    return !this._compare(\n      this._nodes[parentIndex],\n      this._nodes[childIndex]\n    );\n  }\n\n  /**\n   * Bubbles a node from a starting index up in the heap\n   * @param {number} startingIndex\n   * @public\n   */\n  heapifyUp(startingIndex) {\n    let childIndex = startingIndex;\n    let parentIndex = Math.floor((childIndex - 1) / 2);\n\n    while (this._shouldSwap(parentIndex, childIndex)) {\n      this._swap(parentIndex, childIndex);\n      childIndex = parentIndex;\n      parentIndex = Math.floor((childIndex - 1) / 2);\n    }\n  }\n\n  /**\n   * Compares left and right & children of a parent\n   * @private\n   * @param {number} parentIndex\n   * @returns {number} - a child's index\n   */\n  _compareChildrenOf(parentIndex) {\n    if (\n      !this._hasLeftChild(parentIndex)\n      && !this._hasRightChild(parentIndex)\n    ) {\n      return -1;\n    }\n\n    const leftChildIndex = (parentIndex * 2) + 1;\n    const rightChildIndex = (parentIndex * 2) + 2;\n\n    if (!this._hasLeftChild(parentIndex)) {\n      return rightChildIndex;\n    }\n\n    if (!this._hasRightChild(parentIndex)) {\n      return leftChildIndex;\n    }\n\n    const isLeft = this._compare(\n      this._nodes[leftChildIndex],\n      this._nodes[rightChildIndex]\n    );\n\n    return isLeft ? leftChildIndex : rightChildIndex;\n  }\n\n  /**\n   * Pushes a node from a starting index down in the heap\n   * @private\n   */\n  _heapifyDown(startingIndex) {\n    let parentIndex = startingIndex;\n    let childIndex = this._compareChildrenOf(parentIndex);\n\n    while (this._shouldSwap(parentIndex, childIndex)) {\n      this._swap(parentIndex, childIndex);\n      parentIndex = childIndex;\n      childIndex = this._compareChildrenOf(parentIndex);\n    }\n  }\n\n  /**\n   * Removes and returns the root node in the heap\n   * @public\n   * @returns {object}\n   */\n  extractRoot() {\n    if (this.isEmpty()) return null;\n\n    const root = this.root();\n    this._nodes[0] = this._nodes[this.size() - 1];\n    this._nodes.pop();\n    this._heapifyDown(0);\n\n    if (root === this._leaf) {\n      this._leaf = this.root();\n    }\n\n    return root;\n  }\n\n  /**\n   * Pushes a node with down in the heap before an index\n   * @private\n   * @param {number} index\n   */\n  _heapifyDownUntil(index) {\n    let parentIndex = 0;\n    let leftChildIndex = 1;\n    let rightChildIndex = 2;\n    let childIndex;\n\n    while (leftChildIndex < index) {\n      childIndex = this._compareChildrenBefore(\n        index,\n        leftChildIndex,\n        rightChildIndex\n      );\n\n      if (this._shouldSwap(parentIndex, childIndex)) {\n        this._swap(parentIndex, childIndex);\n      }\n\n      parentIndex = childIndex;\n      leftChildIndex = (parentIndex * 2) + 1;\n      rightChildIndex = (parentIndex * 2) + 2;\n    }\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @protected\n   * @param {class} HeapType\n   * @returns {Heap}\n   */\n  _clone(HeapType) {\n    return new HeapType(this._nodes.slice(), this._leaf);\n  }\n\n  /**\n   * Sorts the heap by swapping root with all nodes and fixing positions\n   * @public\n   * @returns {array} the sorted nodes\n   */\n  sort() {\n    for (let i = this.size() - 1; i > 0; i -= 1) {\n      this._swap(0, i);\n      this._heapifyDownUntil(i);\n    }\n\n    return this._nodes;\n  }\n\n  /**\n   * Inserts a node in the right position into the heap\n   * @public\n   * @param {number|string} key\n   * @param {any} [value]\n   * @returns {Heap}\n   */\n  insert(key, value) {\n    const newNode = value !== undefined ? { key, value } : key;\n    this._nodes.push(newNode);\n    this.heapifyUp(this.size() - 1);\n    if (this._leaf === null || !this._compare(newNode, this._leaf)) {\n      this._leaf = newNode;\n    }\n    return this;\n  }\n\n  /**\n   * Fixes all positions of the nodes in the heap\n   * @public\n   * @returns {Heap}\n   */\n  fix() {\n    for (let i = 0; i < this.size(); i += 1) {\n      this.heapifyUp(i);\n    }\n    return this;\n  }\n\n  /**\n   * Verifies that the heap is valid\n   * @public\n   * @returns {boolean}\n   */\n  isValid() {\n    const isValidRecursive = (parentIndex) => {\n      let isValidLeft = true;\n      let isValidRight = true;\n\n      if (this._hasLeftChild(parentIndex)) {\n        const leftChildIndex = (parentIndex * 2) + 1;\n        isValidLeft = this._compare(\n          this._nodes[parentIndex],\n          this._nodes[leftChildIndex]\n        );\n\n        if (!isValidLeft) {\n          return false;\n        }\n\n        isValidLeft = isValidRecursive(leftChildIndex);\n      }\n\n      if (this._hasRightChild(parentIndex)) {\n        const rightChildIndex = (parentIndex * 2) + 2;\n        isValidRight = this._compare(\n          this._nodes[parentIndex],\n          this._nodes[rightChildIndex]\n        );\n\n        if (!isValidRight) {\n          return false;\n        }\n\n        isValidRight = isValidRecursive(rightChildIndex);\n      }\n\n      return isValidLeft && isValidRight;\n    };\n\n    return isValidRecursive(0);\n  }\n\n  /**\n   * Returns the root node in the heap\n   * @public\n   * @returns {object|number|string|null}\n   */\n  root() {\n    if (this.isEmpty()) return null;\n    return this._nodes[0];\n  }\n\n  /**\n   * Returns a leaf node in the heap\n   * @public\n   * @returns {object|number|string|null}\n   */\n  leaf() {\n    return this._leaf;\n  }\n\n  /**\n   * Returns the number of nodes in the heap\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._nodes.length;\n  }\n\n  /**\n   * Checks if the heap is empty\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Clears the heap\n   * @public\n   */\n  clear() {\n    this._nodes = [];\n    this._leaf = null;\n  }\n\n  /**\n   * Convert a list of items into a heap\n   * @protected\n   * @static\n   * @param {array} array\n   * @param {class} HeapType\n   * @returns {Heap}\n   */\n  static _heapify(list, HeapType) {\n    if (!Array.isArray(list)) {\n      throw new Error('.heapify expects an array');\n    }\n\n    return new HeapType(list).fix();\n  }\n\n  /**\n   * Checks if a list of items is a valid heap\n   * @protected\n   * @static\n   * @param {array} array\n   * @param {class} HeapType\n   * @returns {boolean}\n   */\n  static _isHeapified(list, HeapType) {\n    return new HeapType(list).isValid();\n  }\n}\n\nexports.Heap = Heap;\n","/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n */\n\nconst { Heap } = require('./heap');\n\n/**\n * @class MaxHeap\n * @extends Heap\n */\nclass MaxHeap extends Heap {\n  /**\n   * Checks two nodes are in relatively valid position\n   * @private\n   * @param {object} parent\n   * @param {object} child\n   * @returns {boolean}\n   */\n  _compareKeys(parentKey, childKey) {\n    return parentKey > childKey;\n  }\n\n  /**\n   * Returns max child's index of two children before an index\n   * @private\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    const leftChildKey = this._getKey(this._nodes[leftChildIndex]);\n    const rightChildKey = this._getKey(this._nodes[rightChildIndex]);\n\n    if (rightChildKey > leftChildKey && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n    return leftChildIndex;\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @public\n   * @returns {MaxHeap}\n   */\n  clone() {\n    return super._clone(MaxHeap);\n  }\n\n  /**\n   * Builds a max heap from an array of items\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {MaxHeap}\n   */\n  static heapify(list) {\n    return super._heapify(list, MaxHeap);\n  }\n\n  /**\n   * Checks if a list of items is a valid max heap\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {boolean}\n   */\n  static isHeapified(list) {\n    return super._isHeapified(list, MaxHeap);\n  }\n}\n\nexports.MaxHeap = MaxHeap;\n","/**\n * @license MIT\n * @copyright 2019 Eyas Ranjous <eyas.ranjous@gmail.com>\n */\n\nconst { Heap } = require('./heap');\n\n/**\n * @class MinHeap\n * @extends Heap\n */\nclass MinHeap extends Heap {\n  /**\n   * Checks two nodes are in relatively valid position\n   * @private\n   * @param {object} parent\n   * @param {object} child\n   * @returns {boolean}\n   */\n  _compareKeys(parentKey, childKey) {\n    return parentKey < childKey;\n  }\n\n  /**\n   * Returns min child's index of two children before an index\n   * @protected\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    const leftChildKey = this._getKey(this._nodes[leftChildIndex]);\n    const rightChildKey = this._getKey(this._nodes[rightChildIndex]);\n\n    if (rightChildKey < leftChildKey && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n    return leftChildIndex;\n  }\n\n  /**\n   * Returns a shallow copy of the heap\n   * @public\n   * @returns {MinHeap}\n   */\n  clone() {\n    return super._clone(MinHeap);\n  }\n\n  /**\n   * Builds a min heap from an array of items\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {MinHeap}\n   */\n  static heapify(list) {\n    return super._heapify(list, MinHeap);\n  }\n\n  /**\n   * Checks if a list of list is a valid min heap\n   * @public\n   * @static\n   * @param {array} list\n   * @returns {boolean}\n   */\n  static isHeapified(list) {\n    return super._isHeapified(list, MinHeap);\n  }\n}\n\nexports.MinHeap = MinHeap;\n","const { MinPriorityQueue } = require('./src/minPriorityQueue');\nconst { MaxPriorityQueue } = require('./src/maxPriorityQueue');\nconst { PriorityQueue } = require('./src/priorityQueue')\n\nmodule.exports = { MinPriorityQueue, MaxPriorityQueue, PriorityQueue };\n","/**\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { MaxHeap } = require('@datastructures-js/heap');\nconst { PriorityQueue } = require('./priorityQueue');\n\n/**\n * @class MaxPriorityQueue\n * @extends PriorityQueue\n */\nclass MaxPriorityQueue extends PriorityQueue {\n  constructor(options) {\n    super(options);\n    if (!this._compare) {\n      this._heap = new MaxHeap();\n    }\n  }\n}\n\nexports.MaxPriorityQueue = MaxPriorityQueue;\n","/**\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { MinHeap } = require('@datastructures-js/heap');\nconst { PriorityQueue } = require('./priorityQueue');\n\n/**\n * @class MinPriorityQueue\n * @extends PriorityQueue\n */\nclass MinPriorityQueue extends PriorityQueue {\n  constructor(options) {\n    super(options);\n    if (!this._compare) {\n      this._heap = new MinHeap();\n    }\n  }\n}\n\nexports.MinPriorityQueue = MinPriorityQueue;\n","/**\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { CustomHeap } = require('@datastructures-js/heap');\n\n/**\n * @class PriorityQueue\n */\nclass PriorityQueue {\n  /**\n   * Creates a priority queue\n   * @public\n   * @params {object} [options]\n   */\n  constructor(options = {}) {\n    const { priority, compare } = options;\n    if (compare) {\n      if (typeof compare !== 'function') {\n        throw new Error('.constructor expects a valid compare function');\n      }\n      this._compare = compare;\n      this._heap = new CustomHeap(this._compare);\n    } else {\n      if (priority !== undefined && typeof priority !== 'function') {\n        throw new Error('.constructor expects a valid priority function');\n      }\n\n      this._priority = priority || ((el) => +el);\n    }\n  }\n\n  /**\n   * @private\n   * @returns {object}\n   */\n  _getElementWithPriority(node) {\n    return {\n      priority: node.key,\n      element: node.value\n    };\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * Returns an element with highest priority in the queue\n   * @public\n   * @returns {object}\n   */\n  front() {\n    if (this.isEmpty()) return null;\n\n    if (this._compare) {\n      return this._heap.root();\n    }\n\n    return this._getElementWithPriority(this._heap.root());\n  }\n\n  /**\n   * Returns an element with lowest priority in the queue\n   * @public\n   * @returns {object}\n   */\n  back() {\n    if (this.isEmpty()) return null;\n\n    if (this._compare) {\n      return this._heap.leaf();\n    }\n\n    return this._getElementWithPriority(this._heap.leaf());\n  }\n\n  /**\n   * Adds an element to the queue\n   * @public\n   * @param {any} element\n   * @param {number} p - priority\n   * @throws {Error} if priority is not a valid number\n   */\n  enqueue(element, p) {\n    if (this._compare) {\n      this._heap.insert(element);\n      return this;\n    }\n\n    if (p && Number.isNaN(+p)) {\n      throw new Error('.enqueue expects a numeric priority');\n    }\n\n    if (Number.isNaN(+p) && Number.isNaN(this._priority(element))) {\n      throw new Error(\n        '.enqueue expects a numeric priority '\n        + 'or a constructor callback that returns a number'\n      );\n    }\n\n    const priority = !Number.isNaN(+p) ? p : this._priority(element);\n    this._heap.insert(+priority, element);\n    return this;\n  }\n\n  /**\n   * Removes and returns an element with highest priority in the queue\n   * @public\n   * @returns {object}\n   */\n  dequeue() {\n    if (this.isEmpty()) return null;\n\n    if (this._compare) {\n      return this._heap.extractRoot();\n    }\n\n    return this._getElementWithPriority(this._heap.extractRoot());\n  }\n\n  /**\n   * Returns a sorted list of elements from highest to lowest priority\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    if (this._compare) {\n      return this._heap.clone().sort().reverse();\n    }\n\n    return this._heap\n      .clone()\n      .sort()\n      .map((n) => this._getElementWithPriority(n))\n      .reverse();\n  }\n\n  /**\n   * Clears the queue\n   * @public\n   */\n  clear() {\n    this._heap.clear();\n  }\n}\n\nexports.PriorityQueue = PriorityQueue;\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":15,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{staticClass:\"canvas-holder-one\"},[_c('canvas',{ref:\"partOne\",staticClass:\"canvas\",attrs:{\"width\":\"202\",\"height\":\"100\"}})])]},proxy:true},{key:\"partTwo\",fn:function(){return [_c('div',{staticClass:\"canvas-holder-two\"},[_c('canvas',{ref:\"partTwo\",staticClass:\"canvas\",attrs:{\"width\":\"1002\",\"height\":\"500\"}})])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"15\" :year=\"2021\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partOne>\n      <div class=\"canvas-holder-one\">\n        <canvas ref=\"partOne\" class=\"canvas\" width=\"202\" height=\"100\" />\n      </div>\n    </template>\n    <template v-slot:partTwo>\n      <div class=\"canvas-holder-two\">\n        <canvas ref=\"partTwo\" class=\"canvas\" width=\"1002\" height=\"500\" />\n      </div>\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\nimport { createColorGradient } from '@/util/color'\n\nconst { PriorityQueue } = require('@datastructures-js/priority-queue')\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      neighbors: [[1, 0], [0, 1], [-1, 0], [0, -1]],\n      gridOne: null\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const nodesOne = this.parseInput(input, 1)\n      this.solutions.partOne = this.dijkstra(nodesOne, input[0].length - 1, input.length - 1)\n      this.$nextTick(() => this.print(this.$refs.partOne, nodesOne, this.getNodesOnPath(nodesOne, `${input[0].length - 1},${input.length - 1}`), input[0].length - 1, input.length - 1))\n\n      const nodesTwo = this.parseInput(input, 5)\n      this.solutions.partTwo = this.dijkstra(nodesTwo, input[0].length * 5 - 1, input.length * 5 - 1)\n      this.$nextTick(() => this.print(this.$refs.partTwo, nodesTwo, this.getNodesOnPath(nodesTwo, `${input[0].length * 5 - 1},${input.length * 5 - 1}`), input[0].length * 5 - 1, input.length * 5 - 1))\n    },\n    parseInput: function (input, repeat) {\n      const nodes = new Map()\n\n      const maxX = input[0].length\n      const maxY = input.length\n\n      // Parse the original grid\n      const grid = input.map(i => i.split('').map(c => +c))\n\n      // For the larger dimensions\n      for (let y = 0; y < maxY * repeat; y++) {\n        for (let x = 0; x < maxX * repeat; x++) {\n          // Get the coordinates and the valid neighbors\n          const coords = `${x},${y}`\n          const validNeighbors = this.neighbors.filter(n => x + n[0] >= 0 && x + n[0] < maxX * repeat && y + n[1] >= 0 && y + n[1] < maxY * repeat)\n\n          // Calculate the value of the repeated cell\n          let value = (+grid[y % grid.length][x % grid[0].length]) + Math.floor(y / maxY) + Math.floor(x / maxX)\n\n          // Fix issues with large values\n          if (value > 9) {\n            value -= 9\n          }\n\n          // Add the node to the mapping\n          nodes.set(coords, {\n            x: x,\n            y: y,\n            value: value,\n            coords: coords,\n            cost: Number.POSITIVE_INFINITY,\n            neighbors: validNeighbors\n          })\n        }\n      }\n\n      return nodes\n    },\n    dijkstra: function (nodes, maxX, maxY) {\n      const target = `${maxX},${maxY}`\n\n      // Use a priority queue to keep track of the node with lowest cost\n      const queue = new PriorityQueue({\n        compare: (a, b) => a.cost - b.cost\n      })\n\n      // Add the start point\n      const start = nodes.get('0,0')\n      start.cost = 0\n      queue.enqueue(start)\n\n      // While there are still nodes on the queue, continue\n      while (queue.size() > 0) {\n        // Get the lowest-cost node\n        const current = queue.dequeue()\n\n        // Go through all neighbors\n        current.neighbors.forEach(n => {\n          // Get the actual object\n          const coords = `${current.x + n[0]},${current.y + n[1]}`\n          const neighbor = nodes.get(coords)\n\n          // Check if it's on the queue\n          const onQueue = neighbor.cost !== Number.POSITIVE_INFINITY\n          // Adjust the cost\n          neighbor.cost = Math.min(neighbor.cost, current.cost + neighbor.value)\n\n          if (!onQueue) {\n            // Add to queue\n            queue.enqueue(neighbor)\n          }\n        })\n\n        // If we found the target, we can stop\n        if (current.coords === target) {\n          break\n        }\n      }\n\n      return nodes.get(target).cost\n    },\n    print: function (canvas, nodes, path, maxX, maxY) {\n      const ctx = canvas.getContext('2d')\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n      const gradient = createColorGradient('#006266', '#C4E538', nodes.get(`${maxX},${maxY}`).cost + 1)\n      const gradientValue = createColorGradient('#006266', '#C4E538', 10)\n\n      nodes.forEach(n => {\n        ctx.fillStyle = gradientValue[n.value]\n        ctx.fillRect(n.x, n.y, 1, 1)\n\n        if (path.has(n.coords)) {\n          ctx.fillStyle = '#181a1b'\n          ctx.fillRect(n.x + maxX + 2, n.y, 1, 1)\n        } else {\n          ctx.fillStyle = gradient[n.cost]\n          ctx.fillRect(n.x + maxX + 2, n.y, 1, 1)\n        }\n      })\n    },\n    getNodesOnPath: function (nodes, target) {\n      // Keep track of the nodes on the path\n      const path = new Set()\n\n      // Start at the target\n      let current = target\n      path.add(current)\n\n      // While we haven't reached the start yet\n      while (current !== '0,0') {\n        // Find the neighbor with the smallest cost\n        let minValue = Number.MAX_SAFE_INTEGER\n        let min = null\n        nodes.get(current).neighbors.forEach(n => {\n          const curr = current.split(',').map(c => +c)\n          const coords = `${curr[0] + n[0]},${curr[1] + n[1]}`\n          const neighbor = nodes.get(coords)\n\n          if (neighbor.cost < minValue) {\n            minValue = neighbor.cost\n            min = coords\n          }\n        })\n\n        // Add that neighbor and continue with it\n        path.add(min)\n        current = min\n      }\n\n      // Add the target\n      path.add('0,0')\n\n      return path\n    }\n  }\n}\n</script>\n\n<style>\n.canvas-holder-one {\n  overflow: auto;\n  height: 100px;\n  width: 100%;\n}\n.canvas-holder-two {\n  overflow: auto;\n  height: 500px;\n  width: 100%;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day15.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day15.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day15.vue?vue&type=template&id=c6b86140\"\nimport script from \"./Day15.vue?vue&type=script&lang=js\"\nexport * from \"./Day15.vue?vue&type=script&lang=js\"\nimport style0 from \"./Day15.vue?vue&type=style&index=0&id=c6b86140&prod&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const VIRIDIS = ['#440154', '#48186a', '#472d7b', '#424086', '#3b528b', '#33638d', '#2c728e', '#26828e', '#21918c', '#1fa088', '#28ae80', '#3fbc73', '#5ec962', '#84d44b', '#addc30', '#d8e219', '#fde725']\n\n/**\n * Converts a HEX value into an RGB object\n * @param {String} hex The hex color\n */\nconst hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    }\n    : null\n}\n\n/**\n * Converts the given R, G, B values into a HEX color\n * @param {Number} r The red color component\n * @param {Number} g The green color component\n * @param {Number} b The blue color component\n */\nconst rgbToHex = (r, g, b) => {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n}\n\n/**\n * Creates a linear gradient between the two given colors with the given number of steps\n * @param {String} one The first color in HEX\n * @param {String} two The second color in HEX\n * @param {Number} steps The number of steps between the two colors\n */\nconst createColorGradient = (one, two, steps) => {\n  const oneRgb = hexToRgb(one)\n  const twoRgb = hexToRgb(two)\n\n  if (steps < 2) {\n    return [one]\n  }\n\n  const result = []\n  for (let i = 0; i < steps; i++) {\n    const iNorm = (i / (steps - 1))\n    result.push(rgbToHex(\n      Math.floor(oneRgb.r + iNorm * (twoRgb.r - oneRgb.r)),\n      Math.floor(oneRgb.g + iNorm * (twoRgb.g - oneRgb.g)),\n      Math.floor(oneRgb.b + iNorm * (twoRgb.b - oneRgb.b))\n    ))\n  }\n  return result\n}\n\nconst createMultiColorGradient = (colors, steps) => {\n  if (colors.length > steps) {\n    return colors.slice(0, steps)\n  }\n\n  const sections = colors.length - 1\n\n  let result = []\n\n  for (let i = 0; i < sections - 1; i++) {\n    result = result.concat(createColorGradient(colors[i], colors[i + 1], Math.max(1, Math.floor(steps / sections))))\n  }\n\n  while (result.length < steps) {\n    result.push(colors[colors.length - 1])\n  }\n\n  return result\n}\n\nexport {\n  hexToRgb,\n  rgbToHex,\n  createColorGradient,\n  createMultiColorGradient,\n  VIRIDIS\n}\n"],"names":["MinHeap","MaxHeap","CustomHeap","exports","Heap","constructor","comparator","nodes","leaf","Error","super","this","_comparator","_compare","parentNode","childNode","_compareChildrenBefore","index","leftChildIndex","rightChildIndex","compare","_nodes","clone","slice","_leaf","heapify","list","Array","isArray","fix","isHeapified","isValid","_hasLeftChild","parentIndex","size","_hasRightChild","_getKey","node","key","_swap","i","j","temp","_compareKeys","_shouldSwap","childIndex","heapifyUp","startingIndex","Math","floor","_compareChildrenOf","isLeft","_heapifyDown","extractRoot","isEmpty","root","pop","_heapifyDownUntil","_clone","HeapType","sort","insert","value","newNode","undefined","push","isValidRecursive","isValidLeft","isValidRight","length","clear","_heapify","_isHeapified","parentKey","childKey","leftChildKey","rightChildKey","MinPriorityQueue","MaxPriorityQueue","PriorityQueue","module","options","_heap","priority","_priority","el","_getElementWithPriority","element","front","back","enqueue","p","Number","isNaN","dequeue","toArray","reverse","map","n","render","_vm","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","fn","staticClass","ref","proxy","staticRenderFns","components","Day","data","partOne","partTwo","neighbors","gridOne","methods","parseInput","x","y","coords","cost","dijkstra","start","queue","current","neighbor","print","ctx","getNodesOnPath","path","minValue","min","component","VIRIDIS","hexToRgb","hex","result","exec","r","parseInt","g","b","rgbToHex","toString","createColorGradient","one","two","steps","oneRgb","twoRgb","iNorm","createMultiColorGradient","colors","sections","concat","max"],"sourceRoot":""}