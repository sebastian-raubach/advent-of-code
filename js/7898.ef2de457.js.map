{"version":3,"file":"js/7898.ef2de457.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCOtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAEAC,UAAAA,CAAAA,CAAAA,EAAAA,GAAAA,EAAAA,EAAAA,GAAAA,CAAAA,GAAAA,GAAAA,CAAAA,GAAAA,GAAAA,CAAAA,EAAAA,GAAAA,EAAAA,EAAAA,IACAC,WAAAA,CACAC,EAAAA,IACAC,EAAAA,IAAAA,EAEAC,GAAAA,IACAD,EAAAA,IAAAA,EAEAE,GAAAA,IACAF,EAAAA,KACAA,EAAAA,IAAAA,EAEAG,EAAAA,IACAH,EAAAA,IAAAA,EAEAI,GAAAA,IACAJ,EAAAA,IAAAA,EAEAK,GAAAA,IACAL,EAAAA,KACAA,EAAAA,IAAAA,GAIA,EACAM,QAAAA,CACAhB,eAAAA,SAAAA,GAEA,sBACA,WAEA,SAEA,mEAEA,kBACA,SAGAiB,EAAAA,KAAAA,EAAAA,IAEAC,EAAAA,EAAAA,QAAAA,EAAAA,GAAAA,GACA,KAEA,oBACA,mBACA,EACAC,aAAAA,WACA,wBAEA,wBAEA,cAEAC,EAAAA,SAAAA,IAEA,yBAGA,0BAEA,uBACA,0BAEA,sBACA,IAIA,2CACA,EACAC,aAAAA,WAEA,sBAEA,+BAIA,2CACA,EACAC,QAAAA,WACA,gBAGA,2DAEA,gCACA,gCACA,gCACA,gCAGA,yBACA,0BACA,oBAGA,6BAEA,2CAEA,oBAEA,iCACA,OAGA,2BAEA,mBAGA,WADAC,EAAAA,IAAAA,EAKA,CAGA,QACA,IC3I6P,I,UCOzPC,GAAY,OACd,EACAlC,EACAW,GACA,EACA,KACA,KACA,MAIF,EAAeuB,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2020/Day24.vue?94e9","webpack://advent-of-code/src/components/2020/Day24.vue","webpack://advent-of-code/./src/components/2020/Day24.vue?2798","webpack://advent-of-code/./src/components/2020/Day24.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":24,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"24\" :year=\"2020\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      neighbors: [[1, 0], [-1, 0], [1, -1], [0, -1], [0, 1], [-1, 1]],\n      directions: {\n        e: pos => {\n          pos[0]++\n        },\n        se: pos => {\n          pos[1]++\n        },\n        sw: pos => {\n          pos[0]--\n          pos[1]++\n        },\n        w: pos => {\n          pos[0]--\n        },\n        nw: pos => {\n          pos[1]--\n        },\n        ne: pos => {\n          pos[0]++\n          pos[1]--\n        }\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // For each line in the input\n      this.tiles = input.map(line => {\n        const parsed = []\n        // Keep parsing directions\n        while (true) {\n          // Get the direction that matches the first letters\n          const directions = Object.keys(this.directions).filter(d => line.indexOf(d) === 0)\n          // If there isn't one, return the parsed result\n          if (!directions || directions.length < 1) {\n            return parsed\n          }\n          // Else, add it to the array\n          parsed.push(directions[0])\n          // And remove it from the start of the string\n          line = line.replace(directions[0], '')\n        }\n      })\n      this.solvePartOne()\n      this.solvePartTwo()\n    },\n    solvePartOne: function () {\n      this.blackTiles = new Set()\n\n      this.tiles.forEach(t => {\n        // Start at the origin\n        const pos = [0, 0]\n        // For each direction\n        t.forEach(d => {\n          // Adjust the position\n          this.directions[d](pos)\n        })\n        // Produce the key\n        const stringified = `${pos[0]},${pos[1]}`\n        // If it's alive, flip it to dead. Otherwise, set it to alive\n        if (this.blackTiles.has(stringified)) {\n          this.blackTiles.delete(stringified)\n        } else {\n          this.blackTiles.add(stringified)\n        }\n      })\n\n      // Count the number of black (alive) tiles\n      this.solutions.partOne = this.blackTiles.size\n    },\n    solvePartTwo: function () {\n      // For each of the 100 days\n      for (let day = 0; day < 100; day++) {\n        // Run one iteration\n        this.blackTiles = this.iterate()\n      }\n\n      // Count the number of alive cells\n      this.solutions.partTwo = this.blackTiles.size\n    },\n    iterate: function () {\n      const tempTiles = new Set()\n\n      // Split each tile into x and y\n      const split = [...this.blackTiles].map(t => t.split(',').map(i => +i))\n      // Find min and max per dimension\n      const minX = Math.min(...split.map(t => t[0]))\n      const maxX = Math.max(...split.map(t => t[0]))\n      const minY = Math.min(...split.map(t => t[1]))\n      const maxY = Math.max(...split.map(t => t[1]))\n\n      // Check the grid from min-1 to max+1 in each dimension\n      for (let x = minX - 1; x <= maxX + 1; x++) {\n        for (let y = minY - 1; y <= maxY + 1; y++) {\n          const stringified = `${x},${y}`\n\n          // Filter the neighbors to those that are alive/black\n          const activeNeighbors = this.neighbors.filter(n => {\n            // Adjust the position\n            const np = stringified.split(',').map((v, i) => +v + n[i])\n            // Calculate the new key\n            const nk = `${np[0]},${np[1]}`\n\n            return this.blackTiles.has(nk)\n          }).length\n\n          // Check if this one is alive\n          const alive = this.blackTiles.has(stringified)\n\n          if (alive && (activeNeighbors === 1 || activeNeighbors === 2)) {\n            // If we're currently alive, stay alive if we have 1 or 2 active neighbors\n            tempTiles.add(stringified)\n          } else if (!alive && activeNeighbors === 2) {\n            // If we aren't alive, become alive if we have two active neighbors\n            tempTiles.add(stringified)\n          }\n        }\n      }\n\n      return tempTiles\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day24.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day24.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day24.vue?vue&type=template&id=aa0edec0\"\nimport script from \"./Day24.vue?vue&type=script&lang=js\"\nexport * from \"./Day24.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","neighbors","directions","e","pos","se","sw","w","nw","ne","methods","parsed","line","solvePartOne","t","solvePartTwo","iterate","tempTiles","component"],"sourceRoot":""}