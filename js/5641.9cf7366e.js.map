{"version":3,"file":"js/5641.9cf7366e.js","mappings":"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","sources":["webpack://advent-of-code/./src/components/2021/Day18.vue?f4f5","webpack://advent-of-code/src/components/2021/Day18.vue","webpack://advent-of-code/./src/components/2021/Day18.vue?5a52","webpack://advent-of-code/./src/components/2021/Day18.vue","webpack://advent-of-code/./node_modules/core-js/modules/es.array.map.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":18,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"18\" :year=\"2021\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Start with the first\n      let current = input[0]\n      for (let i = 1; i < input.length; i++) {\n        // Then stepwise add the other onto it\n        current = this.add(current, input[i])\n      }\n\n      // Convert to an array using the convenient JSON.parse\n      const arr = JSON.parse(current)\n      // Get the magnitude by traversing the tree\n      this.solutions.partOne = this.magnitude(arr)\n\n      // Find the maximum\n      let max = 0\n      // Pairwise comparison of all pairs\n      for (let i = 0; i < input.length; i++) {\n        for (let j = 0; j < input.length; j++) {\n          // Skip same ones\n          if (i === j) {\n            continue\n          }\n\n          // Calculate the magnitude\n          const result = this.magnitude(JSON.parse(this.add(input[i], input[j])))\n\n          // Update maximum\n          max = Math.max(max, result)\n        }\n      }\n\n      this.solutions.partTwo = max\n    },\n    add: function (one, two) {\n      // Create the concatenated array\n      let current = `[${one},${two}]`\n\n      // While we found something to compact\n      let compacting = false\n      do {\n        // Explode first\n        let result = this.explode(current)\n        current = result[0]\n        compacting = result[1]\n\n        // If there was no explosion\n        if (!compacting) {\n          // Check for splits\n          result = this.split(current)\n          current = result[0]\n          compacting = result[1]\n        }\n      } while (compacting)\n\n      // Return the result of the addition\n      return current\n    },\n    magnitude: function (current) {\n      if (isNaN(current)) {\n        // For internal nodes, it's 3 times left plus 2 times right\n        return 3 * this.magnitude(current[0]) + 2 * this.magnitude(current[1])\n      } else {\n        // For leaf nodes, it's the value\n        return current\n      }\n    },\n    split: function (current) {\n      const arr = current.split('')\n\n      // Find numbers that are larger or equal to 10\n      let start = null\n      let end = null\n      let isNumber = false\n      // Go through the string from left to right\n      for (let i = 0; i < arr.length; i++) {\n        // If we find a number\n        if (!isNaN(arr[i])) {\n          isNumber = true\n          if (start === null) {\n            // Set the start (left boundary)\n            start = i\n            // Set an initial value for the end (right boundary)\n            end = Math.min(i + 1, arr.length - 1)\n          } else {\n            // Update the end (right boundary)\n            end = Math.min(i + 1, arr.length - 1)\n          }\n        } else {\n          isNumber = false\n        }\n\n        // We got to the end\n        if (i === arr.length - 1) {\n          isNumber = false\n        }\n\n        // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n        if (!isNumber && start !== null && end !== null) {\n          // Parse the number\n          const n = parseInt(current.substring(start, end))\n\n          if (n >= 10) {\n            // If it's too large, replace it with an array of floor and ceil\n            return [`${current.substring(0, start)}[${Math.floor(n / 2.0)},${Math.ceil(n / 2.0)}]${current.substring(end, current.length)}`, true]\n          } else {\n            // If it's too small, continue searching\n            start = null\n            end = null\n            isNumber = false\n          }\n        }\n      }\n\n      // Indicate we didn't split\n      return [current, false]\n    },\n    explode: function (current) {\n      const arr = current.split('')\n\n      // Count the level by keeping track of opening and closing brackets\n      let openCount = 0\n      for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === '[') {\n          openCount++\n        }\n        if (arr[i] === ']') {\n          openCount--\n        }\n\n        // We found one that's \"too deep\"\n        if (openCount > 4) {\n          // Get the end index\n          const endIndex = current.indexOf(']', i)\n          // Parse the number pair\n          const pair = current.substring(i + 1, endIndex).split(',').map(c => +c)\n          // Get the left and the right substrings for later\n          let left = current.substring(0, i)\n          let right = current.substring(endIndex + 1)\n\n          // Go from the found index towards the left to find the first number and increase it\n          let start = null\n          let end = null\n          let isNumber = false\n          const leftArr = left.split('')\n          for (let l = leftArr.length - 1; l >= 0; l--) {\n            if (!isNaN(leftArr[l])) {\n              isNumber = true\n              if (end === null) {\n                // We found the right border\n                end = l\n                // Initialise the left border\n                start = Math.max(0, l - 1)\n              } else {\n                // Update the left border\n                start = Math.max(0, l - 1)\n              }\n            } else {\n              isNumber = false\n            }\n\n            if (l === 0) {\n              isNumber = false\n            }\n\n            // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n            if (!isNumber && start !== null && end !== null) {\n              // Update the left side by increasing the number value\n              left = `${left.substring(0, start + 1)}${parseInt(left.substring(start + 1, end + 1)) + pair[0]}${left.substring(end + 1, left.length)}`\n              break\n            }\n          }\n\n          start = null\n          end = null\n          isNumber = false\n          const rightArr = right.split('')\n          for (let r = 0; r < rightArr.length; r++) {\n            if (!isNaN(rightArr[r])) {\n              isNumber = true\n              if (start === null) {\n                // We found the left border\n                start = r\n                // Initialise the left border\n                end = Math.min(rightArr.length - 1, r + 1)\n              } else {\n                // Update the left border\n                end = Math.min(rightArr.length - 1, r + 1)\n              }\n            } else {\n              isNumber = false\n            }\n\n            if (r === rightArr.length - 1) {\n              isNumber = false\n            }\n\n            // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n            if (!isNumber && start !== null && end !== null) {\n              // Update the right side by increasing the number value\n              right = `${right.substring(0, start)}${parseInt(right.substring(start, end)) + pair[1]}${right.substring(end, right.length)}`\n              break\n            }\n          }\n\n          // Reconstitute the whole string by setting a zero in the middle\n          current = `${left}0${right}`\n\n          // Indicate we exploded\n          return [current, true]\n        }\n      }\n\n      // Indicate we didn't explode\n      return [current, false]\n    }\n  }\n}\n</script>\n\n<style scoped>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day18.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day18.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Day18.vue?vue&type=template&id=4850715e&scoped=true&\"\nimport script from \"./Day18.vue?vue&type=script&lang=js&\"\nexport * from \"./Day18.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"4850715e\",\n  null\n  \n)\n\nexport default component.exports","'use strict';\nvar $ = require('../internals/export');\nvar $map = require('../internals/array-iteration').map;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\nvar arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n// FF49- issue\nvar USES_TO_LENGTH = arrayMethodUsesToLength('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","methods","current","add","input","i","magnitude","arr","max","Math","result","compacting","split","isNaN","isNumber","start","end","min","length","n","explode","openCount","leftArr","l","left","rightArr","r","right","component","$","$map","arrayMethodHasSpeciesSupport","arrayMethodUsesToLength","HAS_SPECIES_SUPPORT","USES_TO_LENGTH","target","proto","forced","map","callbackfn","arguments","undefined"],"sourceRoot":""}