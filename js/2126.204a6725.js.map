{"version":3,"file":"js/2126.204a6725.js","mappings":"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","sources":["webpack://advent-of-code/./src/components/2020/Day12.vue?8ea7","webpack://advent-of-code/src/components/2020/Day12.vue","webpack://advent-of-code/./src/components/2020/Day12.vue?629a","webpack://advent-of-code/./src/components/2020/Day12.vue","webpack://advent-of-code/./src/util/color.js","webpack://advent-of-code/./src/util/math.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":12,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{staticClass:\"plotly-chart\",attrs:{\"id\":\"partOneChart\"}})]},proxy:true},{key:\"partTwo\",fn:function(){return [_c('div',{staticClass:\"plotly-chart\",attrs:{\"id\":\"partTwoChart\"}})]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"12\" :year=\"2020\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partOne>\n      <div class=\"plotly-chart\" id=\"partOneChart\" />\n    </template>\n    <template v-slot:partTwo>\n      <div class=\"plotly-chart\" id=\"partTwoChart\" />\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\nimport { mapGetters } from 'vuex'\nimport { createColorGradient } from '@/util/color'\nimport { mod } from '@/util/math'\n\nexport default {\n  components: {\n    Day\n  },\n  computed: {\n    ...mapGetters([\n      'storeDarkMode'\n    ])\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      colorGradient: createColorGradient('#eeeeee', '#c0392b', 1000),\n      operationsOne: {\n        // N, S, E and W just adjust the x and y position\n        N: (pos, op) => { pos.y += op.value },\n        S: (pos, op) => { pos.y -= op.value },\n        E: (pos, op) => { pos.x += op.value },\n        W: (pos, op) => { pos.x -= op.value },\n        // L turns the ship counter-clockwise modulo 360\n        L: (pos, op) => { pos.angle = mod(pos.angle - op.value, 360) },\n        // R turns the ship clockwise modulo 360\n        R: (pos, op) => { pos.angle = mod(pos.angle + op.value, 360) },\n        // F Uses either N, E, S or W depending on the current angle\n        F: (pos, op) => {\n          switch (pos.angle) {\n            case 0:\n              this.operationsOne.N(pos, op)\n              break\n            case 90:\n              this.operationsOne.E(pos, op)\n              break\n            case 180:\n              this.operationsOne.S(pos, op)\n              break\n            case 270:\n              this.operationsOne.W(pos, op)\n              break\n          }\n        }\n      },\n      operationsTwo: {\n        // N, S, E and W move the waypoint x and y positions\n        N: (pos, way, op) => { way.y += op.value },\n        S: (pos, way, op) => { way.y -= op.value },\n        E: (pos, way, op) => { way.x += op.value },\n        W: (pos, way, op) => { way.x -= op.value },\n        // L rotates the waypoint around the ship counter-clockwise\n        L: (pos, way, op) => {\n          let tmp\n          switch (op.value) {\n            case 90:\n              tmp = way.x\n              way.x = -way.y\n              way.y = tmp\n              break\n            case 180:\n              way.x = -way.x\n              way.y = -way.y\n              break\n            case 270:\n              tmp = way.x\n              way.x = way.y\n              way.y = -tmp\n              break\n          }\n          // Update angle\n          pos.angle = mod(pos.angle - op.value, 360)\n        },\n        // R rotates the waypoint around the ship clockwise\n        R: (pos, way, op) => {\n          let tmp\n          switch (op.value) {\n            case 90:\n              tmp = way.x\n              way.x = way.y\n              way.y = -tmp\n              break\n            case 180:\n              way.x = -way.x\n              way.y = -way.y\n              break\n            case 270:\n              tmp = way.x\n              way.x = -way.y\n              way.y = tmp\n              break\n          }\n          pos.angle = mod(pos.angle + op.value, 360)\n         },\n        // F moves the ship in the direction of the waypoint multiplied by the value\n        F: (pos, way, op) => {\n          pos.x += op.value * way.x\n          pos.y += op.value * way.y\n        }\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.directions = input.map(i => {\n        // Get the number\n        const value = +i.replace(/[a-zA-Z]+/g, '')\n        // Get the letter\n        const inst = i.replace(/\\d*/g, '')\n\n        // Save as object\n        return {\n          instruction: inst,\n          value: value\n        }\n      })\n\n      this.solvePartOne()\n      this.solvePartTwo()\n    },\n    solvePartOne: function () {\n      // Ship starting position\n      const ship = {\n        x: 0,\n        y: 0,\n        angle: 90\n      }\n\n      // Keep track of the points for the chart\n      const points = []\n      points.push({\n        x: ship.x,\n        y: ship.y\n      })\n      console.log(this.directions)\n      // For each of the directions\n      this.directions.forEach(i => {\n        console.log(i)\n        // Use the operation mapping to resolve it\n        this.operationsOne[i.instruction](ship, i)\n        // Remember the new point for the chart\n        points.push({\n          x: ship.x,\n          y: ship.y\n        })\n      })\n\n      // Get the solution as the manhattan distance\n      this.solutions.partOne = Math.abs(ship.x) + Math.abs(ship.y)\n\n      // Draw the chart\n      this.drawPath(points, 'partOneChart')\n    },\n    solvePartTwo: function () {\n      // The ship starting position\n      const ship = {\n        x: 0,\n        y: 0,\n        angle: 90\n      }\n      // The waypoint starting position (distance from the ship)\n      const way = {\n        x: 10,\n        y: 1\n      }\n\n      // Keep track of all points for the chart\n      const points = []\n      points.push({\n        x: ship.x,\n        y: ship.y\n      })\n\n      // For each direction\n      this.directions.forEach(i => {\n        // Use the mapping to resolve the direction\n        this.operationsTwo[i.instruction](ship, way, i)\n        // Add the point for the chart\n        points.push({\n          x: ship.x,\n          y: ship.y\n        })\n      })\n\n      // Get the solution as the manhattan distance\n      this.solutions.partTwo = Math.abs(ship.x) + Math.abs(ship.y)\n\n      // Draw the chart\n      this.drawPath(points, 'partTwoChart')\n    },\n    drawPath: function (points, id) {\n      // Keep track of all lines\n      const shapes = []\n      // Calculate min and max in each dimension for the axes\n      let xMin = points[0].x\n      let yMin = points[0].y\n      let xMax = points[0].x\n      let yMax = points[0].y\n\n      for (let i = 1; i < points.length; i++) {\n        // Calculate the color based on the gradient\n        const color = this.colorGradient[Math.floor((i - 1) * this.colorGradient.length / points.length)]\n        // Add the new line\n        shapes.push({\n          type: 'line',\n          x0: points[i - 1].x,\n          y0: points[i - 1].y,\n          x1: points[i].x,\n          y1: points[i].y,\n          line: {\n            color: color,\n            width: 3\n          }\n        })\n\n        xMin = Math.min(xMin, points[i].x)\n        yMin = Math.min(yMin, points[i].y)\n        xMax = Math.max(xMax, points[i].x)\n        yMax = Math.max(yMax, points[i].y)\n      }\n\n      const layout = {\n        shapes: shapes,\n        xaxis: {\n          range: [xMin, xMax],\n          tickfont: { color: this.storeDarkMode ? 'white' : 'black' },\n          gridcolor: this.storeDarkMode ? '#111111' : '#eeeeee'\n        },\n        yaxis: {\n          range: [yMin, yMax],\n          tickfont: { color: this.storeDarkMode ? 'white' : 'black' },\n          gridcolor: this.storeDarkMode ? '#111111' : '#eeeeee'\n        },\n        paper_bgcolor: 'transparent',\n        plot_bgcolor: 'transparent'\n      }\n\n      this.$nextTick(() => {\n        // Purge the old chart and add the new one\n        this.$plotly.purge(id)\n        this.$plotly.newPlot(id, null, layout, {\n          responsive: true,\n          staticPlot: true,\n          displayModeBar: false\n        })\n      })\n    }\n  }\n}\n</script>\n\n<style scoped>\n.plotly-chart {\n  height: 400px;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day12.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day12.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day12.vue?vue&type=template&id=50c253e0&scoped=true\"\nimport script from \"./Day12.vue?vue&type=script&lang=js\"\nexport * from \"./Day12.vue?vue&type=script&lang=js\"\nimport style0 from \"./Day12.vue?vue&type=style&index=0&id=50c253e0&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"50c253e0\",\n  null\n  \n)\n\nexport default component.exports","const VIRIDIS = ['#440154', '#48186a', '#472d7b', '#424086', '#3b528b', '#33638d', '#2c728e', '#26828e', '#21918c', '#1fa088', '#28ae80', '#3fbc73', '#5ec962', '#84d44b', '#addc30', '#d8e219', '#fde725']\n\n/**\n * Converts a HEX value into an RGB object\n * @param {String} hex The hex color\n */\nconst hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    }\n    : null\n}\n\n/**\n * Converts the given R, G, B values into a HEX color\n * @param {Number} r The red color component\n * @param {Number} g The green color component\n * @param {Number} b The blue color component\n */\nconst rgbToHex = (r, g, b) => {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n}\n\n/**\n * Creates a linear gradient between the two given colors with the given number of steps\n * @param {String} one The first color in HEX\n * @param {String} two The second color in HEX\n * @param {Number} steps The number of steps between the two colors\n */\nconst createColorGradient = (one, two, steps) => {\n  const oneRgb = hexToRgb(one)\n  const twoRgb = hexToRgb(two)\n\n  if (steps < 2) {\n    return [one]\n  }\n\n  const result = []\n  for (let i = 0; i < steps; i++) {\n    const iNorm = (i / (steps - 1))\n    result.push(rgbToHex(\n      Math.floor(oneRgb.r + iNorm * (twoRgb.r - oneRgb.r)),\n      Math.floor(oneRgb.g + iNorm * (twoRgb.g - oneRgb.g)),\n      Math.floor(oneRgb.b + iNorm * (twoRgb.b - oneRgb.b))\n    ))\n  }\n  return result\n}\n\nconst createMultiColorGradient = (colors, steps) => {\n  if (colors.length > steps) {\n    return colors.slice(0, steps)\n  }\n\n  const sections = colors.length - 1\n\n  let result = []\n\n  for (let i = 0; i < sections - 1; i++) {\n    result = result.concat(createColorGradient(colors[i], colors[i + 1], Math.max(1, Math.floor(steps / sections))))\n  }\n\n  while (result.length < steps) {\n    result.push(colors[colors.length - 1])\n  }\n\n  return result\n}\n\nexport {\n  hexToRgb,\n  rgbToHex,\n  createColorGradient,\n  createMultiColorGradient,\n  VIRIDIS\n}\n","const mod = (a, b) => {\n  return ((a % b) + b) % b\n}\n\nexport {\n  mod\n}\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","staticClass","proxy","staticRenderFns","components","Day","computed","data","partOne","partTwo","colorGradient","operationsOne","N","pos","S","E","W","L","R","F","operationsTwo","way","tmp","methods","instruction","value","solvePartOne","x","y","angle","points","console","solvePartTwo","drawPath","shapes","type","x0","y0","x1","y1","line","color","width","xMin","yMin","xMax","yMax","xaxis","range","tickfont","gridcolor","yaxis","paper_bgcolor","plot_bgcolor","responsive","staticPlot","displayModeBar","component","VIRIDIS","hexToRgb","hex","result","exec","r","parseInt","g","b","rgbToHex","toString","slice","createColorGradient","one","two","steps","oneRgb","twoRgb","i","iNorm","push","Math","floor","createMultiColorGradient","colors","length","sections","concat","max","mod","a"],"sourceRoot":""}