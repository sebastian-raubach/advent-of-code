{"version":3,"file":"js/5284.d18ba08a.js","mappings":"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","sources":["webpack://advent-of-code/./src/components/2023/Day23.vue?7e65","webpack://advent-of-code/src/components/2023/Day23.vue","webpack://advent-of-code/./src/components/2023/Day23.vue?4872","webpack://advent-of-code/./src/components/2023/Day23.vue","webpack://advent-of-code/./src/util/color.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":23,\"year\":2023,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{staticClass:\"canvas-holder\"},[_c('canvas',{staticClass:\"canvas\",attrs:{\"id\":\"partOne\",\"width\":\"1000\",\"height\":\"1000\"}})]),_c('b-button',{on:{\"click\":_vm.plot}},[_vm._v(\"Redraw\")])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"23\" :year=\"2023\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partOne>\n      <div class=\"canvas-holder\">\n        <canvas id=\"partOne\" class=\"canvas\" width=\"1000\" height=\"1000\" />\n      </div>\n      <b-button @click=\"plot\">Redraw</b-button>\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\nimport { createMultiColorGradient, VIRIDIS } from '@/util/color'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      dirs: [\n        { d: [-1, 0], forbidden: '>' },\n        { d: [1, 0], forbidden: '<' },\n        { d: [0, -1], forbidden: 'v' },\n        { d: [0, 1], forbidden: '^' }\n      ]\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      const grid = {}\n      const start = { x: 0, y: 0 }\n      const end = { x: 0, y: input.length - 1 }\n      this.height = input.length\n      this.width = input[0].length\n      input.forEach((i, y) => {\n        const parts = i.split('')\n        if (y === 0) {\n          start.x = parts.indexOf('.')\n        } else if (y === input.length - 1) {\n          end.x = parts.indexOf('.')\n        }\n        parts.forEach((c, x) => {\n          grid[`${x}|${y}`] = c\n        })\n      })\n\n      this.grid = grid\n      const paths = this.bfs(grid, start, end)\n      this.path = paths[paths.length - 1]\n      this.solutions.partOne = this.path.length - 1\n\n      const crossings = this.convertToGraph(grid)\n      crossings[`${start.x}|${start.y}`] = Object.assign(start, { key: `${start.x}|${start.y}` })\n      crossings[`${end.x}|${end.y}`] = Object.assign(end, { key: `${end.x}|${end.y}` })\n\n      const nodes = Object.values(crossings)\n\n      this.graph = {}\n      Object.keys(crossings).forEach(c => {\n        this.graph[c] = { cost: null, key: c, neighbors: [] }\n      })\n      for (let s = 0; s < nodes.length - 1; s++) {\n        for (let e = s + 1; e < nodes.length; e++) {\n          const p = this.bfs(grid, nodes[s], nodes[e], true)\n          if (p.length > 0) {\n            this.graph[nodes[s].key].neighbors.push({ key: nodes[e].key, cost: p[0].length - 1 })\n            this.graph[nodes[e].key].neighbors.push({ key: nodes[s].key, cost: p[0].length - 1 })\n          }\n        }\n      }\n\n      this.solutions.partTwo = this.getLongestGraph(`${start.x}|${start.y}`, `${end.x}|${end.y}`, new Set())\n\n      this.$nextTick(() => this.plot())\n    },\n    plot: function () {\n      // Initialise the canvas\n      const canvas = document.getElementById('partOne')\n      const factor = 7\n      this.pathIndex = 0\n\n      // Update dimensions based on grid sizes\n      canvas.width = this.width * factor\n      canvas.height = this.height * factor\n\n      const ctx = canvas.getContext('2d')\n\n      this.$nextTick(() => {\n        // Offset for better drawing accuracy\n        ctx.translate(0.5, 0.5)\n        ctx.lineWidth = factor / 2\n\n        ctx.fillStyle = '#57606f'\n        ctx.fillRect(0, 0, canvas.width, canvas.height)\n\n        // Create gradient\n        const gridGradient = createMultiColorGradient(VIRIDIS, this.path.length + 1)\n        const graphGradient = createMultiColorGradient(VIRIDIS, Math.max(...Object.values(this.graph).map(n => Math.max(...n.neighbors.map(nn => nn.cost)))) + 1)\n        ctx.fillStyle = '#2f3542'\n\n        for (let y = 0; y < this.height; y++) {\n          for (let x = 0; x < this.width; x++) {\n            // Fill cells according to elevation\n\n            const cell = this.grid[`${x}|${y}`]\n\n            if (cell === '#') {\n              ctx.fillRect(x * factor, y * factor, factor, factor)\n            }\n          }\n        }\n\n        window.requestAnimationFrame(() => this.plotPath(ctx, factor, gridGradient, graphGradient))\n      })\n    },\n    plotGraph: function (ctx, factor, graphGradient) {\n      Object.values(this.graph).forEach(n => {\n        const [x, y] = n.key.split('|').map(Number)\n\n        this.graph[n.key].neighbors.forEach(nn => {\n          const [nx, ny] = nn.key.split('|').map(Number)\n          ctx.strokeStyle = graphGradient[nn.cost]\n          ctx.beginPath()\n          ctx.moveTo((x + 0.5) * factor, (y + 0.5) * factor)\n          ctx.lineTo((nx + 0.5) * factor, (ny + 0.5) * factor)\n          ctx.stroke()\n        })\n      })\n\n      Object.values(this.graph).forEach(n => {\n        const [x, y] = n.key.split('|').map(Number)\n\n        ctx.fillStyle = 'white'\n        ctx.beginPath()\n        ctx.arc((x + 0.5) * factor, (y + 0.5) * factor, factor / 2, 0, 2 * Math.PI)\n        ctx.fill()\n      })\n    },\n    plotPath: function (ctx, factor, gridGradient, graphGradient) {\n      const p = this.path[this.pathIndex]\n      ctx.fillStyle = gridGradient[this.pathIndex]\n      ctx.fillRect(p.x * factor, p.y * factor, factor, factor)\n\n      this.pathIndex++\n\n      if (this.pathIndex === this.path.length) {\n        window.requestAnimationFrame(() => this.plotGraph(ctx, factor, graphGradient))\n      } else {\n        window.requestAnimationFrame(() => this.plotPath(ctx, factor, gridGradient, graphGradient))\n      }\n    },\n    convertToGraph: function (grid) {\n      const crossings = {}\n\n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          if (grid[`${x}|${y}`] === '.') {\n            const isCrossing = this.dirs.map(d => grid[`${x + d.d[0]}|${y + d.d[1]}`]).filter(c => ['>', '<', 'v', '^'].includes(c)).length > 1\n\n            if (isCrossing) {\n              crossings[`${x}|${y}`] = { x: x, y: y, key: `${x}|${y}` }\n            }\n          }\n        }\n      }\n\n      return crossings\n    },\n    getLongestGraph: function (current, end, visited) {\n      if (current === end) {\n        return 0\n      }\n\n      let maxDistance = Number.MIN_SAFE_INTEGER\n\n      visited.add(current)\n\n      const node = this.graph[current]\n\n      node.neighbors.forEach(n => {\n        if (!visited.has(n.key)) {\n          maxDistance = Math.max(maxDistance, n.cost + this.getLongestGraph(n.key, end, visited))\n        }\n      })\n\n      visited.delete(current)\n\n      return maxDistance\n    },\n    bfs: function (grid, start, end, findShortest = false) {\n      const queue = [{ x: start.x, y: start.y, path: [], visited: new Set() }]\n      queue[0].visited.add(`${start.x}|${start.y}`)\n\n      const paths = []\n\n      while (queue.length > 0) {\n        const current = queue.shift()\n\n        for (const d of this.dirs) {\n          const p = { x: current.x + d.d[0], y: current.y + d.d[1] }\n\n          if (p.x === end.x && p.y === end.y) {\n            // Found a valid path\n            const path = current.path.concat()\n            path.push({ x: current.x, y: current.y })\n            path.push(end)\n\n            if (findShortest) {\n              return [path]\n            } else {\n              paths.push(path)\n            }\n          }\n\n          const c = grid[`${p.x}|${p.y}`]\n\n          const alreadyVisited = current.visited.has(`${p.x}|${p.y}`)\n\n          if (p.x >= 0 && p.x < this.width && p.y >= 0 && p.x < this.height && c !== undefined && c !== '#' && !alreadyVisited) {\n            if (findShortest) {\n              const isCrossing = this.dirs.map(d => grid[`${p.x + d.d[0]}|${p.y + d.d[1]}`]).filter(c => ['>', '<', 'v', '^'].includes(c)).length > 1\n\n              if (isCrossing) {\n                continue\n              }\n            }\n\n            if (!findShortest && c === d.forbidden) {\n              continue\n            }\n            const path = current.path.concat()\n            path.push({ x: current.x, y: current.y })\n            const v = new Set(current.visited)\n            v.add(`${current.x}|${current.y}`)\n            queue.push({ x: p.x, y: p.y, path: path, visited: v })\n          }\n        }\n      }\n\n      return paths\n    }\n  }\n}\n</script>\n\n<style>\n.canvas-holder {\n  overflow: auto;\n  height: 1000px;\n  width: 100%;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day23.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day23.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day23.vue?vue&type=template&id=0b962bfc\"\nimport script from \"./Day23.vue?vue&type=script&lang=js\"\nexport * from \"./Day23.vue?vue&type=script&lang=js\"\nimport style0 from \"./Day23.vue?vue&type=style&index=0&id=0b962bfc&prod&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const VIRIDIS = ['#440154', '#48186a', '#472d7b', '#424086', '#3b528b', '#33638d', '#2c728e', '#26828e', '#21918c', '#1fa088', '#28ae80', '#3fbc73', '#5ec962', '#84d44b', '#addc30', '#d8e219', '#fde725']\n\n/**\n * Converts a HEX value into an RGB object\n * @param {String} hex The hex color\n */\nconst hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    }\n    : null\n}\n\n/**\n * Converts the given R, G, B values into a HEX color\n * @param {Number} r The red color component\n * @param {Number} g The green color component\n * @param {Number} b The blue color component\n */\nconst rgbToHex = (r, g, b) => {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n}\n\n/**\n * Creates a linear gradient between the two given colors with the given number of steps\n * @param {String} one The first color in HEX\n * @param {String} two The second color in HEX\n * @param {Number} steps The number of steps between the two colors\n */\nconst createColorGradient = (one, two, steps) => {\n  const oneRgb = hexToRgb(one)\n  const twoRgb = hexToRgb(two)\n\n  if (steps < 2) {\n    return [one]\n  }\n\n  const result = []\n  for (let i = 0; i < steps; i++) {\n    const iNorm = (i / (steps - 1))\n    result.push(rgbToHex(\n      Math.floor(oneRgb.r + iNorm * (twoRgb.r - oneRgb.r)),\n      Math.floor(oneRgb.g + iNorm * (twoRgb.g - oneRgb.g)),\n      Math.floor(oneRgb.b + iNorm * (twoRgb.b - oneRgb.b))\n    ))\n  }\n  return result\n}\n\nconst createMultiColorGradient = (colors, steps) => {\n  if (colors.length > steps) {\n    return colors.slice(0, steps)\n  }\n\n  const sections = colors.length - 1\n\n  let result = []\n\n  for (let i = 0; i < sections - 1; i++) {\n    result = result.concat(createColorGradient(colors[i], colors[i + 1], Math.max(1, Math.floor(steps / sections))))\n  }\n\n  while (result.length < steps) {\n    result.push(colors[colors.length - 1])\n  }\n\n  return result\n}\n\nexport {\n  hexToRgb,\n  rgbToHex,\n  createColorGradient,\n  createMultiColorGradient,\n  VIRIDIS\n}\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","staticClass","plot","_v","proxy","staticRenderFns","components","Day","data","partOne","partTwo","dirs","d","forbidden","methods","x","y","input","start","end","parts","grid","crossings","Object","cost","neighbors","canvas","ctx","window","plotGraph","plotPath","convertToGraph","getLongestGraph","visited","node","maxDistance","bfs","path","queue","paths","v","component","VIRIDIS","hexToRgb","hex","result","exec","r","parseInt","g","b","rgbToHex","toString","slice","createColorGradient","one","two","steps","oneRgb","twoRgb","i","iNorm","push","Math","floor","createMultiColorGradient","colors","length","sections","concat","max"],"sourceRoot":""}