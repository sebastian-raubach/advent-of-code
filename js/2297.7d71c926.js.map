{"version":3,"file":"js/2297.7d71c926.js","mappings":"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","sources":["webpack://advent-of-code/./src/components/2022/Day8.vue?b37c","webpack://advent-of-code/src/components/2022/Day8.vue","webpack://advent-of-code/./src/components/2022/Day8.vue?1aac","webpack://advent-of-code/./src/components/2022/Day8.vue","webpack://advent-of-code/./src/util/color.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":8,\"year\":2022,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{staticClass:\"canvas-holder\"},[_c('canvas',{staticClass:\"canvas\",attrs:{\"id\":\"partOne\",\"width\":\"991\",\"height\":\"991\"}})])]},proxy:true},{key:\"partTwo\",fn:function(){return [_c('div',{staticClass:\"canvas-holder\"},[_c('canvas',{staticClass:\"canvas\",attrs:{\"id\":\"partTwo\",\"width\":\"991\",\"height\":\"991\"}})])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"8\" :year=\"2022\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partOne>\n      <div class=\"canvas-holder\">\n        <canvas id=\"partOne\" class=\"canvas\" width=\"991\" height=\"991\" />\n      </div>\n    </template>\n    <template v-slot:partTwo>\n      <div class=\"canvas-holder\">\n        <canvas id=\"partTwo\" class=\"canvas\" width=\"991\" height=\"991\" />\n      </div>\n    </template>\n  </Day>\n</template>\n\n<script>\nimport { createColorGradient } from '@/util/color'\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Parse the input into a numeric 2d grid\n      const grid = input.map(i => i.split('').map(c => +c))\n\n      // Remember which cells are visible\n      const visibleGrid = grid.map((r, y) => r.map((c, x) => (y === 0 || x === 0 || y === grid.length - 1 || x === r.length - 1) ? 1 : 0))\n      // Remember the highest viewing score\n      let highestViewingScore = {\n        x: 0,\n        y: 0,\n        score: 0\n      }\n\n      // Iterate the grid\n      for (let y = 1; y < grid.length - 1; y++) {\n        for (let x = 1; x < grid[y].length - 1; x++) {\n          // Get the trees to all four sides (top, right, bottom, left)\n          const sides = this.getSides(grid, x, y)\n\n          // If for ANY side, ALL trees are smaller, then it's visible\n          if (sides.some(s => s.length < 1 || s.every(c => c < grid[y][x]))) {\n            visibleGrid[y][x] = 1\n          }\n\n          // Calculate the viewing score\n          const viewingScore = sides.map(s => {\n            // For each side, sum up the trees that are visible\n            let score = 0\n\n            for (let i = 0; i < s.length; i++) {\n              score++\n\n              if (s[i] >= grid[y][x]) {\n                break\n              }\n            }\n\n            return score\n          }).reduce((a, b) => a * b, 1)\n\n          if (viewingScore > highestViewingScore.score) {\n            // New highest score found\n            highestViewingScore = {\n              x: x,\n              y: y,\n              score: viewingScore\n            }\n          }\n        }\n      }\n\n      // Part one is the count of all visible trees\n      this.solutions.partOne = visibleGrid.reduce((a, b) => a + b.reduce((c, d) => c + d), 0)\n      // Part two is the highest viewing score\n      this.solutions.partTwo = highestViewingScore.score\n\n      // Now draw the result\n      this.$nextTick(() => {\n        this.drawGridOne(grid, visibleGrid)\n        this.drawGridTwo(grid, highestViewingScore)\n      })\n    },\n    getSides: function (grid, x, y) {\n      // Get the trees to all four sides\n      const top = grid.slice(0, y).map(r => r[x]).reverse()\n      const right = grid[y].slice(x + 1, grid[y].length)\n      const bottom = grid.slice(y + 1, grid.length).map(r => r[x])\n      const left = grid[y].slice(0, x).reverse()\n\n      return [top, right, bottom, left]\n    },\n    drawGridOne: function (grid, visible) {\n      // Initialise the canvas\n      const canvas = document.getElementById('partOne')\n      const ctx = canvas.getContext('2d')\n      // Offset for better drawing accuracy\n      ctx.translate(0.5, 0.5)\n      ctx.lineWidth = 1\n\n      // Create gradient\n      const gradient = createColorGradient('#b8e994', '#079992', 10)\n\n      for (let y = 0; y < grid.length; y++) {\n        for (let x = 0; x < grid[y].length; x++) {\n          if (visible[y][x]) {\n            // Draw rectangle around visible trees\n            ctx.strokeStyle = 'black'\n            ctx.rect(x * 10, y * 10, 10, 10)\n            ctx.stroke()\n          }\n          // Fill all of them\n          ctx.fillStyle = gradient[grid[y][x]]\n          ctx.fillRect(x * 10, y * 10, 10, 10)\n        }\n      }\n    },\n    drawGridTwo: function (grid, highest) {\n      // Initialise the canvas\n      const canvas = document.getElementById('partTwo')\n      const ctx = canvas.getContext('2d')\n      // Offset for better drawing accuracy\n      ctx.translate(0.5, 0.5)\n      ctx.lineWidth = 1\n\n      // Create gradients\n      const bgGradient = createColorGradient('#57606f', '#2f3542', 10)\n      const highlightGradient = createColorGradient('#b8e994', '#079992', 10)\n\n      for (let y = 0; y < grid.length; y++) {\n        for (let x = 0; x < grid[y].length; x++) {\n          if (x === highest.x && y === highest.y) {\n            // Highlight highest scoring one\n            ctx.fillStyle = highlightGradient[grid[y][x]]\n            ctx.fillRect(x * 10, y * 10, 10, 10)\n          } else {\n            // Fill all the others with bg gradient\n            ctx.fillStyle = bgGradient[grid[y][x]]\n            ctx.fillRect(x * 10, y * 10, 10, 10)\n          }\n        }\n      }\n\n      // Now highlight all the trees that are visible from here\n      const cell = grid[highest.y][highest.x]\n      for (let y = highest.y + 1; y < grid.length; y++) {\n        ctx.fillStyle = highlightGradient[grid[y][highest.x]]\n        ctx.fillRect(highest.x * 10, y * 10, 10, 10)\n        if (grid[y][highest.x] > cell) {\n          break\n        }\n      }\n      for (let y = highest.y - 1; y >= 0; y--) {\n        ctx.fillStyle = highlightGradient[grid[y][highest.x]]\n        ctx.fillRect(highest.x * 10, y * 10, 10, 10)\n        if (grid[y][highest.x] > cell) {\n          break\n        }\n      }\n      for (let x = highest.x + 1; x < grid[highest.y].length; x++) {\n        ctx.fillStyle = highlightGradient[grid[highest.y][x]]\n        ctx.fillRect(x * 10, highest.y * 10, 10, 10)\n        if (grid[highest.y][x] > cell) {\n          break\n        }\n      }\n      for (let x = highest.x - 1; x >= 0; x--) {\n        ctx.fillStyle = highlightGradient[grid[highest.y][x]]\n        ctx.fillRect(x * 10, highest.y * 10, 10, 10)\n        if (grid[highest.y][x] > cell) {\n          break\n        }\n      }\n    }\n  }\n}\n</script>\n\n<style>\n.canvas-holder {\n  overflow-x: auto;\n  overflow-y: hidden;\n  height: 991px;\n  width: 100%;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day8.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day8.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day8.vue?vue&type=template&id=5393cbcc\"\nimport script from \"./Day8.vue?vue&type=script&lang=js\"\nexport * from \"./Day8.vue?vue&type=script&lang=js\"\nimport style0 from \"./Day8.vue?vue&type=style&index=0&id=5393cbcc&prod&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const VIRIDIS = ['#440154', '#48186a', '#472d7b', '#424086', '#3b528b', '#33638d', '#2c728e', '#26828e', '#21918c', '#1fa088', '#28ae80', '#3fbc73', '#5ec962', '#84d44b', '#addc30', '#d8e219', '#fde725']\n\n/**\n * Converts a HEX value into an RGB object\n * @param {String} hex The hex color\n */\nconst hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    }\n    : null\n}\n\n/**\n * Converts the given R, G, B values into a HEX color\n * @param {Number} r The red color component\n * @param {Number} g The green color component\n * @param {Number} b The blue color component\n */\nconst rgbToHex = (r, g, b) => {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n}\n\n/**\n * Creates a linear gradient between the two given colors with the given number of steps\n * @param {String} one The first color in HEX\n * @param {String} two The second color in HEX\n * @param {Number} steps The number of steps between the two colors\n */\nconst createColorGradient = (one, two, steps) => {\n  const oneRgb = hexToRgb(one)\n  const twoRgb = hexToRgb(two)\n\n  if (steps < 2) {\n    return [one]\n  }\n\n  const result = []\n  for (let i = 0; i < steps; i++) {\n    const iNorm = (i / (steps - 1))\n    result.push(rgbToHex(\n      Math.floor(oneRgb.r + iNorm * (twoRgb.r - oneRgb.r)),\n      Math.floor(oneRgb.g + iNorm * (twoRgb.g - oneRgb.g)),\n      Math.floor(oneRgb.b + iNorm * (twoRgb.b - oneRgb.b))\n    ))\n  }\n  return result\n}\n\nconst createMultiColorGradient = (colors, steps) => {\n  if (colors.length > steps) {\n    return colors.slice(0, steps)\n  }\n\n  const sections = colors.length - 1\n\n  let result = []\n\n  for (let i = 0; i < sections - 1; i++) {\n    result = result.concat(createColorGradient(colors[i], colors[i + 1], Math.max(1, Math.floor(steps / sections))))\n  }\n\n  while (result.length < steps) {\n    result.push(colors[colors.length - 1])\n  }\n\n  return result\n}\n\nexport {\n  hexToRgb,\n  rgbToHex,\n  createColorGradient,\n  createMultiColorGradient,\n  VIRIDIS\n}\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","staticClass","proxy","staticRenderFns","components","Day","data","partOne","partTwo","methods","x","y","score","visibleGrid","highestViewingScore","getSides","drawGridOne","ctx","drawGridTwo","component","VIRIDIS","hexToRgb","hex","result","exec","r","parseInt","g","b","rgbToHex","toString","slice","createColorGradient","one","two","steps","oneRgb","twoRgb","i","iNorm","push","Math","floor","createMultiColorGradient","colors","length","sections","concat","max"],"sourceRoot":""}