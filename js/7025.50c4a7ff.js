"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[7025],{36537:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day14)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day14.vue?vue&type=template&id=1c94dd42\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":14,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day14.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day14vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      memory: {},\n      input: [],\n      masks: []\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Initialize everything\n      this.memory = {};\n      this.input = [];\n      this.masks = [];\n      // Loop through input\n      input.forEach(i => {\n        if (i.indexOf('mask') !== -1) {\n          // If it's a mask, parse it\n          this.masks.push(i.replace('mask = ', '').split(''));\n        } else {\n          // Otherwise, split on the equals\n          const parts = i.split(' = ');\n          // Get the memory index\n          const index = +parts[0].replace(/\\D/g, '');\n          // And get the binary representation of the value\n          const value = this.decimalToBinary(+parts[1], 36);\n          // Then push the configuration to an array\n          this.input.push({\n            index: index,\n            mask: this.masks[this.masks.length - 1],\n            value: value\n          });\n        }\n      });\n      this.solvePartOne();\n\n      // Reset the memory\n      this.memory = {};\n      this.solvePartTwo();\n    },\n    solvePartOne: function () {\n      this.input.forEach(i => {\n        // Set the memory at the given index to the corrected input\n        this.memory[i.index] = parseInt(this.overwriteBits(i.value, i.mask), 2);\n      });\n\n      // Sum over all set memory addresses\n      this.solutions.partOne = Object.keys(this.memory).map(k => this.memory[k]).reduce((a, b) => a + b);\n    },\n    solvePartTwo: function () {\n      // Loop over the input\n      this.input.forEach(i => {\n        // Convert the index to binary representation\n        const addressBits = this.decimalToBinary(i.index, 36).split('');\n        const mask = i.mask;\n\n        // First replace all mask 1's\n        for (let x = 0; x < mask.length; x++) {\n          if (mask[x] === '1') {\n            addressBits[x] = '1';\n          }\n        }\n\n        // Keep track of all final addresses\n        const finalAddresses = [];\n        // Get the number of Xs in the mask\n        const numberOfXs = mask.filter(x => x === 'X').length;\n\n        // Loop through all 2^#Xs combinations\n        for (let x = 0; x < Math.pow(2, numberOfXs); x++) {\n          // Convert the number to a binary\n          // This gives for #X = 2\n          // 00, 01, 10, 11\n          // For #X = 3 this results in\n          // 000, 001, 010, 011, 100, 101, 110, 111\n          // We then use these bits from right to left to fill the Xs in the address\n          const bin = this.decimalToBinary(x, numberOfXs);\n\n          // Copy the current address\n          const copy = JSON.parse(JSON.stringify(addressBits));\n\n          // Walk through the current address from the right, replacing the positions where the mask has an X with the binary representation of the current loop\n          let position = 0;\n          for (let y = addressBits.length - 1; y >= 0; y--) {\n            if (mask[y] === 'X') {\n              copy[y] = bin[bin.length - 1 - position];\n              position++;\n            }\n          }\n\n          // Push the address index\n          finalAddresses.push(parseInt(copy.join(''), 2));\n        }\n\n        // Replace all memory indices with the value\n        finalAddresses.forEach(f => {\n          this.memory[f] = parseInt(i.value, 2);\n        });\n      });\n\n      // Sum over all set memory addresses\n      this.solutions.partTwo = Object.keys(this.memory).map(k => this.memory[k]).reduce((a, b) => a + b);\n    },\n    /**\n     * Converts the given decimal to its binary reprentation enforcing a length of at least `length`\n     * @param dec The decimal number to convert\n     * @param length The minimal length of the binary string representation\n     * @returns The binary string representation of the decimal input with at least the specified length\n     */\n    decimalToBinary: function (dec, length) {\n      let result = (dec >>> 0).toString(2);\n      while (result.length < length) {\n        result = '0' + result;\n      }\n      return result;\n    },\n    /**\n     * Overwrites the positions in the input with the mask bits skipping `X` positions\n     * @param input The input to replace on\n     * @param mask The mask to replace with\n     * @returns The replaced input\n     */\n    overwriteBits: function (input, mask) {\n      return input.split('').map((bit, index) => mask[index] === 'X' ? bit : mask[index]).join('');\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2020/Day14.vue?vue&type=script&lang=js\n /* harmony default export */ const _2020_Day14vue_type_script_lang_js = (Day14vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2020/Day14.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2020_Day14vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day14 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY1MzcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxvQ0FBb0M7QUFDek07Ozs7Ozs7Ozs7OztBQ0tBO0FBRUEsbUVBQWU7RUFDZkE7SUFDQUMsR0FBQUEsRUFBQUEsa0JBQUFBO0VBQ0E7RUFDQUM7SUFDQTtNQUNBQztRQUNBQztRQUNBQztNQUNBO01BQ0FDO01BQ0FDO01BQ0FDO0lBQ0E7RUFDQTtFQUNBQztJQUNBQztNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQUg7UUFDQTtVQUNBO1VBQ0E7UUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7WUFDQUk7WUFDQUM7WUFDQUM7VUFDQTtRQUNBO01BQ0E7TUFFQTs7TUFFQTtNQUNBO01BQ0E7SUFDQTtJQUNBQztNQUNBO1FBQ0E7UUFDQTtNQUNBOztNQUVBO01BQ0E7SUFDQTtJQUNBQztNQUNBO01BQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtVQUNBO1lBQ0FDO1VBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7WUFDQTtjQUNBQztjQUNBQztZQUNBO1VBQ0E7O1VBRUE7VUFDQUM7UUFDQTs7UUFFQTtRQUNBQTtVQUNBO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO0lBQ0E7SUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDQUM7TUFDQTtNQUNBO1FBQ0FDO01BQ0E7TUFFQTtJQUNBO0lBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0FDO01BQ0E7SUFDQTtFQUNBO0FBQ0EsQ0FBQyxFOztBQy9JMlAsQ0FBQyx5RUFBZSw0QkFBRyxFQUFDLEM7Ozs7QUNBN0w7QUFDM0I7QUFDTDs7O0FBR25EO0FBQ0EsQ0FBc0c7QUFDdEcsZ0JBQWdCLHNDQUFVO0FBQzFCLEVBQUUsa0NBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIwL0RheTE0LnZ1ZT84MzUwIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlL3NyYy9jb21wb25lbnRzLzIwMjAvRGF5MTQudnVlP2YyMTciLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIwL0RheTE0LnZ1ZT80NjI5Iiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMC9EYXkxNC52dWU/NGZmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnRGF5Jyx7YXR0cnM6e1wiZGF5XCI6MTQsXCJ5ZWFyXCI6MjAyMCxcInNvbHV0aW9uc1wiOl92bS5zb2x1dGlvbnN9LG9uOntcImlucHV0LWNoYW5nZWRcIjpfdm0ub25JbnB1dENoYW5nZWR9fSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPERheSA6ZGF5PVwiMTRcIiA6eWVhcj1cIjIwMjBcIiA6c29sdXRpb25zPVwic29sdXRpb25zXCIgQGlucHV0LWNoYW5nZWQ9XCJvbklucHV0Q2hhbmdlZFwiPlxuICA8L0RheT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgRGF5IGZyb20gJ0AvY29tcG9uZW50cy9EYXknXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIERheVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvbHV0aW9uczoge1xuICAgICAgICBwYXJ0T25lOiBudWxsLFxuICAgICAgICBwYXJ0VHdvOiBudWxsXG4gICAgICB9LFxuICAgICAgbWVtb3J5OiB7fSxcbiAgICAgIGlucHV0OiBbXSxcbiAgICAgIG1hc2tzOiBbXVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uSW5wdXRDaGFuZ2VkOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIC8vIEluaXRpYWxpemUgZXZlcnl0aGluZ1xuICAgICAgdGhpcy5tZW1vcnkgPSB7fVxuICAgICAgdGhpcy5pbnB1dCA9IFtdXG4gICAgICB0aGlzLm1hc2tzID0gW11cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBpbnB1dFxuICAgICAgaW5wdXQuZm9yRWFjaChpID0+IHtcbiAgICAgICAgaWYgKGkuaW5kZXhPZignbWFzaycpICE9PSAtMSkge1xuICAgICAgICAgIC8vIElmIGl0J3MgYSBtYXNrLCBwYXJzZSBpdFxuICAgICAgICAgIHRoaXMubWFza3MucHVzaChpLnJlcGxhY2UoJ21hc2sgPSAnLCAnJykuc3BsaXQoJycpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgc3BsaXQgb24gdGhlIGVxdWFsc1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gaS5zcGxpdCgnID0gJylcbiAgICAgICAgICAvLyBHZXQgdGhlIG1lbW9yeSBpbmRleFxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gK3BhcnRzWzBdLnJlcGxhY2UoL1xcRC9nLCAnJylcbiAgICAgICAgICAvLyBBbmQgZ2V0IHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRlY2ltYWxUb0JpbmFyeSgrcGFydHNbMV0sIDM2KVxuICAgICAgICAgIC8vIFRoZW4gcHVzaCB0aGUgY29uZmlndXJhdGlvbiB0byBhbiBhcnJheVxuICAgICAgICAgIHRoaXMuaW5wdXQucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBtYXNrOiB0aGlzLm1hc2tzW3RoaXMubWFza3MubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLnNvbHZlUGFydE9uZSgpXG5cbiAgICAgIC8vIFJlc2V0IHRoZSBtZW1vcnlcbiAgICAgIHRoaXMubWVtb3J5ID0ge31cbiAgICAgIHRoaXMuc29sdmVQYXJ0VHdvKClcbiAgICB9LFxuICAgIHNvbHZlUGFydE9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pbnB1dC5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAvLyBTZXQgdGhlIG1lbW9yeSBhdCB0aGUgZ2l2ZW4gaW5kZXggdG8gdGhlIGNvcnJlY3RlZCBpbnB1dFxuICAgICAgICB0aGlzLm1lbW9yeVtpLmluZGV4XSA9IHBhcnNlSW50KHRoaXMub3ZlcndyaXRlQml0cyhpLnZhbHVlLCBpLm1hc2spLCAyKVxuICAgICAgfSlcblxuICAgICAgLy8gU3VtIG92ZXIgYWxsIHNldCBtZW1vcnkgYWRkcmVzc2VzXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gT2JqZWN0LmtleXModGhpcy5tZW1vcnkpLm1hcChrID0+IHRoaXMubWVtb3J5W2tdKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKVxuICAgIH0sXG4gICAgc29sdmVQYXJ0VHdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBMb29wIG92ZXIgdGhlIGlucHV0XG4gICAgICB0aGlzLmlucHV0LmZvckVhY2goaSA9PiB7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGluZGV4IHRvIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCBhZGRyZXNzQml0cyA9IHRoaXMuZGVjaW1hbFRvQmluYXJ5KGkuaW5kZXgsIDM2KS5zcGxpdCgnJylcbiAgICAgICAgY29uc3QgbWFzayA9IGkubWFza1xuXG4gICAgICAgIC8vIEZpcnN0IHJlcGxhY2UgYWxsIG1hc2sgMSdzXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWFzay5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIGlmIChtYXNrW3hdID09PSAnMScpIHtcbiAgICAgICAgICAgIGFkZHJlc3NCaXRzW3hdID0gJzEnXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgZmluYWwgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IGZpbmFsQWRkcmVzc2VzID0gW11cbiAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgWHMgaW4gdGhlIG1hc2tcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZYcyA9IG1hc2suZmlsdGVyKHggPT4geCA9PT0gJ1gnKS5sZW5ndGhcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIDJeI1hzIGNvbWJpbmF0aW9uc1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IE1hdGgucG93KDIsIG51bWJlck9mWHMpOyB4KyspIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgdG8gYSBiaW5hcnlcbiAgICAgICAgICAvLyBUaGlzIGdpdmVzIGZvciAjWCA9IDJcbiAgICAgICAgICAvLyAwMCwgMDEsIDEwLCAxMVxuICAgICAgICAgIC8vIEZvciAjWCA9IDMgdGhpcyByZXN1bHRzIGluXG4gICAgICAgICAgLy8gMDAwLCAwMDEsIDAxMCwgMDExLCAxMDAsIDEwMSwgMTEwLCAxMTFcbiAgICAgICAgICAvLyBXZSB0aGVuIHVzZSB0aGVzZSBiaXRzIGZyb20gcmlnaHQgdG8gbGVmdCB0byBmaWxsIHRoZSBYcyBpbiB0aGUgYWRkcmVzc1xuICAgICAgICAgIGNvbnN0IGJpbiA9IHRoaXMuZGVjaW1hbFRvQmluYXJ5KHgsIG51bWJlck9mWHMpXG5cbiAgICAgICAgICAvLyBDb3B5IHRoZSBjdXJyZW50IGFkZHJlc3NcbiAgICAgICAgICBjb25zdCBjb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhZGRyZXNzQml0cykpXG5cbiAgICAgICAgICAvLyBXYWxrIHRocm91Z2ggdGhlIGN1cnJlbnQgYWRkcmVzcyBmcm9tIHRoZSByaWdodCwgcmVwbGFjaW5nIHRoZSBwb3NpdGlvbnMgd2hlcmUgdGhlIG1hc2sgaGFzIGFuIFggd2l0aCB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxvb3BcbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgICAgICAgZm9yIChsZXQgeSA9IGFkZHJlc3NCaXRzLmxlbmd0aCAtIDE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICAgICAgICBpZiAobWFza1t5XSA9PT0gJ1gnKSB7XG4gICAgICAgICAgICAgIGNvcHlbeV0gPSBiaW5bYmluLmxlbmd0aCAtIDEgLSBwb3NpdGlvbl1cbiAgICAgICAgICAgICAgcG9zaXRpb24rK1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFB1c2ggdGhlIGFkZHJlc3MgaW5kZXhcbiAgICAgICAgICBmaW5hbEFkZHJlc3Nlcy5wdXNoKHBhcnNlSW50KGNvcHkuam9pbignJyksIDIpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgbWVtb3J5IGluZGljZXMgd2l0aCB0aGUgdmFsdWVcbiAgICAgICAgZmluYWxBZGRyZXNzZXMuZm9yRWFjaChmID0+IHtcbiAgICAgICAgICB0aGlzLm1lbW9yeVtmXSA9IHBhcnNlSW50KGkudmFsdWUsIDIpXG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICAvLyBTdW0gb3ZlciBhbGwgc2V0IG1lbW9yeSBhZGRyZXNzZXNcbiAgICAgIHRoaXMuc29sdXRpb25zLnBhcnRUd28gPSBPYmplY3Qua2V5cyh0aGlzLm1lbW9yeSkubWFwKGsgPT4gdGhpcy5tZW1vcnlba10pLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZGVjaW1hbCB0byBpdHMgYmluYXJ5IHJlcHJlbnRhdGlvbiBlbmZvcmNpbmcgYSBsZW5ndGggb2YgYXQgbGVhc3QgYGxlbmd0aGBcbiAgICAgKiBAcGFyYW0gZGVjIFRoZSBkZWNpbWFsIG51bWJlciB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbWluaW1hbCBsZW5ndGggb2YgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJucyBUaGUgYmluYXJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVjaW1hbCBpbnB1dCB3aXRoIGF0IGxlYXN0IHRoZSBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICovXG4gICAgZGVjaW1hbFRvQmluYXJ5OiBmdW5jdGlvbiAoZGVjLCBsZW5ndGgpIHtcbiAgICAgIGxldCByZXN1bHQgPSAoZGVjID4+PiAwKS50b1N0cmluZygyKVxuICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gJzAnICsgcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZXMgdGhlIHBvc2l0aW9ucyBpbiB0aGUgaW5wdXQgd2l0aCB0aGUgbWFzayBiaXRzIHNraXBwaW5nIGBYYCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIHJlcGxhY2Ugb25cbiAgICAgKiBAcGFyYW0gbWFzayBUaGUgbWFzayB0byByZXBsYWNlIHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVwbGFjZWQgaW5wdXRcbiAgICAgKi9cbiAgICBvdmVyd3JpdGVCaXRzOiBmdW5jdGlvbiAoaW5wdXQsIG1hc2spIHtcbiAgICAgIHJldHVybiBpbnB1dC5zcGxpdCgnJykubWFwKChiaXQsIGluZGV4KSA9PiBtYXNrW2luZGV4XSA9PT0gJ1gnID8gYml0IDogbWFza1tpbmRleF0pLmpvaW4oJycpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxNC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkxNC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vRGF5MTQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFjOTRkZDQyXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRGF5MTQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0RheTE0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOlsiY29tcG9uZW50cyIsIkRheSIsImRhdGEiLCJzb2x1dGlvbnMiLCJwYXJ0T25lIiwicGFydFR3byIsIm1lbW9yeSIsImlucHV0IiwibWFza3MiLCJtZXRob2RzIiwib25JbnB1dENoYW5nZWQiLCJpbmRleCIsIm1hc2siLCJ2YWx1ZSIsInNvbHZlUGFydE9uZSIsInNvbHZlUGFydFR3byIsImFkZHJlc3NCaXRzIiwiY29weSIsInBvc2l0aW9uIiwiZmluYWxBZGRyZXNzZXMiLCJkZWNpbWFsVG9CaW5hcnkiLCJyZXN1bHQiLCJvdmVyd3JpdGVCaXRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36537\n")}}]);