{"version":3,"file":"js/2430.20882641.js","mappings":"0KAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCOtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAGA,EACAC,QAAAA,CACAP,eAAAA,SAAAA,GAEA,WACA,2BAEAQ,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IAIA,sBAEA,yCAGA,QAEA,2BACA,4BAEA,SACA,SAIA,wDAGAC,EAAAA,KAAAA,IAAAA,EAAAA,EACA,CAGA,wBACA,EACAC,IAAAA,SAAAA,EAAAA,GAEA,oBAGA,KACA,GAEA,sBACAF,EAAAA,EAAAA,GACAG,EAAAA,EAAAA,GAGA,IAEAC,EAAAA,KAAAA,MAAAA,GACAJ,EAAAA,EAAAA,GACAG,EAAAA,EAAAA,GAEA,UAGA,QACA,EACAE,UAAAA,SAAAA,GACA,gBAEA,8CAGA,CAEA,EACAC,MAAAA,SAAAA,GACA,oBAGA,WACA,OACA,KAEA,2BAuBA,GArBA,YAYAC,GAAAA,GAXAA,GAAAA,EACA,UAEAC,EAAAA,EAEAC,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,EAAAA,OAAAA,IAGAA,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,EAAAA,OAAAA,IAOA,iBACAF,GAAAA,IAIA,uBAEA,mCAEA,SAEA,iGAGAC,EAAAA,KACAC,EAAAA,KACAF,GAAAA,CAEA,CAIA,YACA,EACAG,QAAAA,SAAAA,GACA,oBAGA,QACA,2BASA,GARA,YACAC,IAEA,YACAA,IAIA,KAEA,yBAEA,6CAEA,uBACA,mBAGA,OACA,OACA,KACA,oBACA,8BAqBA,GApBA,YAYAJ,GAAAA,GAXAA,GAAAA,EACA,UAEAE,EAAAA,EAEAD,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IAGAA,EAAAA,KAAAA,IAAAA,EAAAA,EAAAA,IAMA,QACAD,GAAAA,IAIA,uBAEAK,EAAAA,GAAAA,EAAAA,UAAAA,EAAAA,EAAAA,KAAAA,SAAAA,EAAAA,UAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,KAAAA,EAAAA,UAAAA,EAAAA,EAAAA,EAAAA,UACA,KACA,CAGAJ,EAAAA,KACAC,EAAAA,KACAF,GAAAA,EACA,oBACA,2BAqBA,GApBA,YAYAA,GAAAA,GAXAA,GAAAA,EACA,UAEAC,EAAAA,EAEAC,EAAAA,KAAAA,IAAAA,EAAAA,OAAAA,EAAAA,EAAAA,IAGAA,EAAAA,KAAAA,IAAAA,EAAAA,OAAAA,EAAAA,EAAAA,IAMA,iBACAF,GAAAA,IAIA,uBAEAM,EAAAA,GAAAA,EAAAA,UAAAA,EAAAA,KAAAA,SAAAA,EAAAA,UAAAA,EAAAA,IAAAA,EAAAA,KAAAA,EAAAA,UAAAA,EAAAA,EAAAA,UACA,KACA,CAOA,OAHAb,EAAAA,GAAAA,KAAAA,IAGA,MACA,CAIA,YACA,IC3O6P,I,UCOzPc,GAAY,OACd,EACAhC,EACAW,GACA,EACA,KACA,WACA,MAIF,EAAeqB,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2021/Day18.vue?c53f","webpack://advent-of-code/src/components/2021/Day18.vue","webpack://advent-of-code/./src/components/2021/Day18.vue?0727","webpack://advent-of-code/./src/components/2021/Day18.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":18,\"year\":2021,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"18\" :year=\"2021\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Start with the first\n      let current = input[0]\n      for (let i = 1; i < input.length; i++) {\n        // Then stepwise add the other onto it\n        current = this.add(current, input[i])\n      }\n\n      // Convert to an array using the convenient JSON.parse\n      const arr = JSON.parse(current)\n      // Get the magnitude by traversing the tree\n      this.solutions.partOne = this.magnitude(arr)\n\n      // Find the maximum\n      let max = 0\n      // Pairwise comparison of all pairs\n      for (let i = 0; i < input.length; i++) {\n        for (let j = 0; j < input.length; j++) {\n          // Skip same ones\n          if (i === j) {\n            continue\n          }\n\n          // Calculate the magnitude\n          const result = this.magnitude(JSON.parse(this.add(input[i], input[j])))\n\n          // Update maximum\n          max = Math.max(max, result)\n        }\n      }\n\n      this.solutions.partTwo = max\n    },\n    add: function (one, two) {\n      // Create the concatenated array\n      let current = `[${one},${two}]`\n\n      // While we found something to compact\n      let compacting = false\n      do {\n        // Explode first\n        let result = this.explode(current)\n        current = result[0]\n        compacting = result[1]\n\n        // If there was no explosion\n        if (!compacting) {\n          // Check for splits\n          result = this.split(current)\n          current = result[0]\n          compacting = result[1]\n        }\n      } while (compacting)\n\n      // Return the result of the addition\n      return current\n    },\n    magnitude: function (current) {\n      if (isNaN(current)) {\n        // For internal nodes, it's 3 times left plus 2 times right\n        return 3 * this.magnitude(current[0]) + 2 * this.magnitude(current[1])\n      } else {\n        // For leaf nodes, it's the value\n        return current\n      }\n    },\n    split: function (current) {\n      const arr = current.split('')\n\n      // Find numbers that are larger or equal to 10\n      let start = null\n      let end = null\n      let isNumber = false\n      // Go through the string from left to right\n      for (let i = 0; i < arr.length; i++) {\n        // If we find a number\n        if (!isNaN(arr[i])) {\n          isNumber = true\n          if (start === null) {\n            // Set the start (left boundary)\n            start = i\n            // Set an initial value for the end (right boundary)\n            end = Math.min(i + 1, arr.length - 1)\n          } else {\n            // Update the end (right boundary)\n            end = Math.min(i + 1, arr.length - 1)\n          }\n        } else {\n          isNumber = false\n        }\n\n        // We got to the end\n        if (i === arr.length - 1) {\n          isNumber = false\n        }\n\n        // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n        if (!isNumber && start !== null && end !== null) {\n          // Parse the number\n          const n = parseInt(current.substring(start, end))\n\n          if (n >= 10) {\n            // If it's too large, replace it with an array of floor and ceil\n            return [`${current.substring(0, start)}[${Math.floor(n / 2.0)},${Math.ceil(n / 2.0)}]${current.substring(end, current.length)}`, true]\n          } else {\n            // If it's too small, continue searching\n            start = null\n            end = null\n            isNumber = false\n          }\n        }\n      }\n\n      // Indicate we didn't split\n      return [current, false]\n    },\n    explode: function (current) {\n      const arr = current.split('')\n\n      // Count the level by keeping track of opening and closing brackets\n      let openCount = 0\n      for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === '[') {\n          openCount++\n        }\n        if (arr[i] === ']') {\n          openCount--\n        }\n\n        // We found one that's \"too deep\"\n        if (openCount > 4) {\n          // Get the end index\n          const endIndex = current.indexOf(']', i)\n          // Parse the number pair\n          const pair = current.substring(i + 1, endIndex).split(',').map(c => +c)\n          // Get the left and the right substrings for later\n          let left = current.substring(0, i)\n          let right = current.substring(endIndex + 1)\n\n          // Go from the found index towards the left to find the first number and increase it\n          let start = null\n          let end = null\n          let isNumber = false\n          const leftArr = left.split('')\n          for (let l = leftArr.length - 1; l >= 0; l--) {\n            if (!isNaN(leftArr[l])) {\n              isNumber = true\n              if (end === null) {\n                // We found the right border\n                end = l\n                // Initialise the left border\n                start = Math.max(0, l - 1)\n              } else {\n                // Update the left border\n                start = Math.max(0, l - 1)\n              }\n            } else {\n              isNumber = false\n            }\n\n            if (l === 0) {\n              isNumber = false\n            }\n\n            // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n            if (!isNumber && start !== null && end !== null) {\n              // Update the left side by increasing the number value\n              left = `${left.substring(0, start + 1)}${parseInt(left.substring(start + 1, end + 1)) + pair[0]}${left.substring(end + 1, left.length)}`\n              break\n            }\n          }\n\n          start = null\n          end = null\n          isNumber = false\n          const rightArr = right.split('')\n          for (let r = 0; r < rightArr.length; r++) {\n            if (!isNaN(rightArr[r])) {\n              isNumber = true\n              if (start === null) {\n                // We found the left border\n                start = r\n                // Initialise the left border\n                end = Math.min(rightArr.length - 1, r + 1)\n              } else {\n                // Update the left border\n                end = Math.min(rightArr.length - 1, r + 1)\n              }\n            } else {\n              isNumber = false\n            }\n\n            if (r === rightArr.length - 1) {\n              isNumber = false\n            }\n\n            // If we're no longer in the process of parsing a multi-digit number and we found a start and an end\n            if (!isNumber && start !== null && end !== null) {\n              // Update the right side by increasing the number value\n              right = `${right.substring(0, start)}${parseInt(right.substring(start, end)) + pair[1]}${right.substring(end, right.length)}`\n              break\n            }\n          }\n\n          // Reconstitute the whole string by setting a zero in the middle\n          current = `${left}0${right}`\n\n          // Indicate we exploded\n          return [current, true]\n        }\n      }\n\n      // Indicate we didn't explode\n      return [current, false]\n    }\n  }\n}\n</script>\n\n<style scoped>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day18.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day18.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day18.vue?vue&type=template&id=4850715e&scoped=true\"\nimport script from \"./Day18.vue?vue&type=script&lang=js\"\nexport * from \"./Day18.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"4850715e\",\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","methods","current","max","add","compacting","result","magnitude","split","isNumber","start","end","explode","openCount","left","right","component"],"sourceRoot":""}