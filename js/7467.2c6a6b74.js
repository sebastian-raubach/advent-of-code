"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[7467],{26945:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ Day4)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day4.vue?vue&type=template&id=3f226825\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'Day\',{attrs:{"day":4,"year":2021,"solutions":_vm.solutions},on:{"input-changed":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2021/Day4.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day4vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.solutions = {\n        partOne: null,\n        partTwo: null\n      };\n      const numbers = input[0].split(\',\').map(i => +i);\n      const grids = [];\n      let current = [];\n\n      // Parse the grids\n      for (let i = 2; i < input.length; i++) {\n        if (input[i].length < 1) {\n          grids.push(current);\n          current = [];\n        } else {\n          current.push(input[i].trim().split(/\\s+/).map(n => {\n            return {\n              n: +n,\n              m: false\n            };\n          }));\n        }\n      }\n      grids.push(current);\n\n      // Remember which grids are complete\n      const gridsComplete = grids.map(_ => false);\n      for (let i = 0; i < numbers.length; i++) {\n        // Mark the numbers and get back the sum of non-marked values or `undefined` if not complete\n        const complete = this.markNumber(grids, numbers[i]);\n        // Check if any of them are actually complete\n        const anyComplete = complete.filter(g => g);\n        if (anyComplete.length > 0 && !this.solutions.partOne) {\n          // If at least one is complete and we\'ve not found solution 1 yet, this is it\n          this.solutions.partOne = anyComplete[0] * numbers[i];\n          // Mark as complete\n          gridsComplete[complete.indexOf(anyComplete[0])] = true;\n        } else {\n          // Otherwise, check if all are now complete\n          let allComplete = true;\n          // Get the index of the last one\n          let lastIndex = -1;\n          for (let g = 0; g < grids.length; g++) {\n            // Check if this one is also complete\n            allComplete &= complete[g] !== undefined;\n            // If it wasn\'t complete before, but it is now\n            if (!gridsComplete[g] && complete[g]) {\n              // Remember the index\n              lastIndex = g;\n              // Mark as complete\n              gridsComplete[g] = true;\n            }\n          }\n\n          // If all are complete after this iteration, we found our solution 2\n          if (allComplete) {\n            this.solutions.partTwo = complete[lastIndex] * numbers[i];\n            break;\n          }\n        }\n      }\n    },\n    markNumber: function (grids, number) {\n      return grids.map(g => {\n        g.forEach(r => {\n          r.forEach(n => {\n            // Change the marked state\n            n.m |= n.n === number;\n          });\n        });\n        return this.isComplete(g);\n      });\n    },\n    isComplete: function (grid) {\n      // Check if any row or column is complete\n      const rowComplete = grid.filter(r => r.filter(r => r.m).length === r.length).length > 0;\n      const colComplete = grid[0].filter((c, index) => grid.filter(r => r[index].m).length === grid.length).length > 0;\n      if (rowComplete || colComplete) {\n        // Calculate the sum of all non-marked items\n        return grid.reduce((prev, row) => prev + row.map(c => c.m ? 0 : c.n).reduce((a, b) => a + b), 0);\n      } else {\n        return undefined;\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2021/Day4.vue?vue&type=script&lang=js\n /* harmony default export */ const _2021_Day4vue_type_script_lang_js = (Day4vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2021/Day4.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2021_Day4vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day4 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY5NDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTyw4Q0FBOEMsS0FBSyxvQ0FBb0M7QUFDeE07Ozs7Ozs7Ozs7OztBQ0tBO0FBRUEsa0VBQWU7RUFDZkE7SUFDQUMsR0FBQUEsRUFBQUEsa0JBQUFBO0VBQ0E7RUFDQUM7SUFDQTtNQUNBQztRQUNBQztRQUNBQztNQUNBO0lBQ0E7RUFDQTtFQUNBQztJQUNBQztNQUNBO1FBQ0FIO1FBQ0FDO01BQ0E7TUFDQTtNQUVBO01BQ0E7O01BRUE7TUFDQTtRQUNBO1VBQ0FHO1VBQ0FDO1FBQ0E7VUFDQUE7WUFDQTtjQUNBQztjQUNBQztZQUNBO1VBQ0E7UUFDQTtNQUNBO01BRUFIOztNQUVBO01BQ0E7TUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQUk7UUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7WUFDQTtZQUNBQztZQUNBO1lBQ0E7Y0FDQTtjQUNBQztjQUNBO2NBQ0FGO1lBQ0E7VUFDQTs7VUFFQTtVQUNBO1lBQ0E7WUFDQTtVQUNBO1FBQ0E7TUFDQTtJQUNBO0lBQ0FHO01BQ0E7UUFDQUM7VUFDQUM7WUFDQTtZQUNBUDtVQUNBO1FBQ0E7UUFFQTtNQUNBO0lBQ0E7SUFDQVE7TUFDQTtNQUNBO01BQ0E7TUFFQTtRQUNBO1FBQ0E7TUFDQTtRQUNBO01BQ0E7SUFDQTtFQUNBO0FBQ0EsQ0FBQyxFOztBQ2hIMFAsQ0FBQyx3RUFBZSwyQkFBRyxFQUFDLEM7Ozs7QUNBN0w7QUFDM0I7QUFDTDs7O0FBR2xEO0FBQ0EsQ0FBc0c7QUFDdEcsZ0JBQWdCLHNDQUFVO0FBQzFCLEVBQUUsaUNBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIxL0RheTQudnVlPzBmM2QiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvc3JjL2NvbXBvbmVudHMvMjAyMS9EYXk0LnZ1ZT8wM2IwIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXk0LnZ1ZT9lZTQyIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMS9EYXk0LnZ1ZT9iM2UwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdEYXknLHthdHRyczp7XCJkYXlcIjo0LFwieWVhclwiOjIwMjEsXCJzb2x1dGlvbnNcIjpfdm0uc29sdXRpb25zfSxvbjp7XCJpbnB1dC1jaGFuZ2VkXCI6X3ZtLm9uSW5wdXRDaGFuZ2VkfX0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxEYXkgOmRheT1cIjRcIiA6eWVhcj1cIjIwMjFcIiA6c29sdXRpb25zPVwic29sdXRpb25zXCIgQGlucHV0LWNoYW5nZWQ9XCJvbklucHV0Q2hhbmdlZFwiPlxuICA8L0RheT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgRGF5IGZyb20gJ0AvY29tcG9uZW50cy9EYXknXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIERheVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvbHV0aW9uczoge1xuICAgICAgICBwYXJ0T25lOiBudWxsLFxuICAgICAgICBwYXJ0VHdvOiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25JbnB1dENoYW5nZWQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdGhpcy5zb2x1dGlvbnMgPSB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH1cbiAgICAgIGNvbnN0IG51bWJlcnMgPSBpbnB1dFswXS5zcGxpdCgnLCcpLm1hcChpID0+ICtpKVxuXG4gICAgICBjb25zdCBncmlkcyA9IFtdXG4gICAgICBsZXQgY3VycmVudCA9IFtdXG5cbiAgICAgIC8vIFBhcnNlIHRoZSBncmlkc1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRbaV0ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIGdyaWRzLnB1c2goY3VycmVudClcbiAgICAgICAgICBjdXJyZW50ID0gW11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LnB1c2goaW5wdXRbaV0udHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKG4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbjogK24sXG4gICAgICAgICAgICAgIG06IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ3JpZHMucHVzaChjdXJyZW50KVxuXG4gICAgICAvLyBSZW1lbWJlciB3aGljaCBncmlkcyBhcmUgY29tcGxldGVcbiAgICAgIGNvbnN0IGdyaWRzQ29tcGxldGUgPSBncmlkcy5tYXAoXyA9PiBmYWxzZSlcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIG51bWJlcnMgYW5kIGdldCBiYWNrIHRoZSBzdW0gb2Ygbm9uLW1hcmtlZCB2YWx1ZXMgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGNvbXBsZXRlXG4gICAgICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5tYXJrTnVtYmVyKGdyaWRzLCBudW1iZXJzW2ldKVxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlbSBhcmUgYWN0dWFsbHkgY29tcGxldGVcbiAgICAgICAgY29uc3QgYW55Q29tcGxldGUgPSBjb21wbGV0ZS5maWx0ZXIoZyA9PiBnKVxuXG4gICAgICAgIGlmIChhbnlDb21wbGV0ZS5sZW5ndGggPiAwICYmICF0aGlzLnNvbHV0aW9ucy5wYXJ0T25lKSB7XG4gICAgICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIGlzIGNvbXBsZXRlIGFuZCB3ZSd2ZSBub3QgZm91bmQgc29sdXRpb24gMSB5ZXQsIHRoaXMgaXMgaXRcbiAgICAgICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0T25lID0gYW55Q29tcGxldGVbMF0gKiBudW1iZXJzW2ldXG4gICAgICAgICAgLy8gTWFyayBhcyBjb21wbGV0ZVxuICAgICAgICAgIGdyaWRzQ29tcGxldGVbY29tcGxldGUuaW5kZXhPZihhbnlDb21wbGV0ZVswXSldID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgYWxsIGFyZSBub3cgY29tcGxldGVcbiAgICAgICAgICBsZXQgYWxsQ29tcGxldGUgPSB0cnVlXG4gICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvbmVcbiAgICAgICAgICBsZXQgbGFzdEluZGV4ID0gLTFcbiAgICAgICAgICBmb3IgKGxldCBnID0gMDsgZyA8IGdyaWRzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIG9uZSBpcyBhbHNvIGNvbXBsZXRlXG4gICAgICAgICAgICBhbGxDb21wbGV0ZSAmPSBjb21wbGV0ZVtnXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBJZiBpdCB3YXNuJ3QgY29tcGxldGUgYmVmb3JlLCBidXQgaXQgaXMgbm93XG4gICAgICAgICAgICBpZiAoIWdyaWRzQ29tcGxldGVbZ10gJiYgY29tcGxldGVbZ10pIHtcbiAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGluZGV4XG4gICAgICAgICAgICAgIGxhc3RJbmRleCA9IGdcbiAgICAgICAgICAgICAgLy8gTWFyayBhcyBjb21wbGV0ZVxuICAgICAgICAgICAgICBncmlkc0NvbXBsZXRlW2ddID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGFsbCBhcmUgY29tcGxldGUgYWZ0ZXIgdGhpcyBpdGVyYXRpb24sIHdlIGZvdW5kIG91ciBzb2x1dGlvbiAyXG4gICAgICAgICAgaWYgKGFsbENvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gY29tcGxldGVbbGFzdEluZGV4XSAqIG51bWJlcnNbaV1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXJrTnVtYmVyOiBmdW5jdGlvbiAoZ3JpZHMsIG51bWJlcikge1xuICAgICAgcmV0dXJuIGdyaWRzLm1hcChnID0+IHtcbiAgICAgICAgZy5mb3JFYWNoKHIgPT4ge1xuICAgICAgICAgIHIuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgbWFya2VkIHN0YXRlXG4gICAgICAgICAgICBuLm0gfD0gbi5uID09PSBudW1iZXJcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB0aGlzLmlzQ29tcGxldGUoZylcbiAgICAgIH0pXG4gICAgfSxcbiAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbiAoZ3JpZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgYW55IHJvdyBvciBjb2x1bW4gaXMgY29tcGxldGVcbiAgICAgIGNvbnN0IHJvd0NvbXBsZXRlID0gZ3JpZC5maWx0ZXIociA9PiByLmZpbHRlcihyID0+IHIubSkubGVuZ3RoID09PSByLmxlbmd0aCkubGVuZ3RoID4gMFxuICAgICAgY29uc3QgY29sQ29tcGxldGUgPSBncmlkWzBdLmZpbHRlcigoYywgaW5kZXgpID0+IGdyaWQuZmlsdGVyKHIgPT4gcltpbmRleF0ubSkubGVuZ3RoID09PSBncmlkLmxlbmd0aCkubGVuZ3RoID4gMFxuXG4gICAgICBpZiAocm93Q29tcGxldGUgfHwgY29sQ29tcGxldGUpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2YgYWxsIG5vbi1tYXJrZWQgaXRlbXNcbiAgICAgICAgcmV0dXJuIGdyaWQucmVkdWNlKChwcmV2LCByb3cpID0+IHByZXYgKyByb3cubWFwKGMgPT4gYy5tID8gMCA6IGMubikucmVkdWNlKChhLCBiKSA9PiBhICsgYiksIDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXk0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0RheTQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTNmMjI2ODI1XCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRGF5NC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5NC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm5hbWVzIjpbImNvbXBvbmVudHMiLCJEYXkiLCJkYXRhIiwic29sdXRpb25zIiwicGFydE9uZSIsInBhcnRUd28iLCJtZXRob2RzIiwib25JbnB1dENoYW5nZWQiLCJncmlkcyIsImN1cnJlbnQiLCJuIiwibSIsImdyaWRzQ29tcGxldGUiLCJhbGxDb21wbGV0ZSIsImxhc3RJbmRleCIsIm1hcmtOdW1iZXIiLCJnIiwiciIsImlzQ29tcGxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26945\n')}}]);