"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[5051],{3898:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day16)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day16.vue?vue&type=template&id=1b4075ae\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":16,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(36100);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day16.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const Day16vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      }\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.parseInput(input);\n      this.solvePartOne();\n      this.solvePartTwo();\n    },\n    parseInput: function (input) {\n      this.ourTicket = null;\n      this.nearbyTickets = [];\n      this.fields = {};\n      let part = 0;\n      for (let i = 0; i < input.length; i++) {\n        // Empty rows indicate a new section\n        if (input[i] === '') {\n          part++;\n          continue;\n        }\n\n        // Skip ticket rows\n        if (input[i].indexOf('ticket') !== -1) {\n          continue;\n        }\n\n        // Handle the row depending on which part we're in\n        switch (part) {\n          case 0:\n            {\n              // Split the field and value\n              const parts = input[i].split(': ');\n              // Split the value ranges\n              const ranges = parts[1].split(' or ');\n              // Remember the field to range mapping\n              this.fields[parts[0]] = ranges.map(r => r.split('-').map(l => +l));\n              break;\n            }\n          case 1:\n            // This is our ticket, just split it\n            this.ourTicket = input[i].split(',').map(n => +n);\n            break;\n          case 2:\n            // These are other tickets, simply split them\n            this.nearbyTickets.push(input[i].split(',').map(n => +n));\n            break;\n        }\n      }\n    },\n    /**\n     * Checks whether the given ticket is valid\n     * @param t The ticket to check\n     * @returns `true` if the ticket is valid, `false` otherwise\n     */\n    isTicketValid: function (t) {\n      // Check if for EVERY value, there exists SOME field that has a valid range this value falls into\n      return t.every(v => Object.keys(this.fields).some(f => this.fields[f].some(r => r[0] <= v && r[1] >= v)));\n    },\n    solvePartOne: function () {\n      // Map all tickets to the sum of their invalid values\n      const filtered = this.nearbyTickets.map(t => {\n        // Filter out all valid values\n        const innerFiltered = t.filter(v => {\n          // Check if there's a field that matches the value\n          let found = false;\n          Object.keys(this.fields).forEach(f => {\n            if (this.fields[f].some(a => a[0] <= v && a[1] >= v)) {\n              found = true;\n            }\n          });\n          // If there is a match, don't include this one\n          return !found;\n        });\n        // Sum up all invalid values (PER TICKET)\n        return innerFiltered.reduce((a, b) => a + b, 0);\n      });\n\n      // Sum up all invalid values (ACROSS TICKETS)\n      this.solutions.partOne = filtered.reduce((a, b) => a + b);\n    },\n    solvePartTwo: function () {\n      // Remove invalid tickets\n      const validTickets = this.nearbyTickets.filter(t => this.isTicketValid(t));\n\n      // Get all distinct values for each position/field/column\n      const positionValues = Object.keys(this.fields).map((f, i) => {\n        const values = new Set();\n        validTickets.forEach(t => values.add(t[i]));\n        return Array.from(values);\n      });\n\n      // Create a copy of the fields, as we'll be deleting keys\n      const fieldCopy = JSON.parse(JSON.stringify(this.fields));\n      // Remember the mapping of field name to index\n      const fieldMapping = {};\n      // Get all position/field/column indices\n      let indices = Array.from(Array(Object.keys(fieldCopy).length).keys()).map(i => i);\n\n      // While there is an index that still hasn't been matched\n      while (indices.length > 0) {\n        // Map each index to the list of matching fields\n        const matchingFields = indices.map(i => {\n          return {\n            index: i,\n            // Filter the fields down to those where EVERY column value is in SOME of the ranges\n            matches: Object.keys(fieldCopy).filter(f => {\n              return positionValues[i].every(v => fieldCopy[f].some(a => a[0] <= v && a[1] >= v));\n            })\n          };\n        });\n\n        // Now, for each matching field\n        matchingFields.forEach(f => {\n          // If there is only one match, there's a unique mapping\n          if (f.matches.length === 1) {\n            // Remember the mapping\n            fieldMapping[f.matches[0]] = f.index;\n            // Delete this field, so we won't consider it again\n            delete fieldCopy[f.matches[0]];\n            // And delete the column index, as we've mapped it\n            indices = indices.filter(j => f.index !== j);\n          }\n        });\n      }\n\n      // The solution is using all fields containing 'departure' and multiplying their values together\n      this.solutions.partTwo = Object.keys(fieldMapping).filter(k => k.includes('departure')).map(k => this.ourTicket[fieldMapping[k]]).reduce((a, b) => a * b, 1);\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2020/Day16.vue?vue&type=script&lang=js\n /* harmony default export */ const _2020_Day16vue_type_script_lang_js = (Day16vue_type_script_lang_js); \n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2020/Day16.vue\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2020_Day16vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day16 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg5OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQixPQUFPLCtDQUErQyxLQUFLLG9DQUFvQztBQUN6TTs7Ozs7Ozs7Ozs7O0FDS0E7QUFFQSxtRUFBZTtFQUNmQTtJQUNBQyxHQUFBQSxFQUFBQSxrQkFBQUE7RUFDQTtFQUNBQztJQUNBO01BQ0FDO1FBQ0FDO1FBQ0FDO01BQ0E7SUFDQTtFQUNBO0VBQ0FDO0lBQ0FDO01BQ0E7TUFDQTtNQUNBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBO01BQ0E7TUFFQTtNQUNBO1FBQ0E7UUFDQTtVQUNBQztVQUNBO1FBQ0E7O1FBRUE7UUFDQTtVQUNBO1FBQ0E7O1FBRUE7UUFDQTtVQUNBO1lBQUE7Y0FDQTtjQUNBO2NBQ0E7Y0FDQTtjQUNBO2NBQ0E7Y0FDQTtZQUNBO1VBQ0E7WUFDQTtZQUNBO1lBQ0E7VUFDQTtZQUNBO1lBQ0E7WUFDQTtRQUNBO01BQ0E7SUFDQTtJQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDQUM7TUFDQTtNQUNBO0lBQ0E7SUFDQUM7TUFDQTtNQUNBO1FBQ0E7UUFDQTtVQUNBO1VBQ0E7VUFDQUM7WUFDQTtjQUNBQztZQUNBO1VBQ0E7VUFDQTtVQUNBO1FBQ0E7UUFDQTtRQUNBO01BQ0E7O01BRUE7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTs7TUFFQTtNQUNBO1FBQ0E7UUFDQUM7UUFDQTtNQUNBOztNQUVBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7TUFFQTtNQUNBO1FBQ0E7UUFDQTtVQUNBO1lBQ0FDO1lBQ0E7WUFDQUM7Y0FDQTtZQUNBO1VBQ0E7UUFDQTs7UUFFQTtRQUNBQztVQUNBO1VBQ0E7WUFDQTtZQUNBQztZQUNBO1lBQ0E7WUFDQTtZQUNBQztVQUNBO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO0lBQ0E7RUFDQTtBQUNBLENBQUMsRTs7QUNsSjJQLENBQUMseUVBQWUsNEJBQUcsRUFBQyxDOzs7O0FDQTdMO0FBQzNCO0FBQ0w7OztBQUduRDtBQUNBLENBQXNHO0FBQ3RHLGdCQUFnQixzQ0FBVTtBQUMxQixFQUFFLGtDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMC9EYXkxNi52dWU/YWY5NSIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS9zcmMvY29tcG9uZW50cy8yMDIwL0RheTE2LnZ1ZT9mM2FkIiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAyMC9EYXkxNi52dWU/NjhjNyIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjAvRGF5MTYudnVlPzQxYzciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ0RheScse2F0dHJzOntcImRheVwiOjE2LFwieWVhclwiOjIwMjAsXCJzb2x1dGlvbnNcIjpfdm0uc29sdXRpb25zfSxvbjp7XCJpbnB1dC1jaGFuZ2VkXCI6X3ZtLm9uSW5wdXRDaGFuZ2VkfX0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxEYXkgOmRheT1cIjE2XCIgOnllYXI9XCIyMDIwXCIgOnNvbHV0aW9ucz1cInNvbHV0aW9uc1wiIEBpbnB1dC1jaGFuZ2VkPVwib25JbnB1dENoYW5nZWRcIj5cbiAgPC9EYXk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IERheSBmcm9tICdAL2NvbXBvbmVudHMvRGF5J1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBEYXlcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb2x1dGlvbnM6IHtcbiAgICAgICAgcGFydE9uZTogbnVsbCxcbiAgICAgICAgcGFydFR3bzogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uSW5wdXRDaGFuZ2VkOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHRoaXMucGFyc2VJbnB1dChpbnB1dClcbiAgICAgIHRoaXMuc29sdmVQYXJ0T25lKClcbiAgICAgIHRoaXMuc29sdmVQYXJ0VHdvKClcbiAgICB9LFxuICAgIHBhcnNlSW5wdXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgdGhpcy5vdXJUaWNrZXQgPSBudWxsXG4gICAgICB0aGlzLm5lYXJieVRpY2tldHMgPSBbXVxuICAgICAgdGhpcy5maWVsZHMgPSB7fVxuXG4gICAgICBsZXQgcGFydCA9IDBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRW1wdHkgcm93cyBpbmRpY2F0ZSBhIG5ldyBzZWN0aW9uXG4gICAgICAgIGlmIChpbnB1dFtpXSA9PT0gJycpIHtcbiAgICAgICAgICBwYXJ0KytcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCB0aWNrZXQgcm93c1xuICAgICAgICBpZiAoaW5wdXRbaV0uaW5kZXhPZigndGlja2V0JykgIT09IC0xKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgcm93IGRlcGVuZGluZyBvbiB3aGljaCBwYXJ0IHdlJ3JlIGluXG4gICAgICAgIHN3aXRjaCAocGFydCkge1xuICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIGZpZWxkIGFuZCB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBpbnB1dFtpXS5zcGxpdCgnOiAnKVxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHZhbHVlIHJhbmdlc1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gcGFydHNbMV0uc3BsaXQoJyBvciAnKVxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGZpZWxkIHRvIHJhbmdlIG1hcHBpbmdcbiAgICAgICAgICAgIHRoaXMuZmllbGRzW3BhcnRzWzBdXSA9IHJhbmdlcy5tYXAociA9PiByLnNwbGl0KCctJykubWFwKGwgPT4gK2wpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBvdXIgdGlja2V0LCBqdXN0IHNwbGl0IGl0XG4gICAgICAgICAgICB0aGlzLm91clRpY2tldCA9IGlucHV0W2ldLnNwbGl0KCcsJykubWFwKG4gPT4gK24pXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBvdGhlciB0aWNrZXRzLCBzaW1wbHkgc3BsaXQgdGhlbVxuICAgICAgICAgICAgdGhpcy5uZWFyYnlUaWNrZXRzLnB1c2goaW5wdXRbaV0uc3BsaXQoJywnKS5tYXAobiA9PiArbikpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdGlja2V0IGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHQgVGhlIHRpY2tldCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGlja2V0IGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzVGlja2V0VmFsaWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAvLyBDaGVjayBpZiBmb3IgRVZFUlkgdmFsdWUsIHRoZXJlIGV4aXN0cyBTT01FIGZpZWxkIHRoYXQgaGFzIGEgdmFsaWQgcmFuZ2UgdGhpcyB2YWx1ZSBmYWxscyBpbnRvXG4gICAgICByZXR1cm4gdC5ldmVyeSh2ID0+IE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKS5zb21lKGYgPT4gdGhpcy5maWVsZHNbZl0uc29tZShyID0+IHJbMF0gPD0gdiAmJiByWzFdID49IHYpKSlcbiAgICB9LFxuICAgIHNvbHZlUGFydE9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTWFwIGFsbCB0aWNrZXRzIHRvIHRoZSBzdW0gb2YgdGhlaXIgaW52YWxpZCB2YWx1ZXNcbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gdGhpcy5uZWFyYnlUaWNrZXRzLm1hcCh0ID0+IHtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBhbGwgdmFsaWQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGlubmVyRmlsdGVyZWQgPSB0LmZpbHRlcih2ID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgZmllbGQgdGhhdCBtYXRjaGVzIHRoZSB2YWx1ZVxuICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgT2JqZWN0LmtleXModGhpcy5maWVsZHMpLmZvckVhY2goZiA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWVsZHNbZl0uc29tZShhID0+IGFbMF0gPD0gdiAmJiBhWzFdID49IHYpKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBtYXRjaCwgZG9uJ3QgaW5jbHVkZSB0aGlzIG9uZVxuICAgICAgICAgIHJldHVybiAhZm91bmRcbiAgICAgICAgfSlcbiAgICAgICAgLy8gU3VtIHVwIGFsbCBpbnZhbGlkIHZhbHVlcyAoUEVSIFRJQ0tFVClcbiAgICAgICAgcmV0dXJuIGlubmVyRmlsdGVyZWQucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgICAgIH0pXG5cbiAgICAgIC8vIFN1bSB1cCBhbGwgaW52YWxpZCB2YWx1ZXMgKEFDUk9TUyBUSUNLRVRTKVxuICAgICAgdGhpcy5zb2x1dGlvbnMucGFydE9uZSA9IGZpbHRlcmVkLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpXG4gICAgfSxcbiAgICBzb2x2ZVBhcnRUd286IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFJlbW92ZSBpbnZhbGlkIHRpY2tldHNcbiAgICAgIGNvbnN0IHZhbGlkVGlja2V0cyA9IHRoaXMubmVhcmJ5VGlja2V0cy5maWx0ZXIodCA9PiB0aGlzLmlzVGlja2V0VmFsaWQodCkpXG5cbiAgICAgIC8vIEdldCBhbGwgZGlzdGluY3QgdmFsdWVzIGZvciBlYWNoIHBvc2l0aW9uL2ZpZWxkL2NvbHVtblxuICAgICAgY29uc3QgcG9zaXRpb25WYWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcykubWFwKChmLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoKVxuICAgICAgICB2YWxpZFRpY2tldHMuZm9yRWFjaCh0ID0+IHZhbHVlcy5hZGQodFtpXSkpXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlcylcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGZpZWxkcywgYXMgd2UnbGwgYmUgZGVsZXRpbmcga2V5c1xuICAgICAgY29uc3QgZmllbGRDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmZpZWxkcykpXG4gICAgICAvLyBSZW1lbWJlciB0aGUgbWFwcGluZyBvZiBmaWVsZCBuYW1lIHRvIGluZGV4XG4gICAgICBjb25zdCBmaWVsZE1hcHBpbmcgPSB7fVxuICAgICAgLy8gR2V0IGFsbCBwb3NpdGlvbi9maWVsZC9jb2x1bW4gaW5kaWNlc1xuICAgICAgbGV0IGluZGljZXMgPSBBcnJheS5mcm9tKEFycmF5KE9iamVjdC5rZXlzKGZpZWxkQ29weSkubGVuZ3RoKS5rZXlzKCkpLm1hcChpID0+IGkpXG5cbiAgICAgIC8vIFdoaWxlIHRoZXJlIGlzIGFuIGluZGV4IHRoYXQgc3RpbGwgaGFzbid0IGJlZW4gbWF0Y2hlZFxuICAgICAgd2hpbGUgKGluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBNYXAgZWFjaCBpbmRleCB0byB0aGUgbGlzdCBvZiBtYXRjaGluZyBmaWVsZHNcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdGaWVsZHMgPSBpbmRpY2VzLm1hcChpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGZpZWxkcyBkb3duIHRvIHRob3NlIHdoZXJlIEVWRVJZIGNvbHVtbiB2YWx1ZSBpcyBpbiBTT01FIG9mIHRoZSByYW5nZXNcbiAgICAgICAgICAgIG1hdGNoZXM6IE9iamVjdC5rZXlzKGZpZWxkQ29weSkuZmlsdGVyKGYgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb25WYWx1ZXNbaV0uZXZlcnkodiA9PiBmaWVsZENvcHlbZl0uc29tZShhID0+IGFbMF0gPD0gdiAmJiBhWzFdID49IHYpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gTm93LCBmb3IgZWFjaCBtYXRjaGluZyBmaWVsZFxuICAgICAgICBtYXRjaGluZ0ZpZWxkcy5mb3JFYWNoKGYgPT4ge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIG1hdGNoLCB0aGVyZSdzIGEgdW5pcXVlIG1hcHBpbmdcbiAgICAgICAgICBpZiAoZi5tYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG1hcHBpbmdcbiAgICAgICAgICAgIGZpZWxkTWFwcGluZ1tmLm1hdGNoZXNbMF1dID0gZi5pbmRleFxuICAgICAgICAgICAgLy8gRGVsZXRlIHRoaXMgZmllbGQsIHNvIHdlIHdvbid0IGNvbnNpZGVyIGl0IGFnYWluXG4gICAgICAgICAgICBkZWxldGUgZmllbGRDb3B5W2YubWF0Y2hlc1swXV1cbiAgICAgICAgICAgIC8vIEFuZCBkZWxldGUgdGhlIGNvbHVtbiBpbmRleCwgYXMgd2UndmUgbWFwcGVkIGl0XG4gICAgICAgICAgICBpbmRpY2VzID0gaW5kaWNlcy5maWx0ZXIoaiA9PiBmLmluZGV4ICE9PSBqKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHNvbHV0aW9uIGlzIHVzaW5nIGFsbCBmaWVsZHMgY29udGFpbmluZyAnZGVwYXJ0dXJlJyBhbmQgbXVsdGlwbHlpbmcgdGhlaXIgdmFsdWVzIHRvZ2V0aGVyXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gT2JqZWN0LmtleXMoZmllbGRNYXBwaW5nKS5maWx0ZXIoayA9PiBrLmluY2x1ZGVzKCdkZXBhcnR1cmUnKSkubWFwKGsgPT4gdGhpcy5vdXJUaWNrZXRbZmllbGRNYXBwaW5nW2tdXSkucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cbjwvc3R5bGU+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTE2LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTE2LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9EYXkxNi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWI0MDc1YWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9EYXkxNi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRGF5MTYudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6WyJjb21wb25lbnRzIiwiRGF5IiwiZGF0YSIsInNvbHV0aW9ucyIsInBhcnRPbmUiLCJwYXJ0VHdvIiwibWV0aG9kcyIsIm9uSW5wdXRDaGFuZ2VkIiwicGFyc2VJbnB1dCIsInBhcnQiLCJpc1RpY2tldFZhbGlkIiwic29sdmVQYXJ0T25lIiwiT2JqZWN0IiwiZm91bmQiLCJzb2x2ZVBhcnRUd28iLCJ2YWxpZFRpY2tldHMiLCJpbmRleCIsIm1hdGNoZXMiLCJtYXRjaGluZ0ZpZWxkcyIsImZpZWxkTWFwcGluZyIsImluZGljZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3898\n")}}]);