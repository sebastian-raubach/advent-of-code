{"version":3,"file":"js/4149.0cac9420.js","mappings":"yKAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,iBAAiB,EACtMC,EAAkB,G,WCOtB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAN,UAAAA,CACAO,QAAAA,KACAC,QAAAA,MAEAC,eAAAA,CACA,uFACA,sEACA,+EAEAC,cAAAA,CACA,kHACA,yGACA,yGACA,yGACA,sFACA,gGACA,yGACA,gGACA,iGAGA,EACAC,QAAAA,CACAT,eAAAA,SAAAA,GACA,qDACA,oBACA,mBACA,EACAU,QAAAA,SAAAA,EAAAA,GACA,mBA8BA,OA3BAC,EAAAA,SAAAA,CAAAA,EAAAA,KACA,QACAC,EAAAA,SAAAA,IAEA,2CAEA,cAGA,YACA,MAEAC,SACA,OAEAC,EAAAA,IAAAA,GAAAA,EACA,IAIA,EACAA,EAAAA,IAAAA,EAAAA,IAAAA,GAAAA,IAAAA,GAEAA,EAAAA,IAAAA,EAAAA,IAAAA,EACA,IAGA,CACA,EACAC,OAAAA,SAAAA,EAAAA,GACA,mBAkBA,OAfAJ,EAAAA,SAAAA,CAAAA,EAAAA,KAEAC,EAAAA,SAAAA,IAEA,2CAEA,cAGA,UACAE,EAAAA,IAAAA,GAAAA,EACA,GACA,IAGA,CACA,EACAE,IAAAA,SAAAA,EAAAA,GACA,cAEA,4BACAC,EAAAA,SAAAA,CAAAA,EAAAA,KAEA,eACAN,EAAAA,IAAAA,EAAAA,EAAAA,GACA,IAIAA,EAAAA,KAAAA,OAAAA,EAAAA,GAGA,oBACAA,EAAAA,KAAAA,QAAAA,EAAAA,GAIA,QAMA,OALAA,EAAAA,SAAAA,IACA,GACAO,GACA,IAEA,CACA,EACAC,aAAAA,WACA,2EACA,EACAC,aAAAA,WACA,4EACA,ICjI6P,I,UCOzPC,GAAY,OACd,EACA/B,EACAW,GACA,EACA,KACA,KACA,MAIF,EAAeoB,EAAiB,O","sources":["webpack://advent-of-code/./src/components/2020/Day17.vue?9618","webpack://advent-of-code/src/components/2020/Day17.vue","webpack://advent-of-code/./src/components/2020/Day17.vue?fc6e","webpack://advent-of-code/./src/components/2020/Day17.vue"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":17,\"year\":2020,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"17\" :year=\"2020\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      neighborsThree: [\n        [-1, -1, -1], [-1, -1, 0], [-1, -1, 1], [-1, 0, -1], [-1, 0, 0], [-1, 0, 1], [-1, 1, -1], [-1, 1, 0], [-1, 1, 1],\n        [0, -1, -1], [0, -1, 0], [0, -1, 1], [0, 0, -1], [0, 0, 1], [0, 1, -1], [0, 1, 0], [0, 1, 1],\n        [1, -1, -1], [1, -1, 0], [1, -1, 1], [1, 0, -1], [1, 0, 0], [1, 0, 1], [1, 1, -1], [1, 1, 0], [1, 1, 1]\n      ],\n      neighborsFour: [\n        [-1, -1, -1, -1], [-1, -1, -1, 0], [-1, -1, -1, 1], [-1, -1, 0, -1], [-1, -1, 0, 0], [-1, -1, 0, 1], [-1, -1, 1, -1], [-1, -1, 1, 0], [-1, -1, 1, 1],\n        [-1, 0, -1, -1], [-1, 0, -1, 0], [-1, 0, -1, 1], [-1, 0, 0, -1], [-1, 0, 0, 0], [-1, 0, 0, 1], [-1, 0, 1, -1], [-1, 0, 1, 0], [-1, 0, 1, 1],\n        [-1, 1, -1, -1], [-1, 1, -1, 0], [-1, 1, -1, 1], [-1, 1, 0, -1], [-1, 1, 0, 0], [-1, 1, 0, 1], [-1, 1, 1, -1], [-1, 1, 1, 0], [-1, 1, 1, 1],\n        [0, -1, -1, -1], [0, -1, -1, 0], [0, -1, -1, 1], [0, -1, 0, -1], [0, -1, 0, 0], [0, -1, 0, 1], [0, -1, 1, -1], [0, -1, 1, 0], [0, -1, 1, 1],\n        [0, 0, -1, -1], [0, 0, -1, 0], [0, 0, -1, 1], [0, 0, 0, -1], [0, 0, 0, 1], [0, 0, 1, -1], [0, 0, 1, 0], [0, 0, 1, 1],\n        [0, 1, -1, -1], [0, 1, -1, 0], [0, 1, -1, 1], [0, 1, 0, -1], [0, 1, 0, 0], [0, 1, 0, 1], [0, 1, 1, -1], [0, 1, 1, 0], [0, 1, 1, 1],\n        [1, -1, -1, -1], [1, -1, -1, 0], [1, -1, -1, 1], [1, -1, 0, -1], [1, -1, 0, 0], [1, -1, 0, 1], [1, -1, 1, -1], [1, -1, 1, 0], [1, -1, 1, 1],\n        [1, 0, -1, -1], [1, 0, -1, 0], [1, 0, -1, 1], [1, 0, 0, -1], [1, 0, 0, 0], [1, 0, 0, 1], [1, 0, 1, -1], [1, 0, 1, 0], [1, 0, 1, 1],\n        [1, 1, -1, -1], [1, 1, -1, 0], [1, 1, -1, 1], [1, 1, 0, -1], [1, 1, 0, 0], [1, 1, 0, 1], [1, 1, 1, -1], [1, 1, 1, 0], [1, 1, 1, 1]\n      ]\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.input = input.map(i => i.split('').map(c => c === '#'))\n      this.solvePartOne()\n      this.solvePartTwo()\n    },\n    iterate: function (map, neighbors) {\n      const tempMap = new Map(map)\n\n      // Iterate over all currently observed cells\n      map.forEach((alive, position) => {\n        let activeNeighbors = 0\n        neighbors.forEach(n => {\n          // Get the neighbors actual position within the 'grid'\n          const np = position.split(',').map((v, i) => +v + n[i])\n          // Construct its new key\n          const nk = np.join(',')\n\n          // Check if the neighbor is alive\n          const neighborAlive = map.get(nk)\n          if (neighborAlive === true) {\n            // If so, increase the counter\n            activeNeighbors++\n          } else if (neighborAlive === undefined) {\n            // Add all neighbors that don't exist to the map\n            tempMap.set(nk, false)\n          }\n        })\n\n        // Apply the life-or-death rules\n        if (alive) {\n          tempMap.set(position, activeNeighbors === 2 || activeNeighbors === 3)\n        } else {\n          tempMap.set(position, activeNeighbors === 3)\n        }\n      })\n\n      return tempMap\n    },\n    expand: function (map, neighbors) {\n      const tempMap = new Map(map)\n\n      // Iterate over all currently observed cells\n      map.forEach((alive, position) => {\n        // Consider all neighboring positions\n        neighbors.forEach(n => {\n          // Get the neighbors actual position within the 'grid'\n          const np = position.split(',').map((v, i) => +v + n[i])\n          // Construct its new key\n          const nk = np.join(',')\n\n          // If it doesn't exist yet, add it as dead\n          if (!tempMap.has(nk)) {\n            tempMap.set(nk, false)\n          }\n        })\n      })\n\n      return tempMap\n    },\n    run: function (neighbors, mapper) {\n      let map = new Map()\n      // Convert the input to a map between position and alive status\n      this.input.forEach((row, y) => {\n        row.forEach((cell, x) => {\n          // Map to the given mapping (pads dimensions)\n          const mapKey = mapper(x, y)\n          map.set(mapKey, cell)\n        })\n      })\n\n      // Initially expand the 'grid' to include the immediate dead neighbors\n      map = this.expand(map, neighbors)\n\n      // Do 6 rounds\n      for (let round = 0; round < 6; round++) {\n        map = this.iterate(map, neighbors)\n      }\n\n      // Count the ones that are alive\n      let counter = 0\n      map.forEach(value => {\n        if (value) {\n          counter++\n        }\n      })\n      return counter\n    },\n    solvePartOne: function () {\n      this.solutions.partOne = this.run(this.neighborsThree, (x, y) => `0,${y},${x}`)\n    },\n    solvePartTwo: function () {\n      this.solutions.partTwo = this.run(this.neighborsFour, (x, y) => `0,0,${y},${x}`)\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day17.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day17.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day17.vue?vue&type=template&id=0aa112c2\"\nimport script from \"./Day17.vue?vue&type=script&lang=js\"\nexport * from \"./Day17.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","staticRenderFns","components","Day","data","partOne","partTwo","neighborsThree","neighborsFour","methods","iterate","map","neighbors","activeNeighbors","tempMap","expand","run","row","counter","solvePartOne","solvePartTwo","component"],"sourceRoot":""}