"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[4736],{53164:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ Day18)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day18.vue?vue&type=template&id=7b638548\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":18,\"year\":2018,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('pre',{staticClass:\"day-18-code border\"},[_c('code',{domProps:{\"innerHTML\":_vm._s(_vm.gridOne)}}),_vm._v(\"\\n      \")])]},proxy:true},{key:\"partTwo\",fn:function(){return [_c('pre',{staticClass:\"day-18-code border\"},[_c('code',{domProps:{\"innerHTML\":_vm._s(_vm.gridTwo)}}),_vm._v(\"\\n      \")])]},proxy:true}])})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(86889);\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day18.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\nconst GROUND = '.';\nconst TREE = '|';\nconst LUMBER = '#';\n/* harmony default export */ const Day18vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      neighbors: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]],\n      map: {\n        '.': 'ground',\n        '|': 'tree',\n        '#': 'lumber'\n      },\n      gridOne: null,\n      gridTwo: null\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      this.gridOne = null;\n      this.grid = input.map(i => i.split(''));\n      this.solvePartOne();\n      this.solvePartTwo();\n    },\n    run: function (grid) {\n      // Take a copy of the grid\n      const temp = JSON.parse(JSON.stringify(grid));\n\n      // Iteratr through it\n      for (let y = 0; y < temp.length; y++) {\n        for (let x = 0; x < temp[y].length; x++) {\n          // Keep track of neighbor counts per type\n          const neighbors = {\n            tree: 0,\n            lumber: 0,\n            ground: 0\n          };\n\n          // Count them\n          this.neighbors.forEach(n => {\n            if (grid[y + n[1]]) {\n              neighbors[this.map[grid[y + n[1]][x + n[0]]]]++;\n            }\n          });\n\n          // Adjust based on current value and neighbors\n          switch (grid[y][x]) {\n            case GROUND:\n              if (neighbors.tree >= 3) {\n                temp[y][x] = TREE;\n              }\n              break;\n            case TREE:\n              if (neighbors.lumber >= 3) {\n                temp[y][x] = LUMBER;\n              }\n              break;\n            case LUMBER:\n              if (neighbors.lumber < 1 || neighbors.tree < 1) {\n                temp[y][x] = GROUND;\n              }\n              break;\n          }\n        }\n      }\n      return temp;\n    },\n    solvePartOne: function () {\n      // Take a copy of the grid\n      let prev = JSON.parse(JSON.stringify(this.grid));\n      // Run 10 time steps\n      for (let i = 0; i < 10; i++) {\n        const temp = this.run(prev);\n        prev = temp;\n      }\n\n      // Count types\n      const counts = {\n        tree: 0,\n        lumber: 0,\n        ground: 0\n      };\n      for (let y = 0; y < prev.length; y++) {\n        for (let x = 0; x < prev[y].length; x++) {\n          counts[this.map[prev[y][x]]]++;\n        }\n      }\n\n      // Set solution\n      this.solutions.partOne = counts.tree * counts.lumber;\n      this.gridOne = this.print(prev);\n    },\n    solvePartTwo: function () {\n      // Initial setip\n      const LIMIT = 1000000000;\n      let round = 0;\n      // Keep track of seen configurations\n      const memory = new Map();\n      let prev = JSON.parse(JSON.stringify(this.grid));\n      // While we haven't finished yet\n      while (round < LIMIT) {\n        // Do a step\n        let temp = this.run(prev);\n        round++;\n\n        // Get configuration\n        const string = JSON.stringify(temp);\n        if (memory.has(string)) {\n          // Configuration exists? Get it and calculate the loop length\n          const match = memory.get(string);\n          const loopLength = round - match;\n\n          // Then jump using the loop length\n          while (round < LIMIT) {\n            round += loopLength;\n          }\n          // Adjust for offset\n          round -= loopLength;\n\n          // Then run the remaining iterations manually again\n          for (let t = 0; t < LIMIT - round; t++) {\n            temp = this.run(temp);\n            prev = temp;\n          }\n\n          // Calculate counts\n          const counts = {\n            tree: 0,\n            lumber: 0,\n            ground: 0\n          };\n          for (let y = 0; y < prev.length; y++) {\n            for (let x = 0; x < prev[y].length; x++) {\n              counts[this.map[prev[y][x]]]++;\n            }\n          }\n\n          // Set result\n          this.solutions.partTwo = counts.tree * counts.lumber;\n          this.gridTwo = this.print(prev);\n          return;\n        } else {\n          // If we haven't seen this configuration yet, remember and continue\n          memory.set(string, round);\n        }\n        prev = temp;\n      }\n    },\n    print: function (grid) {\n      let result = '';\n      for (let y = 0; y < grid.length; y++) {\n        for (let x = 0; x < grid[y].length; x++) {\n          if (grid[y][x] === TREE) {\n            result += '<span class=\"day-18-tree\">|</span>';\n          } else if (grid[y][x] === LUMBER) {\n            result += '<span class=\"day-18-lumber\">#</span>';\n          } else {\n            result += grid[y][x];\n          }\n        }\n        result += '<br/>';\n      }\n      return result;\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2018/Day18.vue?vue&type=script&lang=js\n /* harmony default export */ const _2018_Day18vue_type_script_lang_js = (Day18vue_type_script_lang_js); \n;// CONCATENATED MODULE: ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-12.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2018/Day18.vue?vue&type=style&index=0&id=7b638548&prod&lang=css\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./src/components/2018/Day18.vue?vue&type=style&index=0&id=7b638548&prod&lang=css\n\n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2018/Day18.vue\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2018_Day18vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day18 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMxNjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsT0FBTywrQ0FBK0MsS0FBSyxtQ0FBbUMsc0JBQXNCLDRCQUE0QixrQkFBa0IsaUNBQWlDLGFBQWEsVUFBVSxpQ0FBaUMsd0JBQXdCLFlBQVksRUFBRSw0QkFBNEIsa0JBQWtCLGlDQUFpQyxhQUFhLFVBQVUsaUNBQWlDLHdCQUF3QixZQUFZLEdBQUc7QUFDempCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZUE7QUFFQTtBQUNBO0FBQ0E7QUFFQSxtRUFBZTtFQUNmQTtJQUNBQyxHQUFBQSxFQUFBQSxrQkFBQUE7RUFDQTtFQUNBQztJQUNBO01BQ0FDO1FBQ0FDO1FBQ0FDO01BQ0E7TUFDQUM7TUFDQUM7UUFDQTtRQUNBO1FBQ0E7TUFDQTtNQUNBQztNQUNBQztJQUNBO0VBQ0E7RUFDQUM7SUFDQUM7TUFDQTtNQUNBO01BQ0E7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTs7TUFFQTtNQUNBO1FBQ0E7VUFDQTtVQUNBO1lBQ0FDO1lBQ0FDO1lBQ0FDO1VBQ0E7O1VBRUE7VUFDQTtZQUNBO2NBQ0FUO1lBQ0E7VUFDQTs7VUFFQTtVQUNBO1lBQ0E7Y0FDQTtnQkFDQVU7Y0FDQTtjQUNBO1lBQ0E7Y0FDQTtnQkFDQUE7Y0FDQTtjQUNBO1lBQ0E7Y0FDQTtnQkFDQUE7Y0FDQTtjQUNBO1VBQ0E7UUFDQTtNQUNBO01BRUE7SUFDQTtJQUNBQztNQUNBO01BQ0E7TUFDQTtNQUNBO1FBQ0E7UUFFQUM7TUFDQTs7TUFFQTtNQUNBO1FBQ0FMO1FBQ0FDO1FBQ0FDO01BQ0E7TUFDQTtRQUNBO1VBQ0FJO1FBQ0E7TUFDQTs7TUFFQTtNQUNBO01BQ0E7SUFDQTtJQUNBQztNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFFQTtNQUNBO01BQ0E7UUFDQTtRQUNBO1FBQ0FDOztRQUVBO1FBQ0E7UUFFQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBO1lBQ0FBO1VBQ0E7VUFDQTtVQUNBQTs7VUFFQTtVQUNBO1lBQ0FMO1lBRUFFO1VBQ0E7O1VBRUE7VUFDQTtZQUNBTDtZQUNBQztZQUNBQztVQUNBO1VBRUE7WUFDQTtjQUNBSTtZQUNBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBRUE7UUFDQTtVQUNBO1VBQ0FHO1FBQ0E7UUFFQUo7TUFDQTtJQUNBO0lBQ0FLO01BQ0E7TUFDQTtRQUNBO1VBQ0E7WUFDQUM7VUFDQTtZQUNBQTtVQUNBO1lBQ0FBO1VBQ0E7UUFDQTtRQUNBQTtNQUNBO01BQ0E7SUFDQTtFQUNBO0FBQ0EsQ0FBQyxFOztBQ3RNMlAsQ0FBQyx5RUFBZSw0QkFBRyxFQUFDLEM7O0FDQWhSOzs7Ozs7O0FFQW1GO0FBQzNCO0FBQ0w7QUFDbkQsQ0FBaUY7OztBQUdqRjtBQUNzRztBQUN0RyxnQkFBZ0Isc0NBQVU7QUFDMUIsRUFBRSxrQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTgvRGF5MTgudnVlPzc4NTMiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkxOC52dWU/ZGJiNyIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTgvRGF5MTgudnVlP2UwMmQiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDE4L0RheTE4LnZ1ZT85NTY2Iiwid2VicGFjazovL2FkdmVudC1vZi1jb2RlLy4vc3JjL2NvbXBvbmVudHMvMjAxOC9EYXkxOC52dWU/ZDUzZCIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMTgvRGF5MTgudnVlP2MzNmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ0RheScse2F0dHJzOntcImRheVwiOjE4LFwieWVhclwiOjIwMTgsXCJzb2x1dGlvbnNcIjpfdm0uc29sdXRpb25zfSxvbjp7XCJpbnB1dC1jaGFuZ2VkXCI6X3ZtLm9uSW5wdXRDaGFuZ2VkfSxzY29wZWRTbG90czpfdm0uX3UoW3trZXk6XCJwYXJ0T25lXCIsZm46ZnVuY3Rpb24oKXtyZXR1cm4gW19jKCdwcmUnLHtzdGF0aWNDbGFzczpcImRheS0xOC1jb2RlIGJvcmRlclwifSxbX2MoJ2NvZGUnLHtkb21Qcm9wczp7XCJpbm5lckhUTUxcIjpfdm0uX3MoX3ZtLmdyaWRPbmUpfX0pLF92bS5fdihcIlxcbiAgICAgIFwiKV0pXX0scHJveHk6dHJ1ZX0se2tleTpcInBhcnRUd29cIixmbjpmdW5jdGlvbigpe3JldHVybiBbX2MoJ3ByZScse3N0YXRpY0NsYXNzOlwiZGF5LTE4LWNvZGUgYm9yZGVyXCJ9LFtfYygnY29kZScse2RvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhfdm0uZ3JpZFR3byl9fSksX3ZtLl92KFwiXFxuICAgICAgXCIpXSldfSxwcm94eTp0cnVlfV0pfSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPERheSA6ZGF5PVwiMThcIiA6eWVhcj1cIjIwMThcIiA6c29sdXRpb25zPVwic29sdXRpb25zXCIgQGlucHV0LWNoYW5nZWQ9XCJvbklucHV0Q2hhbmdlZFwiPlxuICAgIDx0ZW1wbGF0ZSB2LXNsb3Q6cGFydE9uZT5cbiAgICAgIDxwcmUgY2xhc3M9XCJkYXktMTgtY29kZSBib3JkZXJcIj5cbjxjb2RlIHYtaHRtbD1cImdyaWRPbmVcIiAvPlxuICAgICAgPC9wcmU+XG4gICAgPC90ZW1wbGF0ZT5cbiAgICA8dGVtcGxhdGUgdi1zbG90OnBhcnRUd28+XG4gICAgICA8cHJlIGNsYXNzPVwiZGF5LTE4LWNvZGUgYm9yZGVyXCI+XG48Y29kZSB2LWh0bWw9XCJncmlkVHdvXCIgLz5cbiAgICAgIDwvcHJlPlxuICAgIDwvdGVtcGxhdGU+XG4gIDwvRGF5PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBEYXkgZnJvbSAnQC9jb21wb25lbnRzL0RheSdcblxuY29uc3QgR1JPVU5EID0gJy4nXG5jb25zdCBUUkVFID0gJ3wnXG5jb25zdCBMVU1CRVIgPSAnIydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sdXRpb25zOiB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH0sXG4gICAgICBuZWlnaGJvcnM6IFtbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXSwgWzAsIC0xXSwgWzAsIDFdLCBbMSwgLTFdLCBbMSwgMF0sIFsxLCAxXV0sXG4gICAgICBtYXA6IHtcbiAgICAgICAgJy4nOiAnZ3JvdW5kJyxcbiAgICAgICAgJ3wnOiAndHJlZScsXG4gICAgICAgICcjJzogJ2x1bWJlcidcbiAgICAgIH0sXG4gICAgICBncmlkT25lOiBudWxsLFxuICAgICAgZ3JpZFR3bzogbnVsbFxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uSW5wdXRDaGFuZ2VkOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHRoaXMuZ3JpZE9uZSA9IG51bGxcbiAgICAgIHRoaXMuZ3JpZCA9IGlucHV0Lm1hcChpID0+IGkuc3BsaXQoJycpKVxuICAgICAgdGhpcy5zb2x2ZVBhcnRPbmUoKVxuICAgICAgdGhpcy5zb2x2ZVBhcnRUd28oKVxuICAgIH0sXG4gICAgcnVuOiBmdW5jdGlvbiAoZ3JpZCkge1xuICAgICAgLy8gVGFrZSBhIGNvcHkgb2YgdGhlIGdyaWRcbiAgICAgIGNvbnN0IHRlbXAgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdyaWQpKVxuXG4gICAgICAvLyBJdGVyYXRyIHRocm91Z2ggaXRcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGVtcC5sZW5ndGg7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRlbXBbeV0ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIG5laWdoYm9yIGNvdW50cyBwZXIgdHlwZVxuICAgICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IHtcbiAgICAgICAgICAgIHRyZWU6IDAsXG4gICAgICAgICAgICBsdW1iZXI6IDAsXG4gICAgICAgICAgICBncm91bmQ6IDBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb3VudCB0aGVtXG4gICAgICAgICAgdGhpcy5uZWlnaGJvcnMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGlmIChncmlkW3kgKyBuWzFdXSkge1xuICAgICAgICAgICAgICBuZWlnaGJvcnNbdGhpcy5tYXBbZ3JpZFt5ICsgblsxXV1beCArIG5bMF1dXV0rK1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICAvLyBBZGp1c3QgYmFzZWQgb24gY3VycmVudCB2YWx1ZSBhbmQgbmVpZ2hib3JzXG4gICAgICAgICAgc3dpdGNoIChncmlkW3ldW3hdKSB7XG4gICAgICAgICAgICBjYXNlIEdST1VORDpcbiAgICAgICAgICAgICAgaWYgKG5laWdoYm9ycy50cmVlID49IDMpIHtcbiAgICAgICAgICAgICAgICB0ZW1wW3ldW3hdID0gVFJFRVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFRSRUU6XG4gICAgICAgICAgICAgIGlmIChuZWlnaGJvcnMubHVtYmVyID49IDMpIHtcbiAgICAgICAgICAgICAgICB0ZW1wW3ldW3hdID0gTFVNQkVSXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgTFVNQkVSOlxuICAgICAgICAgICAgICBpZiAobmVpZ2hib3JzLmx1bWJlciA8IDEgfHwgbmVpZ2hib3JzLnRyZWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGVtcFt5XVt4XSA9IEdST1VORFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZW1wXG4gICAgfSxcbiAgICBzb2x2ZVBhcnRPbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRha2UgYSBjb3B5IG9mIHRoZSBncmlkXG4gICAgICBsZXQgcHJldiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5ncmlkKSlcbiAgICAgIC8vIFJ1biAxMCB0aW1lIHN0ZXBzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGVtcCA9IHRoaXMucnVuKHByZXYpXG5cbiAgICAgICAgcHJldiA9IHRlbXBcbiAgICAgIH1cblxuICAgICAgLy8gQ291bnQgdHlwZXNcbiAgICAgIGNvbnN0IGNvdW50cyA9IHtcbiAgICAgICAgdHJlZTogMCxcbiAgICAgICAgbHVtYmVyOiAwLFxuICAgICAgICBncm91bmQ6IDBcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcHJldi5sZW5ndGg7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHByZXZbeV0ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICBjb3VudHNbdGhpcy5tYXBbcHJldlt5XVt4XV1dKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc29sdXRpb25cbiAgICAgIHRoaXMuc29sdXRpb25zLnBhcnRPbmUgPSBjb3VudHMudHJlZSAqIGNvdW50cy5sdW1iZXJcbiAgICAgIHRoaXMuZ3JpZE9uZSA9IHRoaXMucHJpbnQocHJldilcbiAgICB9LFxuICAgIHNvbHZlUGFydFR3bzogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSW5pdGlhbCBzZXRpcFxuICAgICAgY29uc3QgTElNSVQgPSAxMDAwMDAwMDAwXG4gICAgICBsZXQgcm91bmQgPSAwXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHNlZW4gY29uZmlndXJhdGlvbnNcbiAgICAgIGNvbnN0IG1lbW9yeSA9IG5ldyBNYXAoKVxuXG4gICAgICBsZXQgcHJldiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5ncmlkKSlcbiAgICAgIC8vIFdoaWxlIHdlIGhhdmVuJ3QgZmluaXNoZWQgeWV0XG4gICAgICB3aGlsZSAocm91bmQgPCBMSU1JVCkge1xuICAgICAgICAvLyBEbyBhIHN0ZXBcbiAgICAgICAgbGV0IHRlbXAgPSB0aGlzLnJ1bihwcmV2KVxuICAgICAgICByb3VuZCsrXG5cbiAgICAgICAgLy8gR2V0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgY29uc3Qgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodGVtcClcblxuICAgICAgICBpZiAobWVtb3J5LmhhcyhzdHJpbmcpKSB7XG4gICAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBleGlzdHM/IEdldCBpdCBhbmQgY2FsY3VsYXRlIHRoZSBsb29wIGxlbmd0aFxuICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWVtb3J5LmdldChzdHJpbmcpXG4gICAgICAgICAgY29uc3QgbG9vcExlbmd0aCA9IHJvdW5kIC0gbWF0Y2hcblxuICAgICAgICAgIC8vIFRoZW4ganVtcCB1c2luZyB0aGUgbG9vcCBsZW5ndGhcbiAgICAgICAgICB3aGlsZSAocm91bmQgPCBMSU1JVCkge1xuICAgICAgICAgICAgcm91bmQgKz0gbG9vcExlbmd0aFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBZGp1c3QgZm9yIG9mZnNldFxuICAgICAgICAgIHJvdW5kIC09IGxvb3BMZW5ndGhcblxuICAgICAgICAgIC8vIFRoZW4gcnVuIHRoZSByZW1haW5pbmcgaXRlcmF0aW9ucyBtYW51YWxseSBhZ2FpblxuICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgTElNSVQgLSByb3VuZDsgdCsrKSB7XG4gICAgICAgICAgICB0ZW1wID0gdGhpcy5ydW4odGVtcClcblxuICAgICAgICAgICAgcHJldiA9IHRlbXBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgY291bnRzXG4gICAgICAgICAgY29uc3QgY291bnRzID0ge1xuICAgICAgICAgICAgdHJlZTogMCxcbiAgICAgICAgICAgIGx1bWJlcjogMCxcbiAgICAgICAgICAgIGdyb3VuZDogMFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcHJldi5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBwcmV2W3ldLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgIGNvdW50c1t0aGlzLm1hcFtwcmV2W3ldW3hdXV0rK1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCByZXN1bHRcbiAgICAgICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gY291bnRzLnRyZWUgKiBjb3VudHMubHVtYmVyXG4gICAgICAgICAgdGhpcy5ncmlkVHdvID0gdGhpcy5wcmludChwcmV2KVxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgY29uZmlndXJhdGlvbiB5ZXQsIHJlbWVtYmVyIGFuZCBjb250aW51ZVxuICAgICAgICAgIG1lbW9yeS5zZXQoc3RyaW5nLCByb3VuZClcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXYgPSB0ZW1wXG4gICAgICB9XG4gICAgfSxcbiAgICBwcmludDogZnVuY3Rpb24gKGdyaWQpIHtcbiAgICAgIGxldCByZXN1bHQgPSAnJ1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBncmlkLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgZ3JpZFt5XS5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIGlmIChncmlkW3ldW3hdID09PSBUUkVFKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJzxzcGFuIGNsYXNzPVwiZGF5LTE4LXRyZWVcIj58PC9zcGFuPidcbiAgICAgICAgICB9IGVsc2UgaWYgKGdyaWRbeV1beF0gPT09IExVTUJFUikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc8c3BhbiBjbGFzcz1cImRheS0xOC1sdW1iZXJcIj4jPC9zcGFuPidcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGdyaWRbeV1beF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICc8YnIvPidcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4uZGF5LTE4LWNvZGUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMmMzZTUwO1xuICBjb2xvcjogIzdmOGM4ZDtcbiAgbWF4LWhlaWdodDogNTB2aDtcbn1cbi5kYXktMTgtdHJlZSB7XG4gIGJhY2tncm91bmQtY29sb3I6IzI3YWU2MDtcbiAgY29sb3I6ICMyYzNlNTA7XG59XG4uZGF5LTE4LWx1bWJlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICMyOTgwYjk7XG4gIGNvbG9yOiAjMmMzZTUwO1xufVxuPC9zdHlsZT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNDAudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MTgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNDAudXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRGF5MTgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTEyLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTEyLnVzZVsyXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTE4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTdiNjM4NTQ4JnByb2QmbGFuZz1jc3NcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vRGF5MTgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTdiNjM4NTQ4XCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRGF5MTgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0RheTE4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0RheTE4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTdiNjM4NTQ4JnByb2QmbGFuZz1jc3NcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm5hbWVzIjpbImNvbXBvbmVudHMiLCJEYXkiLCJkYXRhIiwic29sdXRpb25zIiwicGFydE9uZSIsInBhcnRUd28iLCJuZWlnaGJvcnMiLCJtYXAiLCJncmlkT25lIiwiZ3JpZFR3byIsIm1ldGhvZHMiLCJvbklucHV0Q2hhbmdlZCIsInJ1biIsInRyZWUiLCJsdW1iZXIiLCJncm91bmQiLCJ0ZW1wIiwic29sdmVQYXJ0T25lIiwicHJldiIsImNvdW50cyIsInNvbHZlUGFydFR3byIsInJvdW5kIiwibWVtb3J5IiwicHJpbnQiLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53164\n")}}]);