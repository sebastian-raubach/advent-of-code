"use strict";(self["webpackChunkadvent_of_code"]=self["webpackChunkadvent_of_code"]||[]).push([[777],{32002:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ Day3)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day3.vue?vue&type=template&id=1027242d\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'Day\',{attrs:{"day":3,"year":2020,"solutions":_vm.solutions},on:{"input-changed":_vm.onInputChanged},scopedSlots:_vm._u([{key:"partOne",fn:function(){return [_c(\'pre\',{staticClass:"day-3-code border"},[_c(\'code\',{domProps:{"innerHTML":_vm._s(_vm.gridOne)}}),_vm._v("\\n      ")])]},proxy:true},{key:"partTwo",fn:function(){return [_c(\'pre\',{staticClass:"day-3-code border"},[_c(\'code\',{domProps:{"innerHTML":_vm._s(_vm.gridTwo)}}),_vm._v("\\n      ")])]},proxy:true}])})}\nvar staticRenderFns = []\n\n\n// EXTERNAL MODULE: ./src/components/Day.vue + 5 modules\nvar Day = __webpack_require__(36100);\n;// CONCATENATED MODULE: ./src/util/PathDrawer.js\nclass PathDrawer {\n  constructor(input, paths) {\n    this.$input = input;\n    this.$paths = paths;\n  }\n  getPathGrid() {\n    let result = \'\';\n    // Calculate how many times the grid repeats in x direction\n    const xRepeats = this.$paths.map(p => {\n      return Math.ceil(p[p.length - 1].x / this.$input[0].length);\n    }).reduce((a, b) => Math.max(a, b));\n\n    // Get a map of all cells on the path\n    const onPath = {};\n    this.$paths.forEach(p => {\n      p.forEach(c => {\n        onPath[`${c.x}-${c.y}`] = c.hit;\n      });\n    });\n\n    // Each row\n    for (let y = 0; y < this.$input.length; y++) {\n      // Repeat the for xRepeat times\n      for (let rep = 0; rep < xRepeats; rep++) {\n        // Then draw the row\n        for (let x = 0; x < this.$input[y].length; x++) {\n          const value = this.$input[y][x] ? \'#\' : \'.\';\n          const totalX = this.$input[y].length * rep + x;\n          const isHit = onPath[`${totalX}-${y}`];\n          if (isHit === true) {\n            result += \'<span class="day-3-path-hit">X</span>\';\n          } else if (isHit === false) {\n            result += \'<span class="day-3-path-miss">O</span>\';\n          } else {\n            result += value;\n          }\n        }\n      }\n      result += \'<br/>\';\n    }\n    return result;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day3.vue?vue&type=script&lang=js\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ const Day3vue_type_script_lang_js = ({\n  components: {\n    Day: Day/* default */.Z\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      parsedInput: [],\n      paths: {\n        1: [],\n        2: []\n      },\n      gridOne: null,\n      gridTwo: null\n    };\n  },\n  methods: {\n    onInputChanged: function (input) {\n      // Map the input into a 2d boolean array where trees are true\n      this.parsedInput = input.map(r => {\n        return r.split(\'\').map(c => c === \'#\');\n      });\n\n      // Reset some data fields\n      this.paths = {\n        1: [],\n        2: []\n      };\n      this.gridOne = null;\n      this.gridTwo = null;\n\n      // Solve both parts\n      this.solvePartOne();\n      this.solvePartTwo();\n    },\n    solvePartOne: function () {\n      // Check the slope\n      const result = this.checkSlope(3, 1);\n      // Save the path for drawing\n      this.paths[1].push(result.path);\n      // Set the result\n      this.solutions.partOne = result.trees;\n\n      // Start the drawer\n      this.gridOne = new PathDrawer(this.parsedInput, this.paths[1]).getPathGrid();\n    },\n    solvePartTwo: function () {\n      // Check the slopes\n      const slopes = [[1, 1], [3, 1], [5, 1], [7, 1], [1, 2]];\n\n      // Map each slope to its number of trees then multiply them together\n      this.solutions.partTwo = slopes.map(s => {\n        // Calculate the result\n        const result = this.checkSlope(s[0], s[1]);\n        // Save the path for drawing\n        this.paths[2].push(result.path);\n        // Return the number of trees\n        return result.trees;\n      }).reduce((a, b) => a * b, 1);\n\n      // Start the drawer\n      this.gridTwo = new PathDrawer(this.parsedInput, this.paths[2]).getPathGrid();\n    },\n    /**\n     * Checks the number of trees and grid points on the path from top left with the given delta slope\n     * @param deltaX The delta value in the x direction (>= 0)\n     * @param deltaY The delta value in the y direction (>= 0)\n     * @returns An object containing the number of trees (`trees`) and the cells on the path (`path`)\n     */\n    checkSlope: function (deltaX, deltaY) {\n      let counter = 0;\n      let x = 0;\n      // Keep track of the overall x position for repeated grids\n      let totalX = 0;\n      // Track all the cells on the path\n      const path = [];\n      // Traverse in y direction with delta y\n      for (let y = deltaY; y < this.parsedInput.length; y += deltaY) {\n        // Add to total x\n        totalX += deltaX;\n        // Calculate new x based on wrapping\n        x = (x + deltaX) % this.parsedInput[y].length;\n        // Check if it\'s a tree\n        if (this.parsedInput[y][x]) {\n          counter++;\n          path.push({\n            x: totalX,\n            y: y,\n            hit: true\n          });\n        } else {\n          path.push({\n            x: totalX,\n            y: y,\n            hit: false\n          });\n        }\n      }\n      return {\n        path: path,\n        trees: counter\n      };\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/2020/Day3.vue?vue&type=script&lang=js\n /* harmony default export */ const _2020_Day3vue_type_script_lang_js = (Day3vue_type_script_lang_js); \n;// CONCATENATED MODULE: ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-12.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/2020/Day3.vue?vue&type=style&index=0&id=1027242d&prod&lang=css\n// extracted by mini-css-extract-plugin\n\n;// CONCATENATED MODULE: ./src/components/2020/Day3.vue?vue&type=style&index=0&id=1027242d&prod&lang=css\n\n// EXTERNAL MODULE: ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1001);\n;// CONCATENATED MODULE: ./src/components/2020/Day3.vue\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,componentNormalizer/* default */.Z)(\n  _2020_Day3vue_type_script_lang_js,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ const Day3 = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUEsa0VBQWU7RUFDZnFCO0lBQ0FDLEdBQUFBLEVBQUFBLGtCQUFBQTtFQUNBO0VBQ0FDO0lBQ0E7TUFDQUM7UUFDQUM7UUFDQUM7TUFDQTtNQUNBQztNQUNBL0I7UUFDQTtRQUNBO01BQ0E7TUFDQWdDO01BQ0FDO0lBQ0E7RUFDQTtFQUNBQztJQUNBQztNQUNBO01BQ0E7UUFDQTtNQUNBOztNQUVBO01BQ0E7UUFDQTtRQUNBO01BQ0E7TUFDQTtNQUNBOztNQUVBO01BQ0E7TUFDQTtJQUNBO0lBQ0FDO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztNQUVBO01BQ0E7SUFDQTtJQUNBQztNQUNBO01BQ0EsZ0JBQ0EsUUFDQSxRQUNBLFFBQ0EsUUFDQSxPQUNBOztNQUVBO01BQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7TUFDQSxHQUNBekI7O01BRUE7TUFDQTtJQUNBO0lBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0EwQjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7UUFDQTtRQUNBZjtRQUNBO1FBQ0FaO1FBQ0E7UUFDQTtVQUNBNEI7VUFDQUM7WUFBQTdCO1lBQUFRO1lBQUFDO1VBQUE7UUFDQTtVQUNBb0I7WUFBQTdCO1lBQUFRO1lBQUFDO1VBQUE7UUFDQTtNQUNBO01BRUE7UUFDQW9CO1FBQ0FDO01BQ0E7SUFDQTtFQUNBO0FBQ0EsQ0FBQyxFOztBQy9IMFAsQ0FBQyx3RUFBZSwyQkFBRyxFQUFDLEM7O0FDQS9ROzs7Ozs7O0FFQWtGO0FBQzNCO0FBQ0w7QUFDbEQsQ0FBZ0Y7OztBQUdoRjtBQUNzRztBQUN0RyxnQkFBZ0Isc0NBQVU7QUFDMUIsRUFBRSxpQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy9jb21wb25lbnRzLzIwMjAvRGF5My52dWU/NTA2MyIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS8uL3NyYy91dGlsL1BhdGhEcmF3ZXIuanM/OTc4OCIsIndlYnBhY2s6Ly9hZHZlbnQtb2YtY29kZS9zcmMvY29tcG9uZW50cy8yMDIwL0RheTMudnVlP2YwMmQiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIwL0RheTMudnVlPzRhNjUiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIwL0RheTMudnVlP2Q3YmIiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIwL0RheTMudnVlP2IxOTkiLCJ3ZWJwYWNrOi8vYWR2ZW50LW9mLWNvZGUvLi9zcmMvY29tcG9uZW50cy8yMDIwL0RheTMudnVlP2VmM2UiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ0RheScse2F0dHJzOntcImRheVwiOjMsXCJ5ZWFyXCI6MjAyMCxcInNvbHV0aW9uc1wiOl92bS5zb2x1dGlvbnN9LG9uOntcImlucHV0LWNoYW5nZWRcIjpfdm0ub25JbnB1dENoYW5nZWR9LHNjb3BlZFNsb3RzOl92bS5fdShbe2tleTpcInBhcnRPbmVcIixmbjpmdW5jdGlvbigpe3JldHVybiBbX2MoJ3ByZScse3N0YXRpY0NsYXNzOlwiZGF5LTMtY29kZSBib3JkZXJcIn0sW19jKCdjb2RlJyx7ZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKF92bS5ncmlkT25lKX19KSxfdm0uX3YoXCJcXG4gICAgICBcIildKV19LHByb3h5OnRydWV9LHtrZXk6XCJwYXJ0VHdvXCIsZm46ZnVuY3Rpb24oKXtyZXR1cm4gW19jKCdwcmUnLHtzdGF0aWNDbGFzczpcImRheS0zLWNvZGUgYm9yZGVyXCJ9LFtfYygnY29kZScse2RvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhfdm0uZ3JpZFR3byl9fSksX3ZtLl92KFwiXFxuICAgICAgXCIpXSldfSxwcm94eTp0cnVlfV0pfSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhEcmF3ZXIge1xuICBjb25zdHJ1Y3RvciAoaW5wdXQsIHBhdGhzKSB7XG4gICAgdGhpcy4kaW5wdXQgPSBpbnB1dFxuICAgIHRoaXMuJHBhdGhzID0gcGF0aHNcbiAgfVxuXG4gIGdldFBhdGhHcmlkICgpIHtcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgdGltZXMgdGhlIGdyaWQgcmVwZWF0cyBpbiB4IGRpcmVjdGlvblxuICAgIGNvbnN0IHhSZXBlYXRzID0gdGhpcy4kcGF0aHMubWFwKHAgPT4ge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChwW3AubGVuZ3RoIC0gMV0ueCAvIHRoaXMuJGlucHV0WzBdLmxlbmd0aClcbiAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKVxuXG4gICAgLy8gR2V0IGEgbWFwIG9mIGFsbCBjZWxscyBvbiB0aGUgcGF0aFxuICAgIGNvbnN0IG9uUGF0aCA9IHt9XG4gICAgdGhpcy4kcGF0aHMuZm9yRWFjaChwID0+IHtcbiAgICAgIHAuZm9yRWFjaChjID0+IHtcbiAgICAgICAgb25QYXRoW2Ake2MueH0tJHtjLnl9YF0gPSBjLmhpdFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy8gRWFjaCByb3dcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuJGlucHV0Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAvLyBSZXBlYXQgdGhlIGZvciB4UmVwZWF0IHRpbWVzXG4gICAgICBmb3IgKGxldCByZXAgPSAwOyByZXAgPCB4UmVwZWF0czsgcmVwKyspIHtcbiAgICAgICAgLy8gVGhlbiBkcmF3IHRoZSByb3dcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLiRpbnB1dFt5XS5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4kaW5wdXRbeV1beF0gPyAnIycgOiAnLidcbiAgICAgICAgICBjb25zdCB0b3RhbFggPSB0aGlzLiRpbnB1dFt5XS5sZW5ndGggKiByZXAgKyB4XG4gICAgICAgICAgY29uc3QgaXNIaXQgPSBvblBhdGhbYCR7dG90YWxYfS0ke3l9YF1cblxuICAgICAgICAgIGlmIChpc0hpdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc8c3BhbiBjbGFzcz1cImRheS0zLXBhdGgtaGl0XCI+WDwvc3Bhbj4nXG4gICAgICAgICAgfSBlbHNlIGlmIChpc0hpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnPHNwYW4gY2xhc3M9XCJkYXktMy1wYXRoLW1pc3NcIj5PPC9zcGFuPidcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJzxici8+J1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxuICA8RGF5IDpkYXk9XCIzXCIgOnllYXI9XCIyMDIwXCIgOnNvbHV0aW9ucz1cInNvbHV0aW9uc1wiIEBpbnB1dC1jaGFuZ2VkPVwib25JbnB1dENoYW5nZWRcIj5cbiAgICA8dGVtcGxhdGUgdi1zbG90OnBhcnRPbmU+XG4gICAgICA8cHJlIGNsYXNzPVwiZGF5LTMtY29kZSBib3JkZXJcIj5cbjxjb2RlIHYtaHRtbD1cImdyaWRPbmVcIiAvPlxuICAgICAgPC9wcmU+XG4gICAgPC90ZW1wbGF0ZT5cbiAgICA8dGVtcGxhdGUgdi1zbG90OnBhcnRUd28+XG4gICAgICA8cHJlIGNsYXNzPVwiZGF5LTMtY29kZSBib3JkZXJcIj5cbjxjb2RlIHYtaHRtbD1cImdyaWRUd29cIiAvPlxuICAgICAgPC9wcmU+XG4gICAgPC90ZW1wbGF0ZT5cbiAgPC9EYXk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IERheSBmcm9tICdAL2NvbXBvbmVudHMvRGF5J1xuXG5pbXBvcnQgUGF0aERyYXdlciBmcm9tICdAL3V0aWwvUGF0aERyYXdlci5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgRGF5XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sdXRpb25zOiB7XG4gICAgICAgIHBhcnRPbmU6IG51bGwsXG4gICAgICAgIHBhcnRUd286IG51bGxcbiAgICAgIH0sXG4gICAgICBwYXJzZWRJbnB1dDogW10sXG4gICAgICBwYXRoczoge1xuICAgICAgICAxOiBbXSxcbiAgICAgICAgMjogW11cbiAgICAgIH0sXG4gICAgICBncmlkT25lOiBudWxsLFxuICAgICAgZ3JpZFR3bzogbnVsbFxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uSW5wdXRDaGFuZ2VkOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIC8vIE1hcCB0aGUgaW5wdXQgaW50byBhIDJkIGJvb2xlYW4gYXJyYXkgd2hlcmUgdHJlZXMgYXJlIHRydWVcbiAgICAgIHRoaXMucGFyc2VkSW5wdXQgPSBpbnB1dC5tYXAociA9PiB7XG4gICAgICAgIHJldHVybiByLnNwbGl0KCcnKS5tYXAoYyA9PiBjID09PSAnIycpXG4gICAgICB9KVxuXG4gICAgICAvLyBSZXNldCBzb21lIGRhdGEgZmllbGRzXG4gICAgICB0aGlzLnBhdGhzID0ge1xuICAgICAgICAxOiBbXSxcbiAgICAgICAgMjogW11cbiAgICAgIH1cbiAgICAgIHRoaXMuZ3JpZE9uZSA9IG51bGxcbiAgICAgIHRoaXMuZ3JpZFR3byA9IG51bGxcblxuICAgICAgLy8gU29sdmUgYm90aCBwYXJ0c1xuICAgICAgdGhpcy5zb2x2ZVBhcnRPbmUoKVxuICAgICAgdGhpcy5zb2x2ZVBhcnRUd28oKVxuICAgIH0sXG4gICAgc29sdmVQYXJ0T25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDaGVjayB0aGUgc2xvcGVcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2hlY2tTbG9wZSgzLCAxKVxuICAgICAgLy8gU2F2ZSB0aGUgcGF0aCBmb3IgZHJhd2luZ1xuICAgICAgdGhpcy5wYXRoc1sxXS5wdXNoKHJlc3VsdC5wYXRoKVxuICAgICAgLy8gU2V0IHRoZSByZXN1bHRcbiAgICAgIHRoaXMuc29sdXRpb25zLnBhcnRPbmUgPSByZXN1bHQudHJlZXNcblxuICAgICAgLy8gU3RhcnQgdGhlIGRyYXdlclxuICAgICAgdGhpcy5ncmlkT25lID0gbmV3IFBhdGhEcmF3ZXIodGhpcy5wYXJzZWRJbnB1dCwgdGhpcy5wYXRoc1sxXSkuZ2V0UGF0aEdyaWQoKVxuICAgIH0sXG4gICAgc29sdmVQYXJ0VHdvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDaGVjayB0aGUgc2xvcGVzXG4gICAgICBjb25zdCBzbG9wZXMgPSBbXG4gICAgICAgIFsxLCAxXSxcbiAgICAgICAgWzMsIDFdLFxuICAgICAgICBbNSwgMV0sXG4gICAgICAgIFs3LCAxXSxcbiAgICAgICAgWzEsIDJdXG4gICAgICBdXG5cbiAgICAgIC8vIE1hcCBlYWNoIHNsb3BlIHRvIGl0cyBudW1iZXIgb2YgdHJlZXMgdGhlbiBtdWx0aXBseSB0aGVtIHRvZ2V0aGVyXG4gICAgICB0aGlzLnNvbHV0aW9ucy5wYXJ0VHdvID0gc2xvcGVzLm1hcChzID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZXN1bHRcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jaGVja1Nsb3BlKHNbMF0sIHNbMV0pXG4gICAgICAgIC8vIFNhdmUgdGhlIHBhdGggZm9yIGRyYXdpbmdcbiAgICAgICAgdGhpcy5wYXRoc1syXS5wdXNoKHJlc3VsdC5wYXRoKVxuICAgICAgICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0cmVlc1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRyZWVzXG4gICAgICB9KVxuICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSlcblxuICAgICAgLy8gU3RhcnQgdGhlIGRyYXdlclxuICAgICAgdGhpcy5ncmlkVHdvID0gbmV3IFBhdGhEcmF3ZXIodGhpcy5wYXJzZWRJbnB1dCwgdGhpcy5wYXRoc1syXSkuZ2V0UGF0aEdyaWQoKVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBudW1iZXIgb2YgdHJlZXMgYW5kIGdyaWQgcG9pbnRzIG9uIHRoZSBwYXRoIGZyb20gdG9wIGxlZnQgd2l0aCB0aGUgZ2l2ZW4gZGVsdGEgc2xvcGVcbiAgICAgKiBAcGFyYW0gZGVsdGFYIFRoZSBkZWx0YSB2YWx1ZSBpbiB0aGUgeCBkaXJlY3Rpb24gKD49IDApXG4gICAgICogQHBhcmFtIGRlbHRhWSBUaGUgZGVsdGEgdmFsdWUgaW4gdGhlIHkgZGlyZWN0aW9uICg+PSAwKVxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgdHJlZXMgKGB0cmVlc2ApIGFuZCB0aGUgY2VsbHMgb24gdGhlIHBhdGggKGBwYXRoYClcbiAgICAgKi9cbiAgICBjaGVja1Nsb3BlOiBmdW5jdGlvbiAoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgIGxldCBjb3VudGVyID0gMFxuICAgICAgbGV0IHggPSAwXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBvdmVyYWxsIHggcG9zaXRpb24gZm9yIHJlcGVhdGVkIGdyaWRzXG4gICAgICBsZXQgdG90YWxYID0gMFxuICAgICAgLy8gVHJhY2sgYWxsIHRoZSBjZWxscyBvbiB0aGUgcGF0aFxuICAgICAgY29uc3QgcGF0aCA9IFtdXG4gICAgICAvLyBUcmF2ZXJzZSBpbiB5IGRpcmVjdGlvbiB3aXRoIGRlbHRhIHlcbiAgICAgIGZvciAobGV0IHkgPSBkZWx0YVk7IHkgPCB0aGlzLnBhcnNlZElucHV0Lmxlbmd0aDsgeSArPSBkZWx0YVkpIHtcbiAgICAgICAgLy8gQWRkIHRvIHRvdGFsIHhcbiAgICAgICAgdG90YWxYICs9IGRlbHRhWFxuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHggYmFzZWQgb24gd3JhcHBpbmdcbiAgICAgICAgeCA9ICh4ICsgZGVsdGFYKSAlIHRoaXMucGFyc2VkSW5wdXRbeV0ubGVuZ3RoXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSB0cmVlXG4gICAgICAgIGlmICh0aGlzLnBhcnNlZElucHV0W3ldW3hdKSB7XG4gICAgICAgICAgY291bnRlcisrXG4gICAgICAgICAgcGF0aC5wdXNoKHsgeDogdG90YWxYLCB5OiB5LCBoaXQ6IHRydWUgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goeyB4OiB0b3RhbFgsIHk6IHksIGhpdDogZmFsc2UgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB0cmVlczogY291bnRlclxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbi5kYXktMy1jb2RlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJjM2U1MDtcbiAgY29sb3I6ICM3ZjhjOGQ7XG4gIG1heC1oZWlnaHQ6IDMwMHB4O1xufVxuLmRheS0zLXBhdGgtaGl0IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJlY2M3MTtcbiAgY29sb3I6ICMyYzNlNTA7XG59XG4uZGF5LTMtcGF0aC1taXNzIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VjZjBmMTtcbiAgY29sb3I6ICMyYzNlNTA7XG59XG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9EYXkzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTQwLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTEyLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTEyLnVzZVsyXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0RheTMudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTAyNzI0MmQmcHJvZCZsYW5nPWNzc1wiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9EYXkzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xMDI3MjQyZFwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0RheTMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0RheTMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vRGF5My52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xMDI3MjQyZCZwcm9kJmxhbmc9Y3NzXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6WyJQYXRoRHJhd2VyIiwiY29uc3RydWN0b3IiLCJpbnB1dCIsInBhdGhzIiwiJGlucHV0IiwiJHBhdGhzIiwiZ2V0UGF0aEdyaWQiLCJyZXN1bHQiLCJ4UmVwZWF0cyIsIm1hcCIsInAiLCJNYXRoIiwiY2VpbCIsImxlbmd0aCIsIngiLCJyZWR1Y2UiLCJhIiwiYiIsIm1heCIsIm9uUGF0aCIsImZvckVhY2giLCJjIiwieSIsImhpdCIsInJlcCIsInZhbHVlIiwidG90YWxYIiwiaXNIaXQiLCJjb21wb25lbnRzIiwiRGF5IiwiZGF0YSIsInNvbHV0aW9ucyIsInBhcnRPbmUiLCJwYXJ0VHdvIiwicGFyc2VkSW5wdXQiLCJncmlkT25lIiwiZ3JpZFR3byIsIm1ldGhvZHMiLCJvbklucHV0Q2hhbmdlZCIsInNvbHZlUGFydE9uZSIsInNvbHZlUGFydFR3byIsImNoZWNrU2xvcGUiLCJjb3VudGVyIiwicGF0aCIsInRyZWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32002\n')}}]);