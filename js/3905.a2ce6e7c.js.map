{"version":3,"file":"js/3905.a2ce6e7c.js","mappings":"yKAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,IAAM,GAAG,KAAO,KAAK,UAAYN,EAAIO,WAAWC,GAAG,CAAC,gBAAgBR,EAAIS,gBAAgBC,YAAYV,EAAIW,GAAG,CAAC,CAACC,IAAI,UAAUC,GAAG,WAAW,MAAO,CAACT,EAAG,MAAM,CAACU,YAAY,iBAAiB,CAACV,EAAG,SAAS,CAACU,YAAY,SAASR,MAAM,CAAC,GAAK,UAAU,MAAQ,OAAO,OAAS,YAAY,EAAES,OAAM,MAAS,EACnZC,EAAkB,G,iCCctB,GACAC,WAAAA,CACAC,IAAAA,EAAAA,GAEAC,KAAAA,WACA,OACAZ,UAAAA,CACAa,QAAAA,KACAC,QAAAA,MAEAC,WAAAA,CAAAA,EAAAA,EAAAA,GAAAA,CAAAA,EAAAA,GAAAA,CAAAA,GAAAA,GAAAA,CAAAA,EAAAA,IAEA,EACAC,QAAAA,CACAd,eAAAA,SAAAA,GACA,OAAAe,EAAAA,EAAAC,EAAAA,GAEA,WAEA,qBAEAC,EAAAA,SAAAA,CAAAA,EAAAA,KACA,oBACA,kBAEA,QACAC,EAAAA,CAAAH,EAAAA,EAAAC,EAAAA,IAGA,aACA,qBAGAG,EAAAA,SAAAA,CAAAA,EAAAA,KACA,UACAD,EAAAA,EAAAA,EACAA,EAAAA,EAAAA,GAGAE,EAAAA,GAAAA,KAAAA,KAAAA,CAAAA,GACA,IAGA,kCACA,mCACA,kCACA,mCAEA,WACAC,OAAAA,KAAAA,GAAAA,SAAAA,IACA,kCACAN,GAAAA,EAAAA,EACAC,GAAAA,EAAAA,EAEA,gCACA,gCACA,gCACA,gCAEAM,EAAAA,GAAAA,KAAAA,KAAAA,EAAAA,EAAAA,IAEAJ,EAAAA,CAAAH,EAAAA,EAAAC,EAAAA,GAEA,YAEA,8BAEA,sEACA,oCAGA,EACAO,aAAAA,WACA,iBAEA,QACA,cACA,qBAEAC,GAAAA,KAAAA,MAAAA,EAAAA,EAAAA,GAAAA,GAGAA,GAAAA,EAEAA,GAAAA,KAAAA,KAAAA,EAAAA,GACAC,QAAAA,IAAAA,EAAAA,GAGA,WAEAJ,OAAAA,KAAAA,KAAAA,MAAAA,SAAAA,IACA,oCAEA,oBACAK,EAAAA,KAAAA,CAAAX,EAAAA,EAAAC,EAAAA,GACA,IAGAS,QAAAA,IAAAA,EAAAA,QAEA,QACA,sBACA,uBACA,gCAEA,kBACA,mBACA,2CAGA,GACAE,GAEA,CACA,CAGAF,QAAAA,IAAAA,iBAAAA,EAwBA,EACAG,aAAAA,SAAAA,GACA,WAEA,qCACA,qCACA,+CACA,gCAEA,OACAC,EAAAA,GAAAA,KAAAA,KAAAA,EAEA,CAIA,QACA,EACAC,KAAAA,SAAAA,EAAAA,GACA,gCACA,oBAGA,+CACA,sCAGA,cACA,yCACA,2CAEA,0BACA,qBAEA,6BACA,4DAEA,4BACA,sBAEA,qCACA,sCACA,+BAEA,+BACA,6BAEA,SACA,8EAEA,CAGAC,OAAAA,uBAAAA,IAAAA,KAAAA,SAAAA,EAAAA,EAAAA,IACA,EACAC,SAAAA,SAAAA,EAAAA,EAAAA,GACA,gGAEA,WACA,6BAIAb,EAAAA,SAAAA,IACA,oDACA,qFAEA,0BACA,6BACA,qBACA,8GACA,gBACA,IAGA,oBACAY,OAAAA,uBAAAA,IAAAA,KAAAA,SAAAA,EAAAA,EAAAA,KACA,ICzO6P,I,UCOzPE,GAAY,OACd,EACA3C,EACAiB,GACA,EACA,KACA,KACA,MAIF,EAAe0B,EAAiB,O,yGClBhC,MAAMC,EAAU,CAAC,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,WAM3LC,EAAYC,IAChB,MAAMC,EAAS,4CAA4CC,KAAKF,GAChE,OAAOC,EACH,CACAE,EAAGC,SAASH,EAAO,GAAI,IACvBI,EAAGD,SAASH,EAAO,GAAI,IACvBK,EAAGF,SAASH,EAAO,GAAI,KAEvB,IAAI,EASJM,EAAWA,CAACJ,EAAGE,EAAGC,IACf,MAAQ,GAAK,KAAOH,GAAK,KAAOE,GAAK,GAAKC,GAAGE,SAAS,IAAIC,MAAM,GASnEC,EAAsBA,CAACC,EAAKC,EAAKC,KACrC,MAAMC,EAASf,EAASY,GAClBI,EAAShB,EAASa,GAExB,GAAIC,EAAQ,EACV,MAAO,CAACF,GAGV,MAAMV,EAAS,GACf,IAAK,IAAIe,EAAI,EAAGA,EAAIH,EAAOG,IAAK,CAC9B,MAAMC,EAASD,GAAKH,EAAQ,GAC5BZ,EAAOiB,KAAKX,EACVY,KAAKC,MAAMN,EAAOX,EAAIc,GAASF,EAAOZ,EAAIW,EAAOX,IACjDgB,KAAKC,MAAMN,EAAOT,EAAIY,GAASF,EAAOV,EAAIS,EAAOT,IACjDc,KAAKC,MAAMN,EAAOR,EAAIW,GAASF,EAAOT,EAAIQ,EAAOR,KAErD,CACA,OAAOL,CAAM,EAGToB,EAA2BA,CAACC,EAAQT,KACxC,GAAIS,EAAOC,OAASV,EAClB,OAAOS,EAAOb,MAAM,EAAGI,GAGzB,MAAMW,EAAWF,EAAOC,OAAS,EAEjC,IAAItB,EAAS,GAEb,IAAK,IAAIe,EAAI,EAAGA,EAAIQ,EAAW,EAAGR,IAChCf,EAASA,EAAOwB,OAAOf,EAAoBY,EAAON,GAAIM,EAAON,EAAI,GAAIG,KAAKO,IAAI,EAAGP,KAAKC,MAAMP,EAAQW,MAGtG,MAAOvB,EAAOsB,OAASV,EACrBZ,EAAOiB,KAAKI,EAAOA,EAAOC,OAAS,IAGrC,OAAOtB,CAAM,C,yGCtEf,MAAM0B,EAAMA,CAACC,EAAGtB,KACLsB,EAAItB,EAAKA,GAAKA,EAGnBuB,EAAaC,IACjB,MAAMC,EAAOD,EAAOP,OACdS,EAAOF,EAAO,GAAGP,OACjBvC,EAAO,GACb,IAAK,IAAIiD,EAAI,EAAGA,EAAID,EAAMC,IACxBjD,EAAKiD,GAAKC,MAAMH,GAElB,IAAK,IAAIf,EAAI,EAAGA,EAAIe,EAAMf,IACxB,IAAK,IAAIiB,EAAI,EAAGA,EAAID,EAAMC,IACxBjD,EAAKiD,GAAGjB,GAAKc,EAAOd,GAAGiB,GAG3B,OAAOjD,CAAI,EAGPmD,EAAMA,CAACP,EAAGtB,IAAY,IAANA,EAAUsB,EAAIO,EAAI7B,EAAGsB,EAAItB,GACzC8B,EAAcA,CAACR,EAAGtB,IAAMsB,EAAIO,EAAIP,EAAGtB,GAAKA,EACxC+B,EAAUC,GAAOA,EAAGC,OAAOH,EAAa,GAExCI,EAAOC,GAAWJ,EAAOI,E","sources":["webpack://advent-of-code/./src/components/2023/Day21.vue?3788","webpack://advent-of-code/src/components/2023/Day21.vue","webpack://advent-of-code/./src/components/2023/Day21.vue?3585","webpack://advent-of-code/./src/components/2023/Day21.vue","webpack://advent-of-code/./src/util/color.js","webpack://advent-of-code/./src/util/math.js"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Day',{attrs:{\"day\":21,\"year\":2023,\"solutions\":_vm.solutions},on:{\"input-changed\":_vm.onInputChanged},scopedSlots:_vm._u([{key:\"partOne\",fn:function(){return [_c('div',{staticClass:\"canvas-holder\"},[_c('canvas',{staticClass:\"canvas\",attrs:{\"id\":\"partOne\",\"width\":\"1000\",\"height\":\"1000\"}})])]},proxy:true}])})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <Day :day=\"21\" :year=\"2023\" :solutions=\"solutions\" @input-changed=\"onInputChanged\">\n    <template v-slot:partOne>\n      <div class=\"canvas-holder\">\n        <canvas id=\"partOne\" class=\"canvas\" width=\"1000\" height=\"1000\" />\n      </div>\n    </template>\n  </Day>\n</template>\n\n<script>\nimport Day from '@/components/Day'\nimport { createMultiColorGradient, VIRIDIS } from '@/util/color'\nimport { mod } from '@/util/math'\n\nexport default {\n  components: {\n    Day\n  },\n  data: function () {\n    return {\n      solutions: {\n        partOne: null,\n        partTwo: null\n      },\n      directions: [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    }\n  },\n  methods: {\n    onInputChanged: function (input) {\n      let start = { x: 0, y: 0 }\n\n      const grid = {}\n\n      this.height = input.length\n\n      input.forEach((i, y) => {\n        const cells = i.split('')\n        const sIndex = i.indexOf('S')\n\n        if (sIndex !== -1) {\n          start = { x: sIndex, y: y }\n        }\n\n        if (!this.width) {\n          this.width = cells.length\n        }\n\n        cells.forEach((c, x) => {\n          if (c === 'S') {\n            start.x = x\n            start.y = y\n          }\n\n          grid[`${x}|${y}`] = c\n        })\n      })\n\n      this.minX = Number.MAX_SAFE_INTEGER\n      this.maxX = -Number.MAX_SAFE_INTEGER\n      this.minY = Number.MAX_SAFE_INTEGER\n      this.maxY = -Number.MAX_SAFE_INTEGER\n\n      const centeredGrid = {}\n      Object.keys(grid).forEach(k => {\n        let [x, y] = k.split('|').map(Number)\n        x -= start.x\n        y -= start.y\n\n        this.minX = Math.min(this.minX, x)\n        this.maxX = Math.max(this.maxX, x)\n        this.minY = Math.min(this.minY, y)\n        this.maxY = Math.max(this.maxY, y)\n\n        centeredGrid[`${x}|${y}`] = grid[k]\n      })\n      start = { x: 0, y: 0 }\n\n      this.grid = centeredGrid\n\n      const shortestPaths = this.solvePartOne(64)\n\n      this.solutions.partOne = Object.values(shortestPaths).filter(v => v % 2 === 0).length - 1\n      this.$nextTick(() => this.draw(start, shortestPaths))\n\n      // this.solutions.partTwo = this.solvePartTwo()\n    },\n    solvePartTwo: function () {\n      const maxDist = 26501365\n      // Calculate area\n      let total = 0\n      const delta = maxDist * 2 + 1\n      for (let i = 0; i <= maxDist; i++) {\n        // Ceiling and halfing gives us all odd distance spaces (this wouldn't work if dist was even)\n        total += Math.ceil((delta - (i * 2)) / 2)\n      }\n      // Double area\n      total *= 2\n      // Remove the widest line once, because it has been counted twice\n      total -= Math.ceil(delta / 2)\n      console.log(maxDist, total)\n\n      // For each original obstacle, remove each multiple in both dimensions up to boundary\n      const obstacles = []\n\n      Object.keys(this.grid).forEach(k => {\n        const [x, y] = k.split('|').map(Number)\n\n        if (this.grid[k] === '#') {\n          obstacles.push({ x: x, y: y })\n        }\n      })\n\n      console.log(obstacles.length)\n\n      let c = 0\n      for (let x = -maxDist; x <= maxDist; x++) {\n        for (let y = -maxDist; y <= maxDist; y++) {\n          const dist = Math.abs(x) + Math.abs(y)\n\n          if (dist <= maxDist && dist % 2 === 0) {\n            const isMultiple = obstacles.some(o => {\n              return mod(x, o.x) === 0 && mod(y, o.y) === 0\n            })\n\n            if (isMultiple) {\n              c++\n            }\n          }\n        }\n      }\n\n      console.log('multiple count', c)\n\n      // const toRemove = new Set()\n\n      // obstacles.forEach(o => {\n      //   const mx = Math.floor(maxDist / o.x)\n      //   const my = Math.floor(maxDist / o.y)\n\n      //   for (let x = 0; x <= mx; x++) {\n      //     for (let y = 0; y <= my; y++) {\n      //       const nx = o.x + o.x * x\n      //       const ny = o.y + o.y * y\n\n      //       const dist = Math.abs(nx) + Math.abs(ny)\n\n      //       if (dist < maxDist && dist % 2 === 0) {\n      //         // It's within range and it's got an even distance (otherwise it'd overlap with an area we already removed)\n      //         toRemove.add(`${nx}|${ny}`)\n      //       }\n      //     }\n      //   }\n      // })\n\n      // console.log(toRemove.size)\n    },\n    solvePartOne: function (maxDistance) {\n      const distances = {}\n\n      for (let x = this.minX; x <= this.maxX; x++) {\n        for (let y = this.minY; y <= this.maxY; y++) {\n          if (['.', 'S'].includes(this.grid[`${x}|${y}`])) {\n            const dist = Math.abs(x) + Math.abs(y)\n\n            if (dist <= maxDistance) {\n              distances[`${x}|${y}`] = dist\n            }\n          }\n        }\n      }\n\n      return distances\n    },\n    draw: function (start, shortestPaths) {\n      this.gradient = createMultiColorGradient(VIRIDIS, 65)\n      this.pathDistance = 0\n\n      // Initialise the canvas\n      this.canvas = document.getElementById('partOne')\n      this.ctx = this.canvas.getContext('2d')\n\n      // Set the canvas size\n      this.factor = 8\n      this.canvas.width = this.width * this.factor\n      this.canvas.height = this.height * this.factor\n\n      this.ctx.translate(0.5, 0.5)\n      this.ctx.lineWidth = 1\n\n      this.ctx.fillStyle = '#222222'\n      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\n\n      const dx = Math.abs(this.minX)\n      const dy = Math.abs(this.minY)\n\n      for (let y = this.minY; y <= this.maxY; y++) {\n        for (let x = this.minX; x <= this.maxX; x++) {\n          const cell = this.grid[`${x}|${y}`]\n\n          this.ctx.strokeStyle = '#34495e'\n          this.ctx.fillStyle = '#34495e'\n\n          if (cell === '#') {\n            this.ctx.fillRect((dx + x) * this.factor, (dy + y) * this.factor, this.factor, this.factor)\n          }\n        }\n      }\n\n      window.requestAnimationFrame(() => this.drawPath(shortestPaths, dx, dy))\n    },\n    drawPath: function (shortestPaths, dx, dy) {\n      const cells = Object.keys(shortestPaths).filter(k => shortestPaths[k] === this.pathDistance).map(k => k.split('|').map(Number))\n\n      if (cells.length < 1) {\n        this.ctx.translate(-0.5, -0.5)\n        return\n      }\n\n      cells.forEach(c => {\n        this.ctx.fillStyle = this.gradient[this.pathDistance]\n        this.ctx.fillRect((dx + c[0]) * this.factor, (dy + c[1]) * this.factor, this.factor, this.factor)\n\n        if (this.pathDistance % 2 === 0) {\n          this.ctx.fillStyle = '#222222'\n          this.ctx.beginPath()\n          this.ctx.arc((dx + c[0]) * this.factor + this.factor / 2, (dy + c[1]) * this.factor + this.factor / 2, this.factor / 4, 0, 2 * Math.PI)\n          this.ctx.fill()\n        }\n      })\n\n      this.pathDistance++\n      window.requestAnimationFrame(() => this.drawPath(shortestPaths, dx, dy))\n    }\n  }\n}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day21.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Day21.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Day21.vue?vue&type=template&id=202dc65c\"\nimport script from \"./Day21.vue?vue&type=script&lang=js\"\nexport * from \"./Day21.vue?vue&type=script&lang=js\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const VIRIDIS = ['#440154', '#48186a', '#472d7b', '#424086', '#3b528b', '#33638d', '#2c728e', '#26828e', '#21918c', '#1fa088', '#28ae80', '#3fbc73', '#5ec962', '#84d44b', '#addc30', '#d8e219', '#fde725']\n\n/**\n * Converts a HEX value into an RGB object\n * @param {String} hex The hex color\n */\nconst hexToRgb = (hex) => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n  return result\n    ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    }\n    : null\n}\n\n/**\n * Converts the given R, G, B values into a HEX color\n * @param {Number} r The red color component\n * @param {Number} g The green color component\n * @param {Number} b The blue color component\n */\nconst rgbToHex = (r, g, b) => {\n  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n}\n\n/**\n * Creates a linear gradient between the two given colors with the given number of steps\n * @param {String} one The first color in HEX\n * @param {String} two The second color in HEX\n * @param {Number} steps The number of steps between the two colors\n */\nconst createColorGradient = (one, two, steps) => {\n  const oneRgb = hexToRgb(one)\n  const twoRgb = hexToRgb(two)\n\n  if (steps < 2) {\n    return [one]\n  }\n\n  const result = []\n  for (let i = 0; i < steps; i++) {\n    const iNorm = (i / (steps - 1))\n    result.push(rgbToHex(\n      Math.floor(oneRgb.r + iNorm * (twoRgb.r - oneRgb.r)),\n      Math.floor(oneRgb.g + iNorm * (twoRgb.g - oneRgb.g)),\n      Math.floor(oneRgb.b + iNorm * (twoRgb.b - oneRgb.b))\n    ))\n  }\n  return result\n}\n\nconst createMultiColorGradient = (colors, steps) => {\n  if (colors.length > steps) {\n    return colors.slice(0, steps)\n  }\n\n  const sections = colors.length - 1\n\n  let result = []\n\n  for (let i = 0; i < sections - 1; i++) {\n    result = result.concat(createColorGradient(colors[i], colors[i + 1], Math.max(1, Math.floor(steps / sections))))\n  }\n\n  while (result.length < steps) {\n    result.push(colors[colors.length - 1])\n  }\n\n  return result\n}\n\nexport {\n  hexToRgb,\n  rgbToHex,\n  createColorGradient,\n  createMultiColorGradient,\n  VIRIDIS\n}\n","const mod = (a, b) => {\n  return ((a % b) + b) % b\n}\n\nconst transpose = (matrix) => {\n  const rows = matrix.length\n  const cols = matrix[0].length\n  const grid = []\n  for (let j = 0; j < cols; j++) {\n    grid[j] = Array(rows)\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      grid[j][i] = matrix[i][j]\n    }\n  }\n  return grid\n}\n\nconst gcd = (a, b) => b === 0 ? a : gcd(b, a % b)\nconst lcmInternal = (a, b) => a / gcd(a, b) * b\nconst lcmAll = (ns) => ns.reduce(lcmInternal, 1)\n\nconst lcm = (values) => lcmAll(values)\n\nexport {\n  mod,\n  transpose,\n  lcm\n}\n"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","solutions","on","onInputChanged","scopedSlots","_u","key","fn","staticClass","proxy","staticRenderFns","components","Day","data","partOne","partTwo","directions","methods","x","y","input","start","cells","grid","Object","centeredGrid","solvePartTwo","total","console","obstacles","c","solvePartOne","distances","draw","window","drawPath","component","VIRIDIS","hexToRgb","hex","result","exec","r","parseInt","g","b","rgbToHex","toString","slice","createColorGradient","one","two","steps","oneRgb","twoRgb","i","iNorm","push","Math","floor","createMultiColorGradient","colors","length","sections","concat","max","mod","a","transpose","matrix","rows","cols","j","Array","gcd","lcmInternal","lcmAll","ns","reduce","lcm","values"],"sourceRoot":""}